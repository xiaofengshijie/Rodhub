local cloneref = (cloneref or clonereference or function(instance: any) return instance end)
local InputService: UserInputService = cloneref(game:GetService("UserInputService"));
local TextService: TextService = cloneref(game:GetService("TextService"));
local CoreGui: CoreGui = cloneref(game:GetService("CoreGui"));
local Teams: Teams = cloneref(game:GetService("Teams"));
local Players: Players = cloneref(game:GetService("Players"));
local RunService: RunService = cloneref(game:GetService("RunService"));
local TweenService: TweenService = cloneref(game:GetService("TweenService"));

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait();
local Mouse = cloneref(LocalPlayer:GetMouse());

local setclipboard = setclipboard or nil
local getgenv = getgenv or function() return shared end
local ProtectGui = protectgui or (syn and syn.protect_gui) or function() end
local GetHUI = gethui or function() return CoreGui end

local DrawingLib = if typeof(Drawing) == "table" then Drawing else { drawing_replaced = true };
local IsBadDrawingLib = false;

local assert = function(condition, errorMessage) 
    if (not condition) then
        error(if errorMessage then errorMessage else "assert failed", 3);
    end;
end;

local function SafeParentUI(Instance: Instance, Parent: Instance | () -> Instance)
    local success, _error = pcall(function()
        if not Parent then
            Parent = CoreGui
        end

        local DestinationParent
        if typeof(Parent) == "function" then
            DestinationParent = Parent()
        else
            DestinationParent = Parent
        end

        Instance.Parent = DestinationParent
    end)

    if not (success and Instance.Parent) then
        Instance.Parent = LocalPlayer:WaitForChild("PlayerGui", math.huge)
    end
end

local function ParentUI(UI: Instance, SkipHiddenUI: boolean?)
    if SkipHiddenUI then
        SafeParentUI(UI, CoreGui)
        return
    end

    pcall(ProtectGui, UI)
    SafeParentUI(UI, GetHUI)
end

local ScreenGui = Instance.new("ScreenGui");
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global;
ScreenGui.DisplayOrder = 999;
ScreenGui.ResetOnSpawn = false;
ParentUI(ScreenGui);

local ModalScreenGui = Instance.new("ScreenGui");
ModalScreenGui.DisplayOrder = -1;
ModalScreenGui.ResetOnSpawn = false;
ModalScreenGui.IgnoreGuiInset = true;
ModalScreenGui.Enabled = false;
ParentUI(ModalScreenGui, true);

local ModalElement = Instance.new("TextButton");
ModalElement.BackgroundTransparency = 1;
ModalElement.Modal = true;
ModalElement.Size = UDim2.fromScale(1, 1);
ModalElement.AnchorPoint = Vector2.zero;
ModalElement.Text = "";
ModalElement.Parent = ModalScreenGui;

local LibraryMainOuterFrame = nil;

local Toggles = {};
local Options = {};
local Labels = {};
local Buttons = {};

local Library = {
    Registry = {};
    RegistryMap = {};
    HudRegistry = {};

    FontColor = Color3.fromRGB(255, 255, 255);
    MainColor = Color3.fromRGB(28, 28, 28);
    BackgroundColor = Color3.fromRGB(20, 20, 20);

    AccentColor = Color3.fromRGB(0, 85, 255);
    DisabledAccentColor = Color3.fromRGB(142, 142, 142);

    OutlineColor = Color3.fromRGB(50, 50, 50);
    DisabledOutlineColor = Color3.fromRGB(70, 70, 70);

    DisabledTextColor = Color3.fromRGB(142, 142, 142);

    RiskColor = Color3.fromRGB(255, 50, 50);

    Black = Color3.new(0, 0, 0);
    Font = Enum.Font.Code,

    OpenedFrames = {};
    DependencyBoxes = {};
    DependencyGroupboxes = {};

    UnloadSignals = {};
    Signals = {};

    ActiveTab = nil;
    TotalTabs = 0;

    ScreenGui = ScreenGui;
    KeybindFrame = nil;
    KeybindContainer = nil;
    Window = { Holder = nil; Tabs = {}; };

    VideoLink = "";
    
    Toggled = false;
    ToggleKeybind = nil;

    IsMobile = false;
    DevicePlatform = Enum.Platform.None;

    CanDrag = true;
    CantDragForced = false;

    Notify = nil;
    NotifySide = "Left";
    ShowCustomCursor = true;
    ShowToggleFrameInKeybinds = true;
    NotifyOnError = false;

    SaveManager = nil;
    ThemeManager = nil;

    Toggles = Toggles;
    Options = Options;
    Labels = Labels;
    Buttons = Buttons;
};

if RunService:IsStudio() then
   Library.IsMobile = InputService.TouchEnabled and not InputService.MouseEnabled 
else
    pcall(function() Library.DevicePlatform = InputService:GetPlatform(); end);
    Library.IsMobile = (Library.DevicePlatform == Enum.Platform.Android or Library.DevicePlatform == Enum.Platform.IOS);
end

Library.MinSize = if Library.IsMobile then Vector2.new(550, 200) else Vector2.new(550, 300);

local RainbowStep = 0
local Hue = 0
local DPIScale = 1

table.insert(Library.Signals, RunService.RenderStepped:Connect(function(Delta)
    RainbowStep = RainbowStep + Delta

    if RainbowStep >= (1 / 60) then
        RainbowStep = 0;

        Hue = Hue + (1 / 400);

        if Hue > 1 then
            Hue = 0;
        end;

        Library.CurrentRainbowHue = Hue;
        Library.CurrentRainbowColor = Color3.fromHSV(Hue, 0.8, 1);
    end;
end));

local function ApplyDPIScale(Position)
    return UDim2.new(Position.X.Scale, Position.X.Offset * DPIScale, Position.Y.Scale, Position.Y.Offset * DPIScale);
end;

local function ApplyTextScale(TextSize)
    return TextSize * DPIScale;
end;

local function GetTableSize(t)
    local n = 0
    for _, _ in pairs(t) do
        n = n + 1
    end
    return n;
end;

local function GetPlayers(ExcludeLocalPlayer, ReturnInstances)
    local PlayerList = Players:GetPlayers();

    if ExcludeLocalPlayer then
        local Idx = table.find(PlayerList, LocalPlayer);

        if Idx then
            table.remove(PlayerList, Idx);
        end
    end

    table.sort(PlayerList, function(Player1, Player2)
        return Player1.Name:lower() < Player2.Name:lower();
    end)

    if ReturnInstances == true then
        return PlayerList;
    end;

    local FixedPlayerList = {};
    for _, player in next, PlayerList do
        FixedPlayerList[#FixedPlayerList + 1] = player.Name;
    end;

    return FixedPlayerList;
end;

local function GetTeams(ReturnInstances)
    local TeamList = Teams:GetTeams();

    table.sort(TeamList, function(Team1, Team2)
        return Team1.Name:lower() < Team2.Name:lower();
    end)

    if ReturnInstances == true then
        return TeamList;
    end;

    local FixedTeamList = {};
    for _, team in next, TeamList do
        FixedTeamList[#FixedTeamList + 1] = team.Name;
    end;

    return FixedTeamList;
end;

function Library:SetDPIScale(value: number) 
    assert(type(value) == "number", "Expected type number for DPI scale but got " .. typeof(value))
    
    DPIScale = value / 100;
    Library.MinSize = (if Library.IsMobile then Vector2.new(550, 200) else Vector2.new(550, 300)) * DPIScale;
end;

function Library:SafeCallback(Func, ...)
    if not (Func and typeof(Func) == "function") then
        return;
    end;

    local Result = table.pack(xpcall(Func, function(Error)
        task.defer(error, debug.traceback(Error, 2))
        if Library.NotifyOnError then
            Library:Notify(Error)
        end

        return Error
    end, ...));

    if not Result[1] then
        return nil;
    end;

    return table.unpack(Result, 2, Result.n);
end;

function Library:AttemptSave()
    if (not Library.SaveManager) then return end;
    Library.SaveManager:Save();
end;

function Library:Create(Class, Properties)
    local _Instance = Class;

    if typeof(Class) == "string" then
        _Instance = Instance.new(Class);
    end;

    for Property, Value in next, Properties do
        if (Property == "Size" or Property == "Position") then
            Value = ApplyDPIScale(Value);
        elseif Property == "TextSize" then
            Value = ApplyTextScale(Value);
        end;

        local success, err = pcall(function()
            _Instance[Property] = Value;
        end);

        if (not success) then
            warn(err);
        end;
    end;

    return _Instance;
end;

function Library:ApplyTextStroke(Inst)
    Inst.TextStrokeTransparency = 1;

    return Library:Create('UIStroke', {
        Color = Color3.new(0, 0, 0);
        Thickness = 1;
        LineJoinMode = Enum.LineJoinMode.Miter;
        Parent = Inst;
    });
end;

function Library:CreateLabel(Properties, IsHud)
    local _Instance = Library:Create('TextLabel', {
        BackgroundTransparency = 1;
        Font = Library.Font;
        TextColor3 = Library.FontColor;
        TextSize = 16;
        TextStrokeTransparency = 0;
    });

    Library:ApplyTextStroke(_Instance);

    Library:AddToRegistry(_Instance, {
        TextColor3 = 'FontColor';
    }, IsHud);

    return Library:Create(_Instance, Properties);
end;

function Library:MakeDraggable(Instance, Cutoff, IsMainWindow)
    Instance.Active = true;

    if Library.IsMobile == false then
        Instance.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if IsMainWindow == true and Library.CantDragForced == true then
                    return;
                end;
           
                local ObjPos = Vector2.new(
                    Mouse.X - Instance.AbsolutePosition.X,
                    Mouse.Y - Instance.AbsolutePosition.Y
                );

                if ObjPos.Y > (Cutoff or 40) then
                    return;
                end;

                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    Instance.Position = UDim2.new(
                        0,
                        Mouse.X - ObjPos.X + (Instance.Size.X.Offset * Instance.AnchorPoint.X),
                        0,
                        Mouse.Y - ObjPos.Y + (Instance.Size.Y.Offset * Instance.AnchorPoint.Y)
                    );

                    RunService.RenderStepped:Wait();
                end;
            end;
        end);
    else
        local Dragging, DraggingInput, DraggingStart, StartPosition;

        InputService.TouchStarted:Connect(function(Input)
            if IsMainWindow == true and Library.CantDragForced == true then
                Dragging = false
                return;
            end

            if not Dragging and Library:MouseIsOverFrame(Instance, Input) and (IsMainWindow == true and (Library.CanDrag == true and Library.Window.Holder.Visible == true) or true) then
                DraggingInput = Input;
                DraggingStart = Input.Position;
                StartPosition = Instance.Position;

                local OffsetPos = Input.Position - DraggingStart;
                if OffsetPos.Y > (Cutoff or 40) then
                    Dragging = false;
                    return;
                end;

                Dragging = true;
            end;
        end);
        InputService.TouchMoved:Connect(function(Input)
            if IsMainWindow == true and Library.CantDragForced == true then
                Dragging = false;
                return;
            end

            if Input == DraggingInput and Dragging and (IsMainWindow == true and (Library.CanDrag == true and Library.Window.Holder.Visible == true) or true) then
                local OffsetPos = Input.Position - DraggingStart;

                Instance.Position = UDim2.new(
                    StartPosition.X.Scale,
                    StartPosition.X.Offset + OffsetPos.X,
                    StartPosition.Y.Scale,
                    StartPosition.Y.Offset + OffsetPos.Y
                );
            end;
        end);
        InputService.TouchEnded:Connect(function(Input)
            if Input == DraggingInput then 
                Dragging = false;
            end;
        end);
    end;
end;

function Library:MakeDraggableUsingParent(Instance, Parent, Cutoff, IsMainWindow)
    Instance.Active = true;

    if Library.IsMobile == false then
        Instance.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if IsMainWindow == true and Library.CantDragForced == true then
                    return;
                end;
  
                local ObjPos = Vector2.new(
                    Mouse.X - Parent.AbsolutePosition.X,
                    Mouse.Y - Parent.AbsolutePosition.Y
                );

                if ObjPos.Y > (Cutoff or 40) then
                    return;
                end;

                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    Parent.Position = UDim2.new(
                        0,
                        Mouse.X - ObjPos.X + (Parent.Size.X.Offset * Parent.AnchorPoint.X),
                        0,
                        Mouse.Y - ObjPos.Y + (Parent.Size.Y.Offset * Parent.AnchorPoint.Y)
                    );

                    RunService.RenderStepped:Wait();
                end;
            end;
        end);
    else  
        Library:MakeDraggable(Parent, Cutoff, IsMainWindow)
    end;
end;

function Library:MakeResizable(Instance, MinSize)
    if Library.IsMobile then
        return;
    end;

    Instance.Active = true;
    
    local ResizerImage_Size = 25 * DPIScale;
    local ResizerImage_HoverTransparency = 0.5;

    local Resizer = Library:Create('Frame', {
        SizeConstraint = Enum.SizeConstraint.RelativeXX;
        BackgroundColor3 = Color3.new(0, 0, 0);
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        Size = UDim2.new(0, 30, 0, 30);
        Position = UDim2.new(1, -30, 1, -30);
        Visible = true;
        ClipsDescendants = true;
        ZIndex = 1;
        Parent = Instance;
    });

    local ResizerImage = Library:Create('ImageButton', {
        BackgroundColor3 = Library.AccentColor;
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        Size = UDim2.new(2, 0, 2, 0);
        Position = UDim2.new(1, -30, 1, -30);
        ZIndex = 2;
        Parent = Resizer;
    });

    local ResizerImageUICorner = Library:Create('UICorner', {
        CornerRadius = UDim.new(0.5, 0);
        Parent = ResizerImage;
    });

    Library:AddToRegistry(ResizerImage, { BackgroundColor3 = 'AccentColor'; });

    Resizer.Size = UDim2.fromOffset(ResizerImage_Size, ResizerImage_Size);
    Resizer.Position = UDim2.new(1, -ResizerImage_Size, 1, -ResizerImage_Size);
    MinSize = MinSize or Library.MinSize;

    local OffsetPos;
    Resizer.Parent = Instance;

    local function FinishResize(Transparency)
        ResizerImage.Position = UDim2.new();
        ResizerImage.Size = UDim2.new(2, 0, 2, 0);
        ResizerImage.Parent = Resizer;
        ResizerImage.BackgroundTransparency = Transparency;
        ResizerImageUICorner.Parent = ResizerImage;
        OffsetPos = nil;
    end;

    ResizerImage.MouseButton1Down:Connect(function()
        if not OffsetPos then
            OffsetPos = Vector2.new(Mouse.X - (Instance.AbsolutePosition.X + Instance.AbsoluteSize.X), Mouse.Y - (Instance.AbsolutePosition.Y + Instance.AbsoluteSize.Y));

            ResizerImage.BackgroundTransparency = 1
            ResizerImage.Size = UDim2.fromOffset(Library.ScreenGui.AbsoluteSize.X, Library.ScreenGui.AbsoluteSize.Y);
            ResizerImage.Position = UDim2.new();
            ResizerImageUICorner.Parent = nil;
            ResizerImage.Parent = Library.ScreenGui;
        end;
    end);

    ResizerImage.MouseMoved:Connect(function()
        if OffsetPos then		
            local MousePos = Vector2.new(Mouse.X - OffsetPos.X, Mouse.Y - OffsetPos.Y);
            local FinalSize = Vector2.new(math.clamp(MousePos.X - Instance.AbsolutePosition.X, MinSize.X, math.huge), math.clamp(MousePos.Y - Instance.AbsolutePosition.Y, MinSize.Y, math.huge));
            Instance.Size = UDim2.fromOffset(FinalSize.X, FinalSize.Y);
        end;
    end);

    ResizerImage.MouseEnter:Connect(function()
        FinishResize(ResizerImage_HoverTransparency);	
    end);

    ResizerImage.MouseLeave:Connect(function()
        FinishResize(1);
    end);

    ResizerImage.MouseButton1Up:Connect(function()
        FinishResize(ResizerImage_HoverTransparency);
    end);
end;

function Library:AddToolTip(InfoStr, DisabledInfoStr, HoverInstance)
    InfoStr = typeof(InfoStr) == "string" and InfoStr or nil;
    DisabledInfoStr = typeof(DisabledInfoStr) == "string" and DisabledInfoStr or nil;

    local Tooltip = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;

        ZIndex = 100;
        Parent = Library.ScreenGui;

        Visible = false;
    });

    local Label = Library:CreateLabel({
        Position = UDim2.fromOffset(3, 1);
        
        TextSize = 14;
        Text = InfoStr;
        TextColor3 = Library.FontColor;
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = Tooltip.ZIndex + 1;

        Parent = Tooltip;
    });

    Library:AddToRegistry(Tooltip, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'OutlineColor';
    });

    Library:AddToRegistry(Label, {
        TextColor3 = 'FontColor',
    });

    local TooltipTable = {
        Tooltip = Tooltip;
        Disabled = false;

        Signals = {};
    }
    local IsHovering = false

    local function UpdateText(Text)
        if Text == nil then return end

        local X, Y = Library:GetTextBounds(Text, Library.Font, 14 * DPIScale);

        Label.Text = Text;
        Tooltip.Size = UDim2.fromOffset(X + 5, Y + 4);
        Label.Size = UDim2.fromOffset(X, Y);
    end
    UpdateText(InfoStr);

    table.insert(TooltipTable.Signals, HoverInstance.MouseEnter:Connect(function()
        if Library:MouseIsOverOpenedFrame() then
            Tooltip.Visible = false
            return
        end

        if not TooltipTable.Disabled then
            if InfoStr == nil or InfoStr == "" then
                Tooltip.Visible = false
                return
            end

            if Label.Text ~= InfoStr then UpdateText(InfoStr); end
        else
            if DisabledInfoStr == nil or DisabledInfoStr == "" then
                Tooltip.Visible = false
                return
            end

            if Label.Text ~= DisabledInfoStr then UpdateText(DisabledInfoStr); end
        end

        IsHovering = true

        Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        Tooltip.Visible = true

        while IsHovering do
            if TooltipTable.Disabled == true and DisabledInfoStr == nil then break end

            RunService.Heartbeat:Wait()
            Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        end

        IsHovering = false
        Tooltip.Visible = false
    end))

    table.insert(TooltipTable.Signals, HoverInstance.MouseLeave:Connect(function()
        IsHovering = false
        Tooltip.Visible = false
    end))
    
    if LibraryMainOuterFrame then
        table.insert(TooltipTable.Signals, LibraryMainOuterFrame:GetPropertyChangedSignal("Visible"):Connect(function()
            if LibraryMainOuterFrame.Visible == false then
                IsHovering = false
                Tooltip.Visible = false
            end
        end))
    end

    function TooltipTable:Destroy()
        Tooltip:Destroy();

        for Idx = #TooltipTable.Signals, 1, -1 do
            local Connection = table.remove(TooltipTable.Signals, Idx);
            Connection:Disconnect();
        end
    end

    return TooltipTable
end

function Library:OnHighlight(HighlightInstance, Instance, Properties, PropertiesDefault, condition)
    local function undoHighlight()
        local Reg = Library.RegistryMap[Instance];

        for Property, ColorIdx in next, PropertiesDefault do
            Instance[Property] = Library[ColorIdx] or ColorIdx;

            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx;
            end;
        end;
    end
    local function doHighlight()
        if condition and not condition() then undoHighlight() return end
        local Reg = Library.RegistryMap[Instance];

        for Property, ColorIdx in next, Properties do
            Instance[Property] = Library[ColorIdx] or ColorIdx;

            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx;
            end;
        end;
    end

    HighlightInstance.MouseEnter:Connect(function()
        doHighlight()
    end)
    HighlightInstance.MouseMoved:Connect(function()
        doHighlight()
    end)
    HighlightInstance.MouseLeave:Connect(function()
        undoHighlight()
    end)
end;

function Library:MouseIsOverOpenedFrame(Input)
    local Pos = Mouse;
    if Library.IsMobile and Input then 
        Pos = Input.Position;
    end;

    for Frame, _ in next, Library.OpenedFrames do
        local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;

        if Pos.X >= AbsPos.X and Pos.X <= AbsPos.X + AbsSize.X
            and Pos.Y >= AbsPos.Y and Pos.Y <= AbsPos.Y + AbsSize.Y then

            return true;
        end;
    end;
end;

function Library:MouseIsOverFrame(Frame, Input)
    local Pos = Mouse;
    if Library.IsMobile and Input then 
        Pos = Input.Position;
    end;
    local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;

    if Pos.X >= AbsPos.X and Pos.X <= AbsPos.X + AbsSize.X
        and Pos.Y >= AbsPos.Y and Pos.Y <= AbsPos.Y + AbsSize.Y then

        return true;
    end;
end;

function Library:UpdateDependencyBoxes()
    for _, Depbox in next, Library.DependencyBoxes do
        Depbox:Update();
    end;
end;

function Library:UpdateDependencyGroupboxes()
    for _, Depbox in next, Library.DependencyGroupboxes do
        Depbox:Update();
    end;
end;

function Library:MapValue(Value, MinA, MaxA, MinB, MaxB)
    return (1 - ((Value - MinA) / (MaxA - MinA))) * MinB + ((Value - MinA) / (MaxA - MinA)) * MaxB;
end;

function Library:GetTextBounds(Text, Font, Size, Resolution)
    local Bounds = TextService:GetTextSize(Text:gsub("<%/?[%w:]+[^>]*>", ""), Size, Font, Resolution or Vector2.new(1920, 1080))
    return Bounds.X, Bounds.Y
end;

function Library:GetDarkerColor(Color)
    local H, S, V = Color3.toHSV(Color);
    return Color3.fromHSV(H, S, V / 1.5);
end;
Library.AccentColorDark = Library:GetDarkerColor(Library.AccentColor);

function Library:AddToRegistry(Instance, Properties, IsHud)
    local Idx = #Library.Registry + 1;
    local Data = {
        Instance = Instance;
        Properties = Properties;
        Idx = Idx;
    };

    table.insert(Library.Registry, Data);
    Library.RegistryMap[Instance] = Data;

    if IsHud then
        table.insert(Library.HudRegistry, Data);
    end;
end;

function Library:RemoveFromRegistry(Instance)
    local Data = Library.RegistryMap[Instance];

    if Data then
        for Idx = #Library.Registry, 1, -1 do
            if Library.Registry[Idx] == Data then
                table.remove(Library.Registry, Idx);
            end;
        end;

        for Idx = #Library.HudRegistry, 1, -1 do
            if Library.HudRegistry[Idx] == Data then
                table.remove(Library.HudRegistry, Idx);
            end;
        end;

        Library.RegistryMap[Instance] = nil;
    end;
end;

function Library:UpdateColorsUsingRegistry()
    for Idx, Object in next, Library.Registry do
        for Property, ColorIdx in next, Object.Properties do
            if typeof(ColorIdx) == "string" then
                Object.Instance[Property] = Library[ColorIdx];
            elseif typeof(ColorIdx) == 'function' then
                Object.Instance[Property] = ColorIdx()
            end
        end;
    end;
end;

function Library:GiveSignal(Signal)
    table.insert(Library.Signals, Signal)
end

function Library:Unload()
    for Idx = #Library.Signals, 1, -1 do
        local Connection = table.remove(Library.Signals, Idx)
        Connection:Disconnect()
    end

    for _, UnloadCallback in pairs(Library.UnloadSignals) do
        Library:SafeCallback(UnloadCallback)
    end

    ScreenGui:Destroy()
    ModalScreenGui:Destroy()
    Library.Unloaded = true
    getgenv().Linoria = nil
end

function Library:OnUnload(Callback)
    table.insert(Library.UnloadSignals, Callback)
end

Library:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)
    if Library.RegistryMap[Instance] then
        Library:RemoveFromRegistry(Instance);
    end;
end))

local function Trim(Text: string)
    return Text:match("^%s*(.-)%s*$")
end

local BaseAddons = {};

do
    local BaseAddonsFuncs = {};

    function BaseAddonsFuncs:AddColorPicker(Idx, Info)
        local ParentObj = self
        local ToggleLabel = self.TextLabel;

        assert(Info.Default, string.format('AddColorPicker (IDX: %s): Missing default value.', tostring(Idx)));

        local ColorPicker = {
            Value = Info.Default;
            Transparency = Info.Transparency or 0;
            Type = 'ColorPicker';
            Title = typeof(Info.Title) == "string" and Info.Title or 'Color picker',
            Callback = Info.Callback or function(Color) end;
        };

        function ColorPicker:SetHSVFromRGB(Color)
            local H, S, V = Color:ToHSV();

            ColorPicker.Hue = H;
            ColorPicker.Sat = S;
            ColorPicker.Vib = V;
        end;

        ColorPicker:SetHSVFromRGB(ColorPicker.Value);

        local DisplayFrame = Library:Create('Frame', {
            BackgroundColor3 = ColorPicker.Value;
            BorderColor3 = Library:GetDarkerColor(ColorPicker.Value);
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(0, 28, 0, 15);
            ZIndex = 6;
            Parent = ToggleLabel;
        });

        local CheckerFrame = Library:Create('ImageLabel', {
            BorderSizePixel = 0;
            Size = UDim2.new(0, 27, 0, 13);
            ZIndex = 5;
            Image = 'http://www.roblox.com/asset/?id=12977615774';
            Visible = not not Info.Transparency;
            Parent = DisplayFrame;
        });

        local PickerFrameOuter = Library:Create('Frame', {
            Name = 'Color';
            BackgroundColor3 = Color3.new(1, 1, 1);
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.fromOffset(DisplayFrame.AbsolutePosition.X, DisplayFrame.AbsolutePosition.Y + 18),
            Size = UDim2.fromOffset(230, Info.Transparency and 271 or 253);
            Visible = false;
            ZIndex = 15;
            Parent = ScreenGui,
        });

        DisplayFrame:GetPropertyChangedSignal('AbsolutePosition'):Connect(function()
            PickerFrameOuter.Position = UDim2.fromOffset(DisplayFrame.AbsolutePosition.X, DisplayFrame.AbsolutePosition.Y + 18);
        end)

        local PickerFrameInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 16;
            Parent = PickerFrameOuter;
        });

        local Highlight = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 0, 2);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local SatVibMapOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 4, 0, 25);
            Size = UDim2.new(0, 200, 0, 200);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local SatVibMapInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Parent = SatVibMapOuter;
        });

        local SatVibMap = Library:Create('ImageLabel', {
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Image = 'rbxassetid://4155801252';
            Parent = SatVibMapInner;
        });

        local CursorOuter = Library:Create('ImageLabel', {
            AnchorPoint = Vector2.new(0.5, 0.5);
            Size = UDim2.new(0, 6, 0, 6);
            BackgroundTransparency = 1;
            Image = 'http://www.roblox.com/asset/?id=9619665977';
            ImageColor3 = Color3.new(0, 0, 0);
            ZIndex = 19;
            Parent = SatVibMap;
        });

        local CursorInner = Library:Create('ImageLabel', {
            Size = UDim2.new(0, CursorOuter.Size.X.Offset - 2, 0, CursorOuter.Size.Y.Offset - 2);
            Position = UDim2.new(0, 1, 0, 1);
            BackgroundTransparency = 1;
            Image = 'http://www.roblox.com/asset/?id=9619665977';
            ZIndex = 20;
            Parent = CursorOuter;
        })

        local HueSelectorOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 208, 0, 25);
            Size = UDim2.new(0, 15, 0, 200);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local HueSelectorInner = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(1, 1, 1);
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Parent = HueSelectorOuter;
        });

        local HueCursor = Library:Create('Frame', { 
            BackgroundColor3 = Color3.new(1, 1, 1);
            AnchorPoint = Vector2.new(0, 0.5);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, 0, 0, 1);
            ZIndex = 18;
            Parent = HueSelectorInner;
        });

        local HueBoxOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.fromOffset(4, 228),
            Size = UDim2.new(0.5, -6, 0, 20),
            ZIndex = 18,
            Parent = PickerFrameInner;
        });

        local HueBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18,
            Parent = HueBoxOuter;
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = HueBoxInner;
        });

        local HueBox = Library:Create('TextBox', {
            BackgroundTransparency = 1;
            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -5, 1, 0);
            Font = Library.Font;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = 'Hex color',
            Text = '#FFFFFF',
            TextColor3 = Library.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 20,
            Parent = HueBoxInner;
        });

        Library:ApplyTextStroke(HueBox);

        local RgbBoxBase = Library:Create(HueBoxOuter:Clone(), {
            Position = UDim2.new(0.5, 2, 0, 228),
            Size = UDim2.new(0.5, -6, 0, 20),
            Parent = PickerFrameInner
        });

        local RgbBox = Library:Create(RgbBoxBase.Frame:FindFirstChild('TextBox'), {
            Text = '255, 255, 255',
            PlaceholderText = 'RGB color',
            TextColor3 = Library.FontColor
        });

        local TransparencyBoxOuter, TransparencyBoxInner, TransparencyCursor;
        
        if Info.Transparency then 
            TransparencyBoxOuter = Library:Create('Frame', {
                BorderColor3 = Color3.new(0, 0, 0);
                Position = UDim2.fromOffset(4, 251);
                Size = UDim2.new(1, -8, 0, 15);
                ZIndex = 19;
                Parent = PickerFrameInner;
            });

            TransparencyBoxInner = Library:Create('Frame', {
                BackgroundColor3 = ColorPicker.Value;
                BorderColor3 = Library.OutlineColor;
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.new(1, 0, 1, 0);
                ZIndex = 19;
                Parent = TransparencyBoxOuter;
            });

            Library:AddToRegistry(TransparencyBoxInner, { BorderColor3 = 'OutlineColor' });

            Library:Create('ImageLabel', {
                BackgroundTransparency = 1;
                Size = UDim2.new(1, 0, 1, 0);
                Image = 'http://www.roblox.com/asset/?id=12978095818';
                ZIndex = 20;
                Parent = TransparencyBoxInner;
            });

            TransparencyCursor = Library:Create('Frame', { 
                BackgroundColor3 = Color3.new(1, 1, 1);
                AnchorPoint = Vector2.new(0.5, 0);
                BorderColor3 = Color3.new(0, 0, 0);
                Size = UDim2.new(0, 1, 1, 0);
                ZIndex = 21;
                Parent = TransparencyBoxInner;
            });
        end;

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 0, 14);
            Position = UDim2.fromOffset(5, 5);
            TextXAlignment = Enum.TextXAlignment.Left;
            TextSize = 14;
            Text = ColorPicker.Title,
            TextWrapped = false;
            ZIndex = 16;
            Parent = PickerFrameInner;
        });

        local ContextMenu = {}
        do
            ContextMenu.Options = {}
            ContextMenu.Container = Library:Create('Frame', {
                BorderColor3 = Color3.new(),
                ZIndex = 14,

                Visible = false,
                Parent = ScreenGui
            })

            ContextMenu.Inner = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.fromScale(1, 1);
                ZIndex = 15;
                Parent = ContextMenu.Container;
            });

            Library:Create('UIListLayout', {
                Name = 'Layout',
                FillDirection = Enum.FillDirection.Vertical;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Parent = ContextMenu.Inner;
            });

            Library:Create('UIPadding', {
                Name = 'Padding',
                PaddingLeft = UDim.new(0, 4),
                Parent = ContextMenu.Inner,
            });

            local function updateMenuPosition()
                ContextMenu.Container.Position = UDim2.fromOffset(
                    (DisplayFrame.AbsolutePosition.X + DisplayFrame.AbsoluteSize.X) + 4,
                    DisplayFrame.AbsolutePosition.Y + 1
                )
            end

            local function updateMenuSize()
                local menuWidth = 60
                for i, label in next, ContextMenu.Inner:GetChildren() do
                    if label:IsA('TextLabel') then
                        menuWidth = math.max(menuWidth, label.TextBounds.X)
                    end
                end

                ContextMenu.Container.Size = UDim2.fromOffset(
                    menuWidth + 8,
                    ContextMenu.Inner.Layout.AbsoluteContentSize.Y + 4
                )
            end

            DisplayFrame:GetPropertyChangedSignal('AbsolutePosition'):Connect(updateMenuPosition)
            ContextMenu.Inner.Layout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(updateMenuSize)

            task.spawn(updateMenuPosition)
            task.spawn(updateMenuSize)

            Library:AddToRegistry(ContextMenu.Inner, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'OutlineColor';
            });

            function ContextMenu:Show()
                if Library.IsMobile then
                    Library.CanDrag = false;
                end;

                self.Container.Visible = true;
            end

            function ContextMenu:Hide()
                if Library.IsMobile then
                    Library.CanDrag = true;
                end;
                
                self.Container.Visible = false;
            end

            function ContextMenu:AddOption(Str, Callback)
                if typeof(Callback) ~= 'function' then
                    Callback = function() end
                end

                local Button = Library:CreateLabel({
                    Active = false;
                    Size = UDim2.new(1, 0, 0, 15);
                    TextSize = 13;
                    Text = Str;
                    ZIndex = 16;
                    Parent = self.Inner;
                    TextXAlignment = Enum.TextXAlignment.Left,
                });

                Library:OnHighlight(Button, Button, 
                    { TextColor3 = 'AccentColor' },
                    { TextColor3 = 'FontColor' }
                );

                Button.InputBegan:Connect(function(Input)
                    if Input.UserInputType ~= Enum.UserInputType.MouseButton1 or Input.UserInputType ~= Enum.UserInputType.Touch then
                        return
                    end

                    Callback()
                end)
            end

            ContextMenu:AddOption('Copy color', function()
                Library.ColorClipboard = ColorPicker.Value
                Library:Notify('Copied color!', 2)
            end)

            ContextMenu:AddOption('Paste color', function()
                if not Library.ColorClipboard then
                    return Library:Notify('You have not copied a color!', 2)
                end

                ColorPicker:SetValueRGB(Library.ColorClipboard)
            end)

            ContextMenu:AddOption('Copy HEX', function()
                pcall(setclipboard, ColorPicker.Value:ToHex())
                Library:Notify('Copied hex code to clipboard!', 2)
            end)

            ContextMenu:AddOption('Copy RGB', function()
                pcall(setclipboard, table.concat({ math.floor(ColorPicker.Value.R * 255), math.floor(ColorPicker.Value.G * 255), math.floor(ColorPicker.Value.B * 255) }, ', '))
                Library:Notify('Copied RGB values to clipboard!', 2)
            end)
        end
        ColorPicker.ContextMenu = ContextMenu;

        Library:AddToRegistry(PickerFrameInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(Highlight, { BackgroundColor3 = 'AccentColor'; });
        Library:AddToRegistry(SatVibMapInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });

        Library:AddToRegistry(HueBoxInner, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBoxBase.Frame, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBox, { TextColor3 = 'FontColor', });
        Library:AddToRegistry(HueBox, { TextColor3 = 'FontColor', });

        local SequenceTable = {};

        for Hue = 0, 1, 0.1 do
            table.insert(SequenceTable, ColorSequenceKeypoint.new(Hue, Color3.fromHSV(Hue, 1, 1)));
        end;

        local HueSelectorGradient = Library:Create('UIGradient', {
            Color = ColorSequence.new(SequenceTable);
            Rotation = 90;
            Parent = HueSelectorInner;
        });

        function ColorPicker:Display()
            ColorPicker.Value = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib);
            SatVibMap.BackgroundColor3 = Color3.fromHSV(ColorPicker.Hue, 1, 1);

            Library:Create(DisplayFrame, {
                BackgroundColor3 = ColorPicker.Value;
                BackgroundTransparency = ColorPicker.Transparency;
                BorderColor3 = Library:GetDarkerColor(ColorPicker.Value);
            });

            if TransparencyBoxInner then
                TransparencyBoxInner.BackgroundColor3 = ColorPicker.Value;
                TransparencyCursor.Position = UDim2.new(1 - ColorPicker.Transparency, 0, 0, 0);
            end;

            CursorOuter.Position = UDim2.new(ColorPicker.Sat, 0, 1 - ColorPicker.Vib, 0);
            HueCursor.Position = UDim2.new(0, 0, ColorPicker.Hue, 0);

            HueBox.Text = '#' .. ColorPicker.Value:ToHex()
            RgbBox.Text = table.concat({ math.floor(ColorPicker.Value.R * 255), math.floor(ColorPicker.Value.G * 255), math.floor(ColorPicker.Value.B * 255) }, ', ')

            Library:SafeCallback(ColorPicker.Callback, ColorPicker.Value, ColorPicker.Transparency);
            Library:SafeCallback(ColorPicker.Changed, ColorPicker.Value, ColorPicker.Transparency);
        end;

        function ColorPicker:OnChanged(Func)
            ColorPicker.Changed = Func;
            
            Library:SafeCallback(Func, ColorPicker.Value, ColorPicker.Transparency);
        end;

        if ParentObj.Addons then
            table.insert(ParentObj.Addons, ColorPicker)
        end

        function ColorPicker:Show()
            for Frame, Val in next, Library.OpenedFrames do
                if Frame.Name == 'Color' then
                    Frame.Visible = false;
                    Library.OpenedFrames[Frame] = nil;
                end;
            end;

            PickerFrameOuter.Visible = true;
            Library.OpenedFrames[PickerFrameOuter] = true;
        end;

        function ColorPicker:Hide()
            PickerFrameOuter.Visible = false;
            Library.OpenedFrames[PickerFrameOuter] = nil;
        end;

        function ColorPicker:SetValue(HSV, Transparency)
            local Color = Color3.fromHSV(HSV[1], HSV[2], HSV[3]);

            ColorPicker.Transparency = Transparency or 0;
            ColorPicker:SetHSVFromRGB(Color);
            ColorPicker:Display();
        end;

        function ColorPicker:SetValueRGB(Color, Transparency)
            ColorPicker.Transparency = Transparency or 0;
            ColorPicker:SetHSVFromRGB(Color);
            ColorPicker:Display();
        end;

        HueBox.FocusLost:Connect(function(enter)
            if enter then
                local success, result = pcall(Color3.fromHex, HueBox.Text)
                if success and typeof(result) == 'Color3' then
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(result)
                end
            end

            ColorPicker:Display()
        end)

        RgbBox.FocusLost:Connect(function(enter)
            if enter then
                local r, g, b = RgbBox.Text:match('(%d+),%s*(%d+),%s*(%d+)')
                if r and g and b then
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(Color3.fromRGB(r, g, b))
                end
            end

            ColorPicker:Display()
        end)

        SatVibMap.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1 or Enum.UserInputType.Touch) do
                    local MinX = SatVibMap.AbsolutePosition.X;
                    local MaxX = MinX + SatVibMap.AbsoluteSize.X;
                    local MouseX = math.clamp(Mouse.X, MinX, MaxX);

                    local MinY = SatVibMap.AbsolutePosition.Y;
                    local MaxY = MinY + SatVibMap.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Sat = (MouseX - MinX) / (MaxX - MinX);
                    ColorPicker.Vib = 1 - ((MouseY - MinY) / (MaxY - MinY));
                    ColorPicker:Display();

                    RunService.RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        HueSelectorInner.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1 or Enum.UserInputType.Touch) do
                    local MinY = HueSelectorInner.AbsolutePosition.Y;
                    local MaxY = MinY + HueSelectorInner.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Hue = ((MouseY - MinY) / (MaxY - MinY));
                    ColorPicker:Display();

                    RunService.RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        DisplayFrame.InputBegan:Connect(function(Input)
            if Library:MouseIsOverOpenedFrame(Input) then
                return;
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                if PickerFrameOuter.Visible then
                    ColorPicker:Hide()
                else
                    ContextMenu:Hide()
                    ColorPicker:Show()
                end;
            elseif Input.UserInputType == Enum.UserInputType.MouseButton2 then
                ContextMenu:Show()
                ColorPicker:Hide()
            end
        end);

        if TransparencyBoxInner then
            TransparencyBoxInner.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                    while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1 or Enum.UserInputType.Touch) do
                        local MinX = TransparencyBoxInner.AbsolutePosition.X;
                        local MaxX = MinX + TransparencyBoxInner.AbsoluteSize.X;
                        local MouseX = math.clamp(Mouse.X, MinX, MaxX);

                        ColorPicker.Transparency = 1 - ((MouseX - MinX) / (MaxX - MinX));

                        ColorPicker:Display();

                        RunService.RenderStepped:Wait();
                    end;

                    Library:AttemptSave();
                end;
            end);
        end;

        Library:GiveSignal(InputService.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                local AbsPos, AbsSize = PickerFrameOuter.AbsolutePosition, PickerFrameOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - 20 - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    ColorPicker:Hide();
                end;

                if not Library:MouseIsOverFrame(ContextMenu.Container) then
                    ContextMenu:Hide()
                end
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton2 and ContextMenu.Container.Visible then
                if not Library:MouseIsOverFrame(ContextMenu.Container) and not Library:MouseIsOverFrame(DisplayFrame) then
                    ContextMenu:Hide()
                end
            end
        end))

        ColorPicker:Display();
        ColorPicker.DisplayFrame = DisplayFrame

        Options[Idx] = ColorPicker;

        return self;
    end;

    function BaseAddonsFuncs:AddKeyPicker(Idx, Info)
        local ParentObj = self;
        local ToggleLabel = self.TextLabel;

        assert(Info.Default, string.format('AddKeyPicker (IDX: %s): Missing default value.', tostring(Idx)));

        local KeyPicker = {
            Value = nil;
            Toggled = false;
            Mode = Info.Mode or 'Toggle';
            Type = 'KeyPicker';
            Callback = Info.Callback or function(Value) end;
            ChangedCallback = Info.ChangedCallback or function(New) end;
            SyncToggleState = Info.SyncToggleState or false;
        };

        local SpecialKeys = {
            ["MB1"] = Enum.UserInputType.MouseButton1,
            ["MB2"] = Enum.UserInputType.MouseButton2,
            ["MB3"] = Enum.UserInputType.MouseButton3
        }

        local SpecialKeysInput = {
            [Enum.UserInputType.MouseButton1] = "MB1",
            [Enum.UserInputType.MouseButton2] = "MB2",
            [Enum.UserInputType.MouseButton3] = "MB3"
        }

        if KeyPicker.Mode == "Press" then
            assert(ParentObj.Type == "Label", "KeyPicker with the mode 'Press' can be only applied on Labels.")
            
            KeyPicker.SyncToggleState = false
            Info.Modes = { "Press" }
            Info.Mode = "Press"
        end

        if KeyPicker.SyncToggleState then
            Info.Modes = { 'Toggle' }
            Info.Mode = 'Toggle'
        end

        local PickOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 28, 0, 15);
            ZIndex = 6;
            Parent = ToggleLabel;
        });

        local PickInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 7;
            Parent = PickOuter;
        });

        Library:AddToRegistry(PickInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 1, 0);
            TextSize = 13;
            Text = Info.Default;
            TextWrapped = true;
            ZIndex = 8;
            Parent = PickInner;
        });

        local KeybindsToggle = {}
        do
            local KeybindsToggleContainer = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Size = UDim2.new(1, 0, 0, 18);
                Visible = false;
                ZIndex = 110;
                Parent = Library.KeybindContainer;
            });

            local KeybindsToggleOuter = Library:Create('Frame', {
                BackgroundColor3 = Color3.new(0, 0, 0);
                BorderColor3 = Color3.new(0, 0, 0);
                Size = UDim2.new(0, 13, 0, 13);
                Position = UDim2.new(0, 0, 0, 6);
                Visible = true;
                ZIndex = 110;
                Parent = KeybindsToggleContainer;
            });

            Library:AddToRegistry(KeybindsToggleOuter, {
                BorderColor3 = 'Black';
            });

            local KeybindsToggleInner = Library:Create('Frame', {
                BackgroundColor3 = Library.MainColor;
                BorderColor3 = Library.OutlineColor;
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.new(1, 0, 1, 0);
                ZIndex = 111;
                Parent = KeybindsToggleOuter;
            });

            Library:AddToRegistry(KeybindsToggleInner, {
                BackgroundColor3 = 'MainColor';
                BorderColor3 = 'OutlineColor';
            });

            local KeybindsToggleLabel = Library:CreateLabel({
                BackgroundTransparency = 1;
                Size = UDim2.new(0, 216, 1, 0);
                Position = UDim2.new(1, 6, 0, -1);
                TextSize = 14;
                Text = "";
                TextXAlignment = Enum.TextXAlignment.Left;
                ZIndex = 111;
                Parent = KeybindsToggleInner;
            });

            Library:Create('UIListLayout', {
                Padding = UDim.new(0, 4);
                FillDirection = Enum.FillDirection.Horizontal;
                HorizontalAlignment = Enum.HorizontalAlignment.Right;
                VerticalAlignment = Enum.VerticalAlignment.Center;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Parent = KeybindsToggleLabel;
            });

            local KeybindsToggleRegion = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Size = UDim2.new(0, 170, 1, 0);
                ZIndex = 113;
                Parent = KeybindsToggleOuter;
            });

            Library:OnHighlight(KeybindsToggleRegion, KeybindsToggleOuter,
                { BorderColor3 = 'AccentColor' },
                { BorderColor3 = 'Black' },
                function()
                    return true
                end
            );

            function KeybindsToggle:Display(State)
                KeybindsToggleInner.BackgroundColor3 = State and Library.AccentColor or Library.MainColor;
                KeybindsToggleInner.BorderColor3 = State and Library.AccentColorDark or Library.OutlineColor;
                KeybindsToggleLabel.TextColor3 = State and Library.AccentColor or Library.FontColor;

                Library.RegistryMap[KeybindsToggleInner].Properties.BackgroundColor3 = State and 'AccentColor' or 'MainColor';
                Library.RegistryMap[KeybindsToggleInner].Properties.BorderColor3 = State and 'AccentColorDark' or 'OutlineColor';
                Library.RegistryMap[KeybindsToggleLabel].Properties.TextColor3 = State and 'AccentColor' or 'FontColor';
            end;

            function KeybindsToggle:SetText(Text)
                KeybindsToggleLabel.Text = Text
            end

            function KeybindsToggle:SetVisibility(bool)
                KeybindsToggleContainer.Visible = bool
            end

            function KeybindsToggle:SetNormal(bool)
                KeybindsToggle.Normal = bool

                KeybindsToggleOuter.BackgroundTransparency = if KeybindsToggle.Normal then 1 else 0;

                KeybindsToggleInner.BackgroundTransparency = if KeybindsToggle.Normal then 1 else 0;
                KeybindsToggleInner.BorderSizePixel = if KeybindsToggle.Normal then 0 else 1;

                KeybindsToggleLabel.Position = if KeybindsToggle.Normal then UDim2.new(1, -13, 0, -1) else UDim2.new(1, 6, 0, -1);
            end

            Library:GiveSignal(KeybindsToggleRegion.InputBegan:Connect(function(Input)
                if KeybindsToggle.Normal then return end
                                        
                if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                    KeyPicker.Toggled = not KeyPicker.Toggled;
                    KeyPicker:DoClick();
                end;
            end));

            KeybindsToggle.Loaded = true;
        end;

        local ModeSelectOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            BackgroundTransparency = 1;
            Size = UDim2.new(0, 80, 0, 0);
            Visible = false;
            ZIndex = 14;
            Parent = ScreenGui;
        });

        local function UpdateMenuOuterPos()
            ModeSelectOuter.Position = UDim2.fromOffset(ToggleLabel.AbsolutePosition.X + ToggleLabel.AbsoluteSize.X + 4, ToggleLabel.AbsolutePosition.Y);
        end

        UpdateMenuOuterPos();
        ToggleLabel:GetPropertyChangedSignal('AbsolutePosition'):Connect(UpdateMenuOuterPos);

        local ModeSelectInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 0, 3);
            ZIndex = 15;
            Parent = ModeSelectOuter;
        });

        Library:AddToRegistry(ModeSelectInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIListLayout', {
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = ModeSelectInner;
        });

        local Modes = Info.Modes or { 'Always', 'Toggle', 'Hold' };
        local ModeButtons = {};
        local UnbindButton = {};

        for Idx, Mode in next, Modes do
            local ModeButton = {};

            local Label = Library:CreateLabel({
                Active = false;
                Size = UDim2.new(1, 0, 0, 15);
                TextSize = 13;
                Text = Mode;
                ZIndex = 16;
                Parent = ModeSelectInner;
            });
            ModeSelectInner.Size = ModeSelectInner.Size + UDim2.new(0, 0, 0, 15)
            ModeSelectOuter.Size = ModeSelectOuter.Size + UDim2.new(0, 0, 0, 18)

            function ModeButton:Select()
                for _, Button in next, ModeButtons do
                    Button:Deselect();
                end;

                KeyPicker.Mode = Mode;

                Label.TextColor3 = Library.AccentColor;
                Library.RegistryMap[Label].Properties.TextColor3 = 'AccentColor';

                ModeSelectOuter.Visible = false;
            end;

            function ModeButton:Deselect()
                KeyPicker.Mode = nil;

                Label.TextColor3 = Library.FontColor;
                Library.RegistryMap[Label].Properties.TextColor3 = 'FontColor';
            end;

            Label.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    ModeButton:Select();
                end;
            end);

            if Mode == KeyPicker.Mode then
                ModeButton:Select();
            end;

            ModeButtons[Mode] = ModeButton;
        end;

        do
            local UnbindInner = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                BorderMode = Enum.BorderMode.Inset;
                Position = UDim2.new(0, 0, 0, ModeSelectInner.Size.Y.Offset + 3);
                Size = UDim2.new(1, 0, 0, 18);
                ZIndex = 15;
                Parent = ModeSelectOuter;
            });

            ModeSelectOuter.Size = ModeSelectOuter.Size + UDim2.new(0, 0, 0, 18)

            Library:AddToRegistry(UnbindInner, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'OutlineColor';
            });

            local UnbindLabel = Library:CreateLabel({
                Active = false;
                Size = UDim2.new(1, 0, 0, 15);
                TextSize = 13;
                Text = "Unbind Key";
                ZIndex = 16;
                Parent = UnbindInner;
            });

            function UnbindButton:UnbindKey()
                KeyPicker:SetValue({ nil, KeyPicker.Mode })
                ModeSelectOuter.Visible = false;
            end;

            UnbindLabel.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    UnbindButton:UnbindKey();
                end;
            end);
        end

        function KeyPicker:Update()
            if Info.NoUI then
                return;
            end;

            local State = KeyPicker:GetState();
            local ShowToggle = Library.ShowToggleFrameInKeybinds and KeyPicker.Mode == 'Toggle';

            if KeybindsToggle.Loaded then
                KeybindsToggle:SetNormal(not ShowToggle)

                KeybindsToggle:SetVisibility(true);
                KeybindsToggle:SetText(string.format('[%s] %s (%s)', tostring(KeyPicker.Value), Info.Text, KeyPicker.Mode));
                KeybindsToggle:Display(State);
            end

            local YSize = 0
            local XSize = 0

            for _, Frame in next, Library.KeybindContainer:GetChildren() do
                if Frame:IsA('Frame') and Frame.Visible then
                    YSize = YSize + 18;
                    local Label = Frame:FindFirstChild("TextLabel", true)
                    if not Label then continue end
                    
                    local LabelSize = Label.TextBounds.X + 20
                    if (LabelSize > XSize) then
                        XSize = LabelSize;
                    end
                end;
            end;

            Library.KeybindFrame.Size = UDim2.new(0, math.max(XSize + 10, 220), 0, (YSize + 23 + 6) * DPIScale);
            UpdateMenuOuterPos();
        end;

        function KeyPicker:GetState()
            if KeyPicker.Mode == 'Always' then
                return true;
            
            elseif KeyPicker.Mode == 'Hold' then
                if KeyPicker.Value == 'None' then
                    return false;
                end

                local Key = KeyPicker.Value;

                if SpecialKeys[Key] ~= nil then
                    return InputService:IsMouseButtonPressed(SpecialKeys[Key]) and not InputService:GetFocusedTextBox();
                else
                    return InputService:IsKeyDown(Enum.KeyCode[KeyPicker.Value]) and not InputService:GetFocusedTextBox();
                end;
            else
                return KeyPicker.Toggled;
            end;
        end;

        function KeyPicker:SetValue(Data)
            local Key, Mode = Data[1], Data[2];

            local IsKeyValid, UserInputType = pcall(function() 
                if SpecialKeys[Key] == nil then 
                    return Enum.KeyCode[Key];
                end; 

                return SpecialKeys[Key]; 
            end);

            if Key == nil then
                DisplayLabel.Text = "None";
                KeyPicker.Value = "None";

            elseif IsKeyValid  then
                DisplayLabel.Text = Key;
                KeyPicker.Value = Key;

            else
                DisplayLabel.Text = "Unknown";
                KeyPicker.Value = "Unknown";
            end

            if Mode ~= nil and ModeButtons[Mode] ~= nil then 
                ModeButtons[Mode]:Select(); 
            end;

            PickOuter.Size = UDim2.new(0, 999999, 0, 18);
            RunService.RenderStepped:Wait();
            PickOuter.Size = UDim2.new(0, math.max(28, DisplayLabel.TextBounds.X + 8), 0, 18);

            KeyPicker:Update();

            Library:SafeCallback(KeyPicker.ChangedCallback, UserInputType)
            Library:SafeCallback(KeyPicker.Changed, UserInputType)
        end;

        function KeyPicker:OnClick(Callback)
            KeyPicker.Clicked = Callback
        end

        function KeyPicker:OnChanged(Callback)
            KeyPicker.Changed = Callback
            Callback(KeyPicker.Value)
        end

        if ParentObj.Addons then
            table.insert(ParentObj.Addons, KeyPicker)
        end

        function KeyPicker:DoClick()
            if KeyPicker.Mode == "Press" then
                if KeyPicker.Toggled and Info.WaitForCallback == true then
                    return
                end

                KeyPicker.Toggled = true
            end

            if ParentObj.Type == 'Toggle' and KeyPicker.SyncToggleState then
                ParentObj:SetValue(not ParentObj.Value)
            end

            Library:SafeCallback(KeyPicker.Callback, KeyPicker.Toggled)
            Library:SafeCallback(KeyPicker.Clicked, KeyPicker.Toggled)

            if KeyPicker.Mode == "Press" then
                KeyPicker.Toggled = false
            end
        end

        function KeyPicker:SetModePickerVisibility(bool)
            ModeSelectOuter.Visible = bool;
        end

        function KeyPicker:GetModePickerVisibility()
            return ModeSelectOuter.Visible;
        end

        local Picking = false;

        PickOuter.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                Picking = true;

                DisplayLabel.Text = '';

                local Break;
                local Text = '';

                task.spawn(function()
                    while (not Break) do
                        if Text == '...' then
                            Text = '';
                        end;

                        Text = Text .. '.';
                        DisplayLabel.Text = Text;

                        task.wait(0.4);
                    end;
                end);

                task.wait(0.2);

                InputService.InputBegan:Once(function(Input)
                    local Key;

                    if SpecialKeysInput[Input.UserInputType] ~= nil then
                        Key = SpecialKeysInput[Input.UserInputType];
                        
                    elseif Input.UserInputType == Enum.UserInputType.Keyboard then
                        Key = Input.KeyCode == Enum.KeyCode.Escape and "None" or Input.KeyCode.Name
                    end

                    Break = true;
                    KeyPicker:SetValue({ Key, KeyPicker.Mode })

                    task.wait();
                    Picking = false;
                end);

            elseif Input.UserInputType == Enum.UserInputType.MouseButton2 and not Library:MouseIsOverOpenedFrame() then
                local visible = KeyPicker:GetModePickerVisibility()
                
                if visible == false then
                    for _, option in next, Options do
                        if option.Type == "KeyPicker" then
                            option:SetModePickerVisibility(false)
                        end
                    end
                end

                KeyPicker:SetModePickerVisibility(not visible)
            end;
        end)

        Library:GiveSignal(InputService.InputBegan:Connect(function(Input)
            if KeyPicker.Value == "Unknown" then return end
        
            if (not Picking) and (not InputService:GetFocusedTextBox()) then
                local Key = KeyPicker.Value;
                local HoldingKey = false;

                if Input.UserInputType == Enum.UserInputType.Keyboard then
                    if Input.KeyCode.Name == Key then
                        HoldingKey = true;
                    end;
                elseif SpecialKeysInput[Input.UserInputType] == Key then
                    HoldingKey = true;
                end;

                if KeyPicker.Mode == 'Toggle' then
                    if HoldingKey then
                        KeyPicker.Toggled = not KeyPicker.Toggled;
                        KeyPicker:DoClick();
                    end;
                elseif KeyPicker.Mode == "Press" then
                    if HoldingKey then
                        KeyPicker:DoClick();
                    end;
                end;

                KeyPicker:Update();
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = ModeSelectOuter.AbsolutePosition, ModeSelectOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - 20 - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    KeyPicker:SetModePickerVisibility(false);
                end;
            end;
        end))

        Library:GiveSignal(InputService.InputEnded:Connect(function(Input)
            if (not Picking) then
                KeyPicker:Update();
            end;
        end))
        
        KeyPicker:SetValue({ Info.Default, Info.Mode or 'Toggle' });
        KeyPicker.DisplayFrame = PickOuter

        Options[Idx] = KeyPicker;

        return self;
    end;

    function BaseAddonsFuncs:AddDropdown(Idx, Info)
        Info.ReturnInstanceInstead = if typeof(Info.ReturnInstanceInstead) == "boolean" then Info.ReturnInstanceInstead else false;

        if Info.SpecialType == 'Player' then
            Info.ExcludeLocalPlayer = if typeof(Info.ExcludeLocalPlayer) == "boolean" then Info.ExcludeLocalPlayer else false;

            Info.Values = GetPlayers(Info.ExcludeLocalPlayer, Info.ReturnInstanceInstead);
            Info.AllowNull = true;
        elseif Info.SpecialType == 'Team' then
            Info.Values = GetTeams(Info.ReturnInstanceInstead);
            Info.AllowNull = true;
        end;

        assert(Info.Values, string.format('AddDropdown (IDX: %s): Missing dropdown value list.', tostring(Idx)));
        if not (Info.AllowNull or Info.Default) then
            Info.Default = 1;
            warn(string.format('AddDropdown (IDX: %s): Missing default value, selected the first index instead. Pass `AllowNull` as true if this was intentional.', tostring(Idx)))
        end

        Info.Searchable = if typeof(Info.Searchable) == "boolean" then Info.Searchable else false;
        Info.FormatDisplayValue = if typeof(Info.FormatDisplayValue) == "function" then Info.FormatDisplayValue else nil;

        local Dropdown = {
            Values = Info.Values;
            Value = Info.Multi and {};
            DisabledValues = Info.DisabledValues or {};
            Multi = Info.Multi;
            Type = 'Dropdown';
            SpecialType = Info.SpecialType;
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled else false;
            Callback = Info.Callback or function(Value) end;

            OriginalText = Info.Text; Text = Info.Text;
            ExcludeLocalPlayer = Info.ExcludeLocalPlayer;
            ReturnInstanceInstead = Info.ReturnInstanceInstead;
        };

        local Tooltip;

        local ParentObj = self
        local ToggleLabel = self.TextLabel;
        local Container = self.Container;

        local RelativeOffset = 0;

        for _, Element in next, Container:GetChildren() do
            if not Element:IsA('UIListLayout') then
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            end;
        end;

        local DropdownOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 60, 0, 18);
            Visible = Dropdown.Visible;
            ZIndex = 6;
            Parent = ToggleLabel;
        });

        Library:AddToRegistry(DropdownOuter, {
            BorderColor3 = 'Black';
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = DropdownOuter;
        });

        Library:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = DropdownInner;
        });

        local DropdownInnerSearch;
        if Info.Searchable then
            DropdownInnerSearch = Library:Create('TextBox', {
                BackgroundTransparency = 1;
                Visible = false;

                Position = UDim2.new(0, 5, 0, 0);
                Size = UDim2.new(0.9, -5, 1, 0);

                Font = Library.Font;
                PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
                PlaceholderText = 'Search...';

                Text = '';
                TextColor3 = Library.FontColor;
                TextSize = 14;
                TextStrokeTransparency = 0;
                TextXAlignment = Enum.TextXAlignment.Left;

                ClearTextOnFocus = false;

                ZIndex = 7;
                Parent = DropdownOuter;
            });

            Library:ApplyTextStroke(DropdownInnerSearch);

            Library:AddToRegistry(DropdownInnerSearch, {
                TextColor3 = 'FontColor';
            });
        end

        local DropdownArrow = Library:Create('ImageLabel', {
            AnchorPoint = Vector2.new(0, 0.5);
            BackgroundTransparency = 1;
            Position = UDim2.new(1, -16, 0.5, 0);
            Size = UDim2.new(0, 12, 0, 12);
            Image = 'http://www.roblox.com/asset/?id=6282522798';
            ZIndex = 8;
            Parent = DropdownInner;
        });

        local ItemList = Library:CreateLabel({
            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -5, 1, 0);
            TextSize = 14;
            Text = '--';
            TextXAlignment = Enum.TextXAlignment.Left;
            TextWrapped = false;
            TextTruncate = Enum.TextTruncate.AtEnd;
            RichText = true;
            ZIndex = 7;
            Parent = DropdownInner;
        });

        Library:OnHighlight(DropdownOuter, DropdownOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' },
            function()
                return not Dropdown.Disabled;
            end
        );

        if typeof(Info.Tooltip) == "string" or typeof(Info.DisabledTooltip) == "string" then
            Tooltip = Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, DropdownOuter)
            Tooltip.Disabled = Dropdown.Disabled;
        end

        local MAX_DROPDOWN_ITEMS = if typeof(Info.MaxVisibleDropdownItems) == "number" then math.clamp(Info.MaxVisibleDropdownItems, 4, 16) else 8;

        local ListOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            ZIndex = 20;
            Visible = false;
            Parent = ScreenGui;
        });

        local OpenedXSizeForList = 0;

        local function RecalculateListPosition()
            ListOuter.Position = UDim2.fromOffset(DropdownOuter.AbsolutePosition.X, DropdownOuter.AbsolutePosition.Y + DropdownOuter.Size.Y.Offset + 1);
        end;

        local function RecalculateListSize(YSize)
            local Y = YSize or math.clamp(GetTableSize(Dropdown.Values) * (20 * DPIScale), 0, MAX_DROPDOWN_ITEMS * (20 * DPIScale)) + 1;
            ListOuter.Size = UDim2.fromOffset(ListOuter.Visible and OpenedXSizeForList or DropdownOuter.AbsoluteSize.X + 0.5, Y)
        end;

        RecalculateListPosition();
        RecalculateListSize();

        DropdownOuter:GetPropertyChangedSignal('AbsolutePosition'):Connect(RecalculateListPosition);
        DropdownOuter:GetPropertyChangedSignal('AbsoluteSize'):Connect(RecalculateListSize);

        local ListInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = ListOuter;
        });

        Library:AddToRegistry(ListInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = ListInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor,
        });

        Library:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = Scrolling;
        });

        function Dropdown:UpdateColors()
            ItemList.TextColor3 = Dropdown.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
            DropdownArrow.ImageColor3 = Dropdown.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
        end;

        function Dropdown:GenerateDisplayText(SelectedValue)
            local Str = '';

            if Info.Multi and typeof(SelectedValue) == "table" then
                for Idx, Value in next, Dropdown.Values do
                    local StringValue = if typeof(Value) == "Instance" then Value.Name else Value;

                    if SelectedValue[Value] then
                        Str = Str .. (Info.FormatDisplayValue and tostring(Info.FormatDisplayValue(StringValue)) or StringValue) .. ', ';
                    end;
                end;

                Str = Str:sub(1, #Str - 2);
                Str = (Str == '' and '--' or Str);
            else
                if not SelectedValue then
                    return '--';
                end;

                local StringValue = if typeof(SelectedValue) == "Instance" then SelectedValue.Name else tostring(SelectedValue);
                Str = Info.FormatDisplayValue and tostring(Info.FormatDisplayValue(StringValue)) or StringValue;
            end;

            return Str;
        end

        function Dropdown:Display()
            local Str = Dropdown:GenerateDisplayText(Dropdown.Value);
            ItemList.Text = Str;

            local X = ListOuter.Visible and OpenedXSizeForList or Library:GetTextBounds(ItemList.Text, Library.Font, ItemList.TextSize, Vector2.new(ToggleLabel.AbsoluteSize.X, math.huge)) + 26;
            DropdownOuter.Size = UDim2.new(0, X, 0, 18)
        end;

        function Dropdown:GetActiveValues()
            if Info.Multi then
                local T = {};

                for Value, Bool in next, Dropdown.Value do
                    table.insert(T, Value);
                end;

                return T;
            else
                return Dropdown.Value and 1 or 0;
            end;
        end;

        function Dropdown:BuildDropdownList()
            local Values = Dropdown.Values;
            local DisabledValues = Dropdown.DisabledValues;
            local Buttons = {};

            for _, Element in next, Scrolling:GetChildren() do
                if not Element:IsA('UIListLayout') then
                    Element:Destroy();
                end;
            end;

            local Count = 0;
            OpenedXSizeForList = DropdownOuter.AbsoluteSize.X + 0.5

            for Idx, Value in next, Values do
                local StringValue = if typeof(Value) == "Instance" then Value.Name else Value;
                if Info.Searchable and not string.lower(StringValue):match(string.lower(DropdownInnerSearch.Text)) then
                    continue;
                end

                local IsDisabled = table.find(DisabledValues, StringValue);
                local Table = {};

                Count = Count + 1;

                local Button = Library:Create('TextButton', {
                    AutoButtonColor = false,
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Size = UDim2.new(1, -1, 0, 20);
                    Text = '';
                    ZIndex = 23;
                    Parent = Scrolling;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'OutlineColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Active = false;
                    Size = UDim2.new(1, -6, 1, 0);
                    Position = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Text = Info.FormatDisplayValue and tostring(Info.FormatDisplayValue(StringValue)) or StringValue;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    RichText = true;
                    ZIndex = 25;
                    Parent = Button;
                });

                Library:OnHighlight(Button, Button,
                    { BorderColor3 = IsDisabled and 'DisabledAccentColor' or 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                local Selected;

                if Info.Multi then
                    Selected = Dropdown.Value[Value];
                else
                    Selected = Dropdown.Value == Value;
                end;

                function Table:UpdateButton()
                    if Info.Multi then
                        Selected = Dropdown.Value[Value];
                    else
                        Selected = Dropdown.Value == Value;
                    end;

                    ButtonLabel.TextColor3 = Selected and Library.AccentColor or (IsDisabled and Library.DisabledAccentColor or Library.FontColor);
                    Library.RegistryMap[ButtonLabel].Properties.TextColor3 = Selected and 'AccentColor' or (IsDisabled and 'DisabledAccentColor' or 'FontColor');
                end;

                if not IsDisabled then
                    Button.MouseButton1Click:Connect(function(Input)
                        local Try = not Selected;

                        if Dropdown:GetActiveValues() == 1 and (not Try) and (not Info.AllowNull) then
                        else
                            if Info.Multi then
                                Selected = Try;

                                if Selected then
                                    Dropdown.Value[Value] = true;
                                else
                                    Dropdown.Value[Value] = nil;
                                end;
                            else
                                Selected = Try;

                                if Selected then
                                    Dropdown.Value = Value;
                                else
                                    Dropdown.Value = nil;
                                end;

                                for _, OtherButton in next, Buttons do
                                    OtherButton:UpdateButton();
                                end;
                            end;

                            Table:UpdateButton();
                            Dropdown:Display();
                            
                            Library:UpdateDependencyBoxes();
                            Library:UpdateDependencyGroupboxes();
                            Library:SafeCallback(Dropdown.Callback, Dropdown.Value);
                            Library:SafeCallback(Dropdown.Changed, Dropdown.Value);

                            Library:AttemptSave();
                        end;
                    end);
                end

                Table:UpdateButton();
                Dropdown:Display();

                local Str = Dropdown:GenerateDisplayText(Value);
                local X = Library:GetTextBounds(Str, Library.Font, ItemList.TextSize, Vector2.new(ToggleLabel.AbsoluteSize.X, math.huge)) + 26;
                if X > OpenedXSizeForList then
                    OpenedXSizeForList = X;
                end;

                Buttons[Button] = Table;
            end;
            
            Scrolling.CanvasSize = UDim2.fromOffset(0, (Count * (20 * DPIScale)) + 1);

            Scrolling.Visible = false;
            Scrolling.Visible = true;

            local Y = math.clamp(Count * (20 * DPIScale), 0, MAX_DROPDOWN_ITEMS * (20 * DPIScale)) + 1;
            RecalculateListSize(Y);
        end;

        function Dropdown:SetValues(NewValues)
            if NewValues then
                Dropdown.Values = NewValues;
            end;

            Dropdown:BuildDropdownList();
        end;

        function Dropdown:AddValues(NewValues)
            if typeof(NewValues) == "table" then
                for _, val in pairs(NewValues) do
                    table.insert(Dropdown.Values, val);
                end
            elseif typeof(NewValues) == "string" then
                table.insert(Dropdown.Values, NewValues);
            else
                return;
            end

            Dropdown:BuildDropdownList();
        end;

        function Dropdown:SetDisabledValues(NewValues)
            if NewValues then
                Dropdown.DisabledValues = NewValues;
            end;

            Dropdown:BuildDropdownList();
        end

        function Dropdown:AddDisabledValues(DisabledValues)
            if typeof(DisabledValues) == "table" then
                for _, val in pairs(DisabledValues) do
                    table.insert(Dropdown.DisabledValues, val)
                end
            elseif typeof(DisabledValues) == "string" then
                table.insert(Dropdown.DisabledValues, DisabledValues)
            else
                return
            end

            Dropdown:BuildDropdownList()
        end

        function Dropdown:SetVisible(Visibility)
            Dropdown.Visible = Visibility;

            DropdownOuter.Visible = Dropdown.Visible;
            if not Dropdown.Visible then Dropdown:CloseDropdown(); end;
        end;

        function Dropdown:SetDisabled(Disabled)
            Dropdown.Disabled = Disabled;

            if Tooltip then
                Tooltip.Disabled = Disabled;
            end

            if Disabled then
                Dropdown:CloseDropdown();
            end

            Dropdown:Display();
            Dropdown:UpdateColors();
        end;

        function Dropdown:OpenDropdown()
            if Dropdown.Disabled then
                return;
            end;

            if Library.IsMobile then
                Library.CanDrag = false;
            end;

            if Info.Searchable then
                ItemList.Visible = false;
                DropdownInnerSearch.Text = "";
                DropdownInnerSearch.Visible = true;
            end
            
            ListOuter.Visible = true;
            Library.OpenedFrames[ListOuter] = true;
            DropdownArrow.Rotation = 180;

            Dropdown:Display();
            RecalculateListSize();
        end;

        function Dropdown:CloseDropdown()
            if Library.IsMobile then         
                Library.CanDrag = true;
            end;

            if Info.Searchable then
                DropdownInnerSearch.Text = "";
                DropdownInnerSearch.Visible = false;
                ItemList.Visible = true;
            end
        
            ListOuter.Visible = false;
            Library.OpenedFrames[ListOuter] = nil;
            DropdownArrow.Rotation = 0;

            Dropdown:Display();
            RecalculateListSize();
        end;

        function Dropdown:OnChanged(Func)
            Dropdown.Changed = Func;

            if Dropdown.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Dropdown.Value);
        end;

        function Dropdown:SetValue(Val)
            if Dropdown.Multi then
                local nTable = {};

                for Value, Bool in next, Val do
                    if table.find(Dropdown.Values, Value) then
                        nTable[Value] = true
                    end;
                end;

                Dropdown.Value = nTable;
            else
                if (not Val) then
                    Dropdown.Value = nil;
                elseif table.find(Dropdown.Values, Val) then
                    Dropdown.Value = Val;
                end;
            end;

            Dropdown:BuildDropdownList();

            if not Dropdown.Disabled then
                Library:SafeCallback(Dropdown.Callback, Dropdown.Value);
                Library:SafeCallback(Dropdown.Changed, Dropdown.Value);
            end;
        end;

        function Dropdown:SetText(...)
            return;
        end;

        DropdownOuter.InputBegan:Connect(function(Input)
            if Dropdown.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                if ListOuter.Visible then
                    Dropdown:CloseDropdown();
                else
                    Dropdown:OpenDropdown();
                end;
            end;
        end);

        if Info.Searchable then
            DropdownInnerSearch:GetPropertyChangedSignal("Text"):Connect(function()
                Dropdown:BuildDropdownList()
            end);
        end;

        InputService.InputBegan:Connect(function(Input)
            if Dropdown.Disabled then
                return;
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                local AbsPos, AbsSize = ListOuter.AbsolutePosition, ListOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - (20 * DPIScale) - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    Dropdown:CloseDropdown();
                end;
            end;
        end);

        Dropdown:BuildDropdownList();
        Dropdown:Display();

        local Defaults = {}

        if typeof(Info.Default) == "string" then
            local Idx = table.find(Dropdown.Values, Info.Default)
            if Idx then
                table.insert(Defaults, Idx)
            end
        elseif typeof(Info.Default) == 'table' then
            for _, Value in next, Info.Default do
                local Idx = table.find(Dropdown.Values, Value)
                if Idx then
                    table.insert(Defaults, Idx)
                end
            end
        elseif typeof(Info.Default) == 'number' and Dropdown.Values[Info.Default] ~= nil then
            table.insert(Defaults, Info.Default)
        end

        if next(Defaults) then
            for i = 1, #Defaults do
                local Index = Defaults[i]
                if Info.Multi then
                    Dropdown.Value[Dropdown.Values[Index]] = true
                else
                    Dropdown.Value = Dropdown.Values[Index];
                end

                if (not Info.Multi) then break end
            end

            Dropdown:BuildDropdownList();
            Dropdown:Display();
        end

        task.delay(0.1, Dropdown.UpdateColors, Dropdown)

        Dropdown.DisplayFrame = DropdownOuter;
        if ParentObj.Addons then
            table.insert(ParentObj.Addons, Dropdown)
        end

        Options[Idx] = Dropdown;

        return self;
    end;

    BaseAddons.__index = BaseAddonsFuncs;
    BaseAddons.__namecall = function(Table, Key, ...)
        return BaseAddonsFuncs[Key](...);
    end;
end;

local BaseGroupbox = {};

do
    local BaseGroupboxFuncs = {};

    function BaseGroupboxFuncs:AddBlank(Size, Visible)
        local Groupbox = self;
        local Container = Groupbox.Container;

        return Library:Create('Frame', {
            BackgroundTransparency = 1;
            Size = UDim2.new(1, 0, 0, Size);
            Visible = if typeof(Visible) == "boolean" then Visible else true;
            ZIndex = 1;
            Parent = Container;
        });
    end;

    function BaseGroupboxFuncs:AddLabel(...)
        local Data = {}

        if select(2, ...) ~= nil and typeof(select(2, ...)) == "table" then
            if select(1, ...) ~= nil then
                assert(typeof(select(1, ...)) == "string", "Expected string for Idx, got " .. typeof(select(1, ...)))
            end
            
            local Params = select(2, ...)

            Data.Text = Params.Text or ""
            Data.DoesWrap = Params.DoesWrap or false
            Data.Idx = select(1, ...)
        else
            Data.Text = select(1, ...) or ""
            Data.DoesWrap = select(2, ...) or false
            Data.Idx = select(3, ...) or nil
        end

        Data.OriginalText = Data.Text;
        
        local Label = {
            Type = "Label"
        };

        local Blank = nil;
        local Groupbox = self;
        local Container = Groupbox.Container;

        local TextLabel = Library:CreateLabel({
            Size = UDim2.new(1, -4, 0, 15);
            TextSize = 14;
            Text = Data.Text;
            TextWrapped = Data.DoesWrap or false,
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 5;
            Parent = Container;
            RichText = true;
        });

        if Data.DoesWrap then
            local Y = select(2, Library:GetTextBounds(Data.Text, Library.Font, 14 * DPIScale, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
            TextLabel.Size = UDim2.new(1, -4, 0, Y)
        else
            Library:Create('UIListLayout', {
                Padding = UDim.new(0, 4 * DPIScale);
                FillDirection = Enum.FillDirection.Horizontal;
                HorizontalAlignment = Enum.HorizontalAlignment.Right;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Parent = TextLabel;
            });
        end

        Label.TextLabel = TextLabel;
        Label.Container = Container;

        function Label:SetText(Text)
            TextLabel.Text = Text

            if Data.DoesWrap then
                local Y = select(2, Library:GetTextBounds(Text, Library.Font, 14 * DPIScale, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
                TextLabel.Size = UDim2.new(1, -4, 0, Y)
            end

            Groupbox:Resize();
        end

        if (not Data.DoesWrap) then
            setmetatable(Label, BaseAddons);
        end

        Blank = Groupbox:AddBlank(5);
        Groupbox:Resize();
        
        if Data.Idx then
            Labels[Data.Idx] = Label;
        else
            table.insert(Labels, Label);
        end

        return Label;
    end;
    
    function BaseGroupboxFuncs:AddButton(...)
        local Button = typeof(select(1, ...)) == "table" and select(1, ...) or {
            Text = select(1, ...),
            Func = select(2, ...)
        }
        Button.OriginalText = Button.Text;
        
        assert(typeof(Button.Func) == 'function', 'AddButton: `Func` callback is missing.');

        local Blank = nil;
        local Groupbox = self;
        local Container = Groupbox.Container;
        local IsVisible = if typeof(Button.Visible) == "boolean" then Button.Visible else true;

        local function CreateBaseButton(Button)
            local Outer = Library:Create('Frame', {
                BackgroundColor3 = Color3.new(0, 0, 0);
                BorderColor3 = Color3.new(0, 0, 0);
                Size = UDim2.new(1, -4, 0, 20);
                Visible = IsVisible;
                ZIndex = 5;
            });

            local Inner = Library:Create('Frame', {
                BackgroundColor3 = Library.MainColor;
                BorderColor3 = Library.OutlineColor;
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.new(1, 0, 1, 0);
                ZIndex = 6;
                Parent = Outer;
            });

            local Label = Library:CreateLabel({
                Size = UDim2.new(1, 0, 1, 0);
                TextSize = 14;
                Text = Button.Text;
                ZIndex = 6;
                Parent = Inner;
                RichText = true;
            });

            Library:Create('UIGradient', {
                Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
                });
                Rotation = 90;
                Parent = Inner;
            });

            Library:AddToRegistry(Outer, {
                BorderColor3 = 'Black';
            });

            Library:AddToRegistry(Inner, {
                BackgroundColor3 = 'MainColor';
                BorderColor3 = 'OutlineColor';
            });

            Library:OnHighlight(Outer, Outer,
                { BorderColor3 = 'AccentColor' },
                { BorderColor3 = 'Black' }
            );

            return Outer, Inner, Label
        end

        local function InitEvents(Button)
            local function WaitForEvent(event, timeout, validator)
                local bindable = Instance.new('BindableEvent')
                local connection = event:Once(function(...)

                    if typeof(validator) == 'function' and validator(...) then
                        bindable:Fire(true)
                    else
                        bindable:Fire(false)
                    end
                end)
                task.delay(timeout, function()
                    connection:disconnect()
                    bindable:Fire(false)
                end)
                return bindable.Event:Wait()
            end

            local function ValidateClick(Input)
                if Library:MouseIsOverOpenedFrame(Input) then
                    return false
                end

                if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    return true
                elseif Input.UserInputType == Enum.UserInputType.Touch then
                    return true
                else
                    return false
                end
            end

            Button.Outer.InputBegan:Connect(function(Input)
                if Button.Disabled then
                    return;
                end;

                if not ValidateClick(Input) then return end
                if Button.Locked then return end

                if Button.DoubleClick then
                    Library:RemoveFromRegistry(Button.Label)
                    Library:AddToRegistry(Button.Label, { TextColor3 = 'AccentColor' })

                    Button.Label.TextColor3 = Library.AccentColor
                    Button.Label.Text = 'Are you sure?'
                    Button.Locked = true

                    local clicked = WaitForEvent(Button.Outer.InputBegan, 0.5, ValidateClick)

                    Library:RemoveFromRegistry(Button.Label)
                    Library:AddToRegistry(Button.Label, { TextColor3 = 'FontColor' })

                    Button.Label.TextColor3 = Library.FontColor
                    Button.Label.Text = Button.Text
                    task.defer(rawset, Button, 'Locked', false)

                    if clicked then
                        Library:SafeCallback(Button.Func)
                    end

                    return
                end

                Library:SafeCallback(Button.Func);
            end)
        end

        Button.Outer, Button.Inner, Button.Label = CreateBaseButton(Button)
        Button.Outer.Parent = Container

        InitEvents(Button)

        function Button:AddButton(...)
            local SubButton = typeof(select(1, ...)) == "table" and select(1, ...) or {
                Text = select(1, ...),
                Func = select(2, ...)
            }

            assert(typeof(SubButton.Func) == 'function', 'AddButton: `Func` callback is missing.');

            self.Outer.Size = UDim2.new(0.5, -2, 0, 20 * DPIScale)

            SubButton.Outer, SubButton.Inner, SubButton.Label = CreateBaseButton(SubButton)

            SubButton.Outer.Position = UDim2.new(1, 3, 0, 0)
            SubButton.Outer.Size = UDim2.new(1, -3, 0, self.Outer.AbsoluteSize.Y)
            SubButton.Outer.Parent = self.Outer

            function SubButton:UpdateColors()
                SubButton.Label.TextColor3 = SubButton.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
            end;

            function SubButton:AddToolTip(tooltip, disabledTooltip)
                if typeof(tooltip) == "string" or typeof(disabledTooltip) == "string" then
                    if SubButton.TooltipTable then
                        SubButton.TooltipTable:Destroy()
                    end
                
                    SubButton.TooltipTable = Library:AddToolTip(tooltip, disabledTooltip, self.Outer)
                    SubButton.TooltipTable.Disabled = SubButton.Disabled;
                end

                return SubButton
            end

            function SubButton:SetDisabled(Disabled)
                SubButton.Disabled = Disabled;

                if SubButton.TooltipTable then
                    SubButton.TooltipTable.Disabled = Disabled;
                end

                SubButton:UpdateColors();
            end;

            function SubButton:SetText(Text)
                if typeof(Text) == "string" then
                    SubButton.Text = Text;
                    SubButton.Label.Text = SubButton.Text;
                end
            end;

            if typeof(SubButton.Tooltip) == "string" or typeof(SubButton.DisabledTooltip) == "string" then
                SubButton.TooltipTable = SubButton:AddToolTip(SubButton.Tooltip, SubButton.DisabledTooltip, SubButton.Outer)
                SubButton.TooltipTable.Disabled = SubButton.Disabled;
            end

            task.delay(0.1, SubButton.UpdateColors, SubButton);
            InitEvents(SubButton)

            table.insert(Buttons, SubButton);
            return SubButton
        end

        function Button:UpdateColors()
            Button.Label.TextColor3 = Button.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
        end;

        function Button:AddToolTip(tooltip, disabledTooltip)
            if typeof(tooltip) == "string" or typeof(disabledTooltip) == "string" then
                if Button.TooltipTable then
                    Button.TooltipTable:Destroy()
                end

                Button.TooltipTable = Library:AddToolTip(tooltip, disabledTooltip, self.Outer)
                Button.TooltipTable.Disabled = Button.Disabled;
            end

            return Button
        end;

        if typeof(Button.Tooltip) == "string" or typeof(Button.DisabledTooltip) == "string" then
            Button.TooltipTable = Button:AddToolTip(Button.Tooltip, Button.DisabledTooltip, Button.Outer)
            Button.TooltipTable.Disabled = Button.Disabled;
        end

        function Button:SetVisible(Visibility)
            IsVisible = Visibility;

            Button.Outer.Visible = IsVisible;
            if Blank then Blank.Visible = IsVisible end;

            Groupbox:Resize();
        end;

        function Button:SetText(Text)
            if typeof(Text) == "string" then
                Button.Text = Text;
                Button.Label.Text = Button.Text;
            end
        end;

        function Button:SetDisabled(Disabled)
            Button.Disabled = Disabled;

            if Button.TooltipTable then
                Button.TooltipTable.Disabled = Disabled;
            end

            Button:UpdateColors();
        end;

        task.delay(0.1, Button.UpdateColors, Button);
        Blank = Groupbox:AddBlank(5, IsVisible);
        Groupbox:Resize();

        table.insert(Buttons, Button);
        return Button;
    end;

    function BaseGroupboxFuncs:AddDivider()
        local Groupbox = self;
        local Container = self.Container

        local Divider = {
            Type = 'Divider',
        }

        Groupbox:AddBlank(2);
        local DividerOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 5);
            ZIndex = 5;
            Parent = Container;
        });

        local DividerInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = DividerOuter;
        });

        Library:AddToRegistry(DividerOuter, {
            BorderColor3 = 'Black';
        });

        Library:AddToRegistry(DividerInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Groupbox:AddBlank(9);
        Groupbox:Resize();
    end

    function BaseGroupboxFuncs:AddInput(Idx, Info)
        assert(Info.Text, string.format('AddInput (IDX: %s): Missing `Text` string.', tostring(Idx)));

        Info.ClearTextOnFocus = if typeof(Info.ClearTextOnFocus) == "boolean" then Info.ClearTextOnFocus else true;

        local Textbox = {
            Value = Info.Default or '';
            Numeric = Info.Numeric or false;
            Finished = Info.Finished or false;
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled else false;
        AllowEmpty = if typeof(Info.AllowEmpty) == "boolean" then Info.AllowEmpty else true;
            EmptyReset = if typeof(Info.EmptyReset) == "string" then Info.EmptyReset else "---";
            Type = 'Input';

            Callback = Info.Callback or function(Value) end;
        };

        local Groupbox = self;
        local Container = Groupbox.Container;
        local Blank;

        local InputLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 0, 15);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 5;
            Parent = Container;
        });

        Groupbox:AddBlank(1);

        local TextBoxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Parent = Container;
        });

        local TextBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = TextBoxOuter;
        });

        Library:AddToRegistry(TextBoxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:OnHighlight(TextBoxOuter, TextBoxOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' }
        );

        local TooltipTable;
        if typeof(Info.Tooltip) == "string" or typeof(Info.DisabledTooltip) == "string" then
            TooltipTable = Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, TextBoxOuter)
            TooltipTable.Disabled = Textbox.Disabled;
        end

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = TextBoxInner;
        });

        local Container = Library:Create('Frame', {
            BackgroundTransparency = 1;
            ClipsDescendants = true;

            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -5, 1, 0);

            ZIndex = 7;
            Parent = TextBoxInner;
        })

        local Box = Library:Create('TextBox', {
            BackgroundTransparency = 1;

            Position = UDim2.fromOffset(0, 0),
            Size = UDim2.fromScale(5, 1),

            Font = Library.Font;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = Info.Placeholder or '';

            Text = Info.Default or (if Textbox.AllowEmpty == false then Textbox.EmptyReset else "---");
            TextColor3 = Library.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;

            TextEditable = not Textbox.Disabled;
            ClearTextOnFocus = not Textbox.Disabled and Info.ClearTextOnFocus;

            ZIndex = 7;
            Parent = Container;
        });

        Library:ApplyTextStroke(Box);

        Library:AddToRegistry(Box, {
            TextColor3 = 'FontColor';
        });

        function Textbox:OnChanged(Func)
            Textbox.Changed = Func;

            if Textbox.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Textbox.Value);
        end;

        function Textbox:UpdateColors()
            Box.TextColor3 = Textbox.Disabled and Library.DisabledAccentColor or Library.FontColor;

            Library.RegistryMap[Box].Properties.TextColor3 = Textbox.Disabled and 'DisabledAccentColor' or 'FontColor';
        end;

        function Textbox:Display()
            TextBoxOuter.Visible = Textbox.Visible;
            InputLabel.Visible = Textbox.Visible;
            if Blank then Blank.Visible = Textbox.Visible; end

            Groupbox:Resize();
        end;

        function Textbox:SetValue(Text)
        if not Textbox.AllowEmpty and Trim(Text) == "" then
        Text = Textbox.EmptyReset;
        end

            if Info.MaxLength and #Text > Info.MaxLength then
                Text = Text:sub(1, Info.MaxLength);
            end;

            if Textbox.Numeric then
                if (not tonumber(Text)) and Text:len() > 0 then
                    Text = Textbox.Value
                end
            end

            Textbox.Value = Text;
            Box.Text = Text;

            if not Textbox.Disabled then
                Library:SafeCallback(Textbox.Callback, Textbox.Value);
                Library:SafeCallback(Textbox.Changed, Textbox.Value);
            end;
        end;

        function Textbox:SetVisible(Visibility)
            Textbox.Visible = Visibility;

            Textbox:Display();
        end;

        function Textbox:SetDisabled(Disabled)
            Textbox.Disabled = Disabled;

            Box.TextEditable = not Disabled;
            Box.ClearTextOnFocus = not Disabled and Info.ClearTextOnFocus;

            if TooltipTable then
                TooltipTable.Disabled = Disabled;
            end

            Textbox:UpdateColors();
        end;

        if Textbox.Finished then
            Box.FocusLost:Connect(function(enter)
                if not enter then return end

                Textbox:SetValue(Box.Text);
                Library:AttemptSave();
            end)
        else
            Box:GetPropertyChangedSignal('Text'):Connect(function()
                Textbox:SetValue(Box.Text);
                Library:AttemptSave();
            end);
        end

        local function Update()
            local PADDING = 2
            local reveal = Container.AbsoluteSize.X

            if not Box:IsFocused() or Box.TextBounds.X <= reveal - 2 * PADDING then
                Box.Position = UDim2.new(0, PADDING, 0, 0)
            else
                local cursor = Box.CursorPosition
                if cursor ~= -1 then
                    local subtext = string.sub(Box.Text, 1, cursor-1)
                    local width = TextService:GetTextSize(subtext, Box.TextSize, Box.Font, Vector2.new(math.huge, math.huge)).X

                    local currentCursorPos = Box.Position.X.Offset + width

                    if currentCursorPos < PADDING then
                        Box.Position = UDim2.fromOffset(PADDING-width, 0)
                    elseif currentCursorPos > reveal - PADDING - 1 then
                        Box.Position = UDim2.fromOffset(reveal-width-PADDING-1, 0)
                    end
                end
            end
        end

        task.spawn(Update)

        Box:GetPropertyChangedSignal('Text'):Connect(Update)
        Box:GetPropertyChangedSignal('CursorPosition'):Connect(Update)
        Box.FocusLost:Connect(Update)
        Box.Focused:Connect(Update)

        Blank = Groupbox:AddBlank(5, Textbox.Visible);
        task.delay(0.1, Textbox.UpdateColors, Textbox);
        Textbox:Display();
        Groupbox:Resize();

        Options[Idx] = Textbox;

        return Textbox;
    end;

    function BaseGroupboxFuncs:AddToggle(Idx, Info)
        assert(Info.Text, string.format('AddInput (IDX: %s): Missing `Text` string.', tostring(Idx)));

        local Toggle = {
            Value = Info.Default or false;
            Type = 'Toggle';
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled else false;
            Risky = if typeof(Info.Risky) == "boolean" then Info.Risky else false;
            OriginalText = Info.Text; Text = Info.Text;

            Callback = Info.Callback or function(Value) end;
            Addons = {};
        };

        local Blank;
        local Tooltip;
        local Groupbox = self;
        local Container = Groupbox.Container;

        local ToggleContainer = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Size = UDim2.new(1, -4, 0, 13);
            Visible = Toggle.Visible;
            ZIndex = 5;
            Parent = Container;
        });

        local ToggleOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 13, 0, 13);
            Visible = Toggle.Visible;
            ZIndex = 5;
            Parent = ToggleContainer;
        });

        Library:AddToRegistry(ToggleOuter, {
            BorderColor3 = 'Black';
        });

        local ToggleInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = ToggleOuter;
        });

        Library:AddToRegistry(ToggleInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local ToggleLabel = Library:CreateLabel({
            Size = UDim2.new(1, -19, 0, 11);
            Position = UDim2.new(0, 19, 0, 0);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 6;
            Parent = ToggleContainer;
            RichText = true;
        });

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 4);
            FillDirection = Enum.FillDirection.Horizontal;
            HorizontalAlignment = Enum.HorizontalAlignment.Right;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = ToggleLabel;
        });

        local ToggleRegion = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Size = UDim2.new(0, 170, 1, 0);
            ZIndex = 8;
            Parent = ToggleOuter;
        });

        Library:OnHighlight(ToggleRegion, ToggleOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' },
            function()
                if Toggle.Disabled then
                    return false;
                end;

                for _, Addon in next, Toggle.Addons do
                    if Library:MouseIsOverFrame(Addon.DisplayFrame) then return false end
                end
                return true
            end
        );

        function Toggle:UpdateColors()
            Toggle:Display();
        end;

        if typeof(Info.Tooltip) == "string" or typeof(Info.DisabledTooltip) == "string" then
            Tooltip = Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, ToggleRegion)
            Tooltip.Disabled = Toggle.Disabled;
        end

        function Toggle:Display()
            if Toggle.Disabled then
                ToggleLabel.TextColor3 = Library.DisabledTextColor;

                ToggleInner.BackgroundColor3 = Toggle.Value and Library.DisabledAccentColor or Library.MainColor;
                ToggleInner.BorderColor3 = Library.DisabledOutlineColor;

                Library.RegistryMap[ToggleInner].Properties.BackgroundColor3 = Toggle.Value and 'DisabledAccentColor' or 'MainColor';
                Library.RegistryMap[ToggleInner].Properties.BorderColor3 = 'DisabledOutlineColor';
                Library.RegistryMap[ToggleLabel].Properties.TextColor3 = 'DisabledTextColor';

                return;
            end;

            ToggleLabel.TextColor3 = Toggle.Risky and Library.RiskColor or Color3.new(1, 1, 1);

            ToggleInner.BackgroundColor3 = Toggle.Value and Library.AccentColor or Library.MainColor;
            ToggleInner.BorderColor3 = Toggle.Value and Library.AccentColorDark or Library.OutlineColor;

            Library.RegistryMap[ToggleInner].Properties.BackgroundColor3 = Toggle.Value and 'AccentColor' or 'MainColor';
            Library.RegistryMap[ToggleInner].Properties.BorderColor3 = Toggle.Value and 'AccentColorDark' or 'OutlineColor';

            Library.RegistryMap[ToggleLabel].Properties.TextColor3 = Toggle.Risky and 'RiskColor' or nil;
        end;

        function Toggle:OnChanged(Func)
            Toggle.Changed = Func;

            if Toggle.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Toggle.Value);
        end;

        function Toggle:SetValue(Bool)
            if Toggle.Disabled then
                return;
            end;

            Bool = (not not Bool);

            Toggle.Value = Bool;
            Toggle:Display();

            for _, Addon in next, Toggle.Addons do
                if Addon.Type == 'KeyPicker' and Addon.SyncToggleState then
                    Addon.Toggled = Bool
                    Addon:Update()
                end
            end

            if not Toggle.Disabled then
                Library:SafeCallback(Toggle.Callback, Toggle.Value);
                Library:SafeCallback(Toggle.Changed, Toggle.Value);
            end;

            Library:UpdateDependencyBoxes();
            Library:UpdateDependencyGroupboxes();
        end;

        function Toggle:SetVisible(Visibility)
            Toggle.Visible = Visibility;

            ToggleOuter.Visible = Toggle.Visible;
            if Blank then Blank.Visible = Toggle.Visible end;

            Groupbox:Resize();
        end;

        function Toggle:SetDisabled(Disabled)
            Toggle.Disabled = Disabled;

            if Tooltip then
                Tooltip.Disabled = Disabled;
            end

            Toggle:Display();
        end;

        function Toggle:SetText(Text)
            if typeof(Text) == "string" then
                Toggle.Text = Text;
                ToggleLabel.Text = Toggle.Text;
            end
        end;

        ToggleRegion.InputBegan:Connect(function(Input)
            if Toggle.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                for _, Addon in next, Toggle.Addons do
                    if Library:MouseIsOverFrame(Addon.DisplayFrame) then return end
                end

                Toggle:SetValue(not Toggle.Value)
                Library:AttemptSave();
            end;
        end);

        if Toggle.Risky == true then
            Library:RemoveFromRegistry(ToggleLabel)

            ToggleLabel.TextColor3 = Library.RiskColor
            Library:AddToRegistry(ToggleLabel, { TextColor3 = 'RiskColor' })
        end

        Toggle:Display();
        Blank = Groupbox:AddBlank(Info.BlankSize or 5 + 2, Toggle.Visible);
        Groupbox:Resize();

        Toggle.TextLabel = ToggleLabel;
        Toggle.Container = Container;
        setmetatable(Toggle, BaseAddons);

        Toggles[Idx] = Toggle;

        Library:UpdateDependencyBoxes();
        Library:UpdateDependencyGroupboxes();

        return Toggle;
    end;

    function BaseGroupboxFuncs:AddSlider(Idx, Info)
        assert(Info.Default,    string.format('AddSlider (IDX: %s): Missing default value.', tostring(Idx)));
        assert(Info.Text,       string.format('AddSlider (IDX: %s): Missing slider text.', tostring(Idx)));
        assert(Info.Min,        string.format('AddSlider (IDX: %s): Missing minimum value.', tostring(Idx)));
        assert(Info.Max,        string.format('AddSlider (IDX: %s): Missing maximum value.', tostring(Idx)));
        assert(Info.Rounding,   string.format('AddSlider (IDX: %s): Missing rounding value.', tostring(Idx)));

        local Slider = {
            Value = Info.Default;
            Min = Info.Min;
            Max = Info.Max;
            Rounding = Info.Rounding;
            MaxSize = 232;
            Type = 'Slider';
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled else false;
            OriginalText = Info.Text; Text = Info.Text;

            Prefix = typeof(Info.Prefix) == "string" and Info.Prefix or "";
            Suffix = typeof(Info.Suffix) == "string" and Info.Suffix or "";

            Callback = Info.Callback or function(Value) end;
        };

        local Blanks = {};
        local SliderText = nil;
        local Groupbox = self;
        local Container = Groupbox.Container;
        local Tooltip;

        if not Info.Compact then
            SliderText = Library:CreateLabel({
                Size = UDim2.new(1, 0, 0, 10);
                TextSize = 14;
                Text = Info.Text;
                TextXAlignment = Enum.TextXAlignment.Left;
                TextYAlignment = Enum.TextYAlignment.Bottom;
                Visible = Slider.Visible;
                ZIndex = 5;
                Parent = Container;
                RichText = true;
            });

            table.insert(Blanks, Groupbox:AddBlank(3, Slider.Visible));
        end

        local SliderOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 13);
            Visible = Slider.Visible;
            ZIndex = 5;
            Parent = Container;
        });

        SliderOuter:GetPropertyChangedSignal('AbsoluteSize'):Connect(function()
            Slider.MaxSize = SliderOuter.AbsoluteSize.X - 2;
        end);

        Library:AddToRegistry(SliderOuter, {
            BorderColor3 = 'Black';
        });

        local SliderInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = SliderOuter;
        });

        Library:AddToRegistry(SliderInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local Fill = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderColor3 = Library.AccentColorDark;
            Size = UDim2.new(0, 0, 1, 0);
            ZIndex = 7;
            Parent = SliderInner;
        });

        Library:AddToRegistry(Fill, {
            BackgroundColor3 = 'AccentColor';
            BorderColor3 = 'AccentColorDark';
        });

        local HideBorderRight = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderSizePixel = 0;
            Position = UDim2.new(1, 0, 0, 0);
            Size = UDim2.new(0, 1, 1, 0);
            ZIndex = 8;
            Parent = Fill;
        });

        Library:AddToRegistry(HideBorderRight, {
            BackgroundColor3 = 'AccentColor';
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 1, 0);
            TextSize = 14;
            Text = 'Infinite';
            ZIndex = 9;
            Parent = SliderInner;
            RichText = true;
        });

        Library:OnHighlight(SliderOuter, SliderOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' },
            function()
                return not Slider.Disabled;
            end
        );

        if typeof(Info.Tooltip) == "string" or typeof(Info.DisabledTooltip) == "string" then
            Tooltip = Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, SliderOuter)
            Tooltip.Disabled = Slider.Disabled;
        end

        function Slider:UpdateColors()
            if SliderText then
                SliderText.TextColor3 = Slider.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
            end;
            DisplayLabel.TextColor3 = Slider.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);

            HideBorderRight.BackgroundColor3 = Slider.Disabled and Library.DisabledAccentColor or Library.AccentColor;

            Fill.BackgroundColor3 = Slider.Disabled and Library.DisabledAccentColor or Library.AccentColor;
            Fill.BorderColor3 = Slider.Disabled and Library.DisabledOutlineColor or Library.AccentColorDark;

            Library.RegistryMap[HideBorderRight].Properties.BackgroundColor3 = Slider.Disabled and 'DisabledAccentColor' or 'AccentColor';

            Library.RegistryMap[Fill].Properties.BackgroundColor3 = Slider.Disabled and 'DisabledAccentColor' or 'AccentColor';
            Library.RegistryMap[Fill].Properties.BorderColor3 = Slider.Disabled and 'DisabledOutlineColor' or 'AccentColorDark';
        end;
        
        function Slider:Display()
            local CustomDisplayText = nil;
            if Info.FormatDisplayValue then
                CustomDisplayText = Info.FormatDisplayValue(Slider, Slider.Value);
            end;

            if CustomDisplayText then
                DisplayLabel.Text = tostring(CustomDisplayText);
            else
                local FormattedValue = (Slider.Value == 0 or Slider.Value == -0) and "0" or tostring(Slider.Value);
                if Info.Compact then
                    DisplayLabel.Text = string.format("%s: %s%s%s", Slider.Text, Slider.Prefix, FormattedValue, Slider.Suffix);

                elseif Info.HideMax then
                    DisplayLabel.Text = string.format("%s%s%s", Slider.Prefix, FormattedValue, Slider.Suffix);

                else
                    DisplayLabel.Text = string.format("%s%s%s/%s%s%s", 
                        Slider.Prefix, FormattedValue, Slider.Suffix,
                        Slider.Prefix, tostring(Slider.Max), Slider.Suffix);
                end;
            end;

            local X = Library:MapValue(Slider.Value, Slider.Min, Slider.Max, 0, 1);
            Fill.Size = UDim2.new(X, 0, 1, 0);

            HideBorderRight.Visible = not (X == 1 or X == 0);
        end;

        function Slider:OnChanged(Func)
            Slider.Changed = Func;

            if Slider.Disabled then
                return;
            end;
            
            Library:SafeCallback(Func, Slider.Value);
        end;

        local function Round(Value)
            if Slider.Rounding == 0 then
                return math.floor(Value);
            end;

            return tonumber(string.format('%.' .. Slider.Rounding .. 'f', Value))
        end;

        function Slider:GetValueFromXScale(X)
            return Round(Library:MapValue(X, 0, 1, Slider.Min, Slider.Max));
        end;
        
        function Slider:SetMax(Value)
            assert(Value > Slider.Min, 'Max value cannot be less than the current min value.');
            
            Slider.Value = math.clamp(Slider.Value, Slider.Min, Value);
            Slider.Max = Value;
            Slider:Display();
        end;
        
        function Slider:SetMin(Value)
            assert(Value < Slider.Max, 'Min value cannot be greater than the current max value.');

            Slider.Value = math.clamp(Slider.Value, Value, Slider.Max);
            Slider.Min = Value;
            Slider:Display();
        end;

        function Slider:SetValue(Str)
            if Slider.Disabled then
                return;
            end;

            local Num = tonumber(Str);

            if (not Num) then
                return;
            end;

            Num = math.clamp(Num, Slider.Min, Slider.Max);

            Slider.Value = Num;
            Slider:Display();

            if not Slider.Disabled then
                Library:SafeCallback(Slider.Callback, Slider.Value);
                Library:SafeCallback(Slider.Changed, Slider.Value);
            end;
        end;

        function Slider:SetVisible(Visibility)
            Slider.Visible = Visibility;

            if SliderText then SliderText.Visible = Slider.Visible end;
            SliderOuter.Visible = Slider.Visible;

            for _, Blank in pairs(Blanks) do
                Blank.Visible = Slider.Visible
            end

            Groupbox:Resize();
        end;

        function Slider:SetDisabled(Disabled)
            Slider.Disabled = Disabled;

            if Tooltip then
                Tooltip.Disabled = Disabled;
            end

            Slider:UpdateColors();
        end;

        function Slider:SetText(Text)
            if typeof(Text) == "string" then
                Slider.Text = Text;

                if SliderText then SliderText.Text = Slider.Text end;
                Slider:Display();
            end
        end;

        function Slider:SetPrefix(Prefix)
            if typeof(Prefix) == "string" then
                Slider.Prefix = Prefix;
                Slider:Display();
            end
        end;

        function Slider:SetSuffix(Suffix)
            if typeof(Suffix) == "string" then
                Slider.Suffix = Suffix;
                Slider:Display();
            end
        end;

        SliderInner.InputBegan:Connect(function(Input)
            if Slider.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1 or Enum.UserInputType.Touch) do
                    local MinX = SliderInner.AbsolutePosition.X;
                    local MaxX = MinX + SliderInner.AbsoluteSize.X;
                    local MouseX = math.clamp(Mouse.X, MinX, MaxX);

                    local X = (MouseX - MinX) / (MaxX - MinX);
                    local Value = Slider:GetValueFromXScale(X);

                    Slider.Value = Value;
                    Slider:Display();

                    Library:SafeCallback(Slider.Callback, Slider.Value);
                    Library:SafeCallback(Slider.Changed, Slider.Value);

                    RunService.RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        Slider:Display();
        table.insert(Blanks, Groupbox:AddBlank(5, Slider.Visible));
        task.delay(0.1, Slider.UpdateColors, Slider);
        Groupbox:Resize();

        Options[Idx] = Slider;

        return Slider;
    end;

    function BaseGroupboxFuncs:AddBox(Idx, Info)
        assert(Info.Default, string.format('AddBox (IDX: %s): Missing default value.', tostring(Idx)));

        Info.Values = Info.Values or {};

        local Box = {
            Value = Info.Default;
            Values = Info.Values;
            Type = 'Box';
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled else false;
            OriginalText = Info.Text; Text = Info.Text;

            Callback = Info.Callback or function(Value) end;
        };

        local Groupbox = self;
        local Container = Groupbox.Container;
        local Blank;
        local Tooltip;

        local BoxLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 0, 15);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            Visible = Box.Visible;
            ZIndex = 5;
            Parent = Container;
            RichText = true;
        });

        Groupbox:AddBlank(1);

        local BoxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 20);
            Visible = Box.Visible;
            ZIndex = 5;
            Parent = Container;
        });

        local BoxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = BoxOuter;
        });

        Library:AddToRegistry(BoxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:OnHighlight(BoxOuter, BoxOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' },
            function()
                return not Box.Disabled;
            end
        );

        if typeof(Info.Tooltip) == "string" or typeof(Info.DisabledTooltip) == "string" then
            Tooltip = Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, BoxOuter)
            Tooltip.Disabled = Box.Disabled;
        end

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = BoxInner;
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, -5, 1, 0);
            Position = UDim2.new(0, 5, 0, 0);
            TextSize = 14;
            Text = Box.Value;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 7;
            Parent = BoxInner;
            RichText = true;
        });

        local DropdownOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 60, 0, 18);
            Visible = false;
            ZIndex = 20;
            Parent = ScreenGui;
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownOuter;
        });

        Library:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor,
        });

        Library:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = Scrolling;
        });

        function Box:UpdateColors()
            BoxLabel.TextColor3 = Box.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);
            DisplayLabel.TextColor3 = Box.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);

            Library.RegistryMap[BoxLabel].Properties.TextColor3 = Box.Disabled and 'DisabledAccentColor' or nil;
            Library.RegistryMap[DisplayLabel].Properties.TextColor3 = Box.Disabled and 'DisabledAccentColor' or nil;
        end;

        function Box:Display()
            BoxOuter.Visible = Box.Visible;
            BoxLabel.Visible = Box.Visible;
            if Blank then Blank.Visible = Box.Visible end;

            Groupbox:Resize();
        end;

        function Box:SetValue(Value)
            if Box.Disabled then
                return;
            end;

            Box.Value = Value;
            DisplayLabel.Text = Value;

            if not Box.Disabled then
                Library:SafeCallback(Box.Callback, Box.Value);
                Library:SafeCallback(Box.Changed, Box.Value);
            end;
        end;

        function Box:OnChanged(Func)
            Box.Changed = Func;

            if Box.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Box.Value);
        end;

        function Box:SetVisible(Visibility)
            Box.Visible = Visibility;

            Box:Display();
        end;

        function Box:SetDisabled(Disabled)
            Box.Disabled = Disabled;

            if Tooltip then
                Tooltip.Disabled = Disabled;
            end

            Box:UpdateColors();
        end;

        function Box:SetText(Text)
            if typeof(Text) == "string" then
                Box.Text = Text;
                BoxLabel.Text = Box.Text;
            end
        end;

        function Box:BuildDropdownList()
            local Values = Box.Values;
            local Buttons = {};

            for _, Element in next, Scrolling:GetChildren() do
                if not Element:IsA('UIListLayout') then
                    Element:Destroy();
                end;
            end;

            local Count = 0;

            for Idx, Value in next, Values do
                local Table = {};

                Count = Count + 1;

                local Button = Library:Create('TextButton', {
                    AutoButtonColor = false,
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Size = UDim2.new(1, -1, 0, 20);
                    Text = '';
                    ZIndex = 23;
                    Parent = Scrolling;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'OutlineColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Active = false;
                    Size = UDim2.new(1, -6, 1, 0);
                    Position = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Text = Value;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    ZIndex = 25;
                    Parent = Button;
                });

                Library:OnHighlight(Button, Button,
                    { BorderColor3 = 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                Button.MouseButton1Click:Connect(function(Input)
                    Box:SetValue(Value);
                    Box:CloseDropdown();
                    Library:AttemptSave();
                end);

                Buttons[Button] = Table;
            end;

            Scrolling.CanvasSize = UDim2.fromOffset(0, (Count * (20 * DPIScale)) + 1);
        end;

        function Box:SetValues(NewValues)
            if NewValues then
                Box.Values = NewValues;
            end;

            Box:BuildDropdownList();
        end;

        function Box:OpenDropdown()
            if Box.Disabled then
                return;
            end;

            if Library.IsMobile then
                Library.CanDrag = false;
            end;

            local X = BoxOuter.AbsoluteSize.X + 0.5;
            DropdownOuter.Size = UDim2.new(0, X, 0, math.clamp(GetTableSize(Box.Values) * (20 * DPIScale), 0, 8 * (20 * DPIScale)) + 1);
            DropdownOuter.Position = UDim2.fromOffset(BoxOuter.AbsolutePosition.X, BoxOuter.AbsolutePosition.Y + BoxOuter.Size.Y.Offset + 1);

            DropdownOuter.Visible = true;
            Library.OpenedFrames[DropdownOuter] = true;
        end;

        function Box:CloseDropdown()
            if Library.IsMobile then
                Library.CanDrag = true;
            end;

            DropdownOuter.Visible = false;
            Library.OpenedFrames[DropdownOuter] = nil;
        end;

        BoxOuter.InputBegan:Connect(function(Input)
            if Box.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                if DropdownOuter.Visible then
                    Box:CloseDropdown();
                else
                    Box:OpenDropdown();
                end;
            end;
        end);

        InputService.InputBegan:Connect(function(Input)
            if Box.Disabled then
                return;
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = DropdownOuter.AbsolutePosition, DropdownOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - (20 * DPIScale) - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    Box:CloseDropdown();
                end;
            end;
        end);

        Box:SetValue(Box.Value);
        Box:BuildDropdownList();
        Blank = Groupbox:AddBlank(5, Box.Visible);
        task.delay(0.1, Box.UpdateColors, Box);
        Box:Display();
        Groupbox:Resize();

        Options[Idx] = Box;

        return Box;
    end;

    function BaseGroupboxFuncs:AddDependencyBox(Idx, Info)
        local Groupbox = self;
        local Container = Groupbox.Container;

        local Depbox = {
            Type = 'DependencyBox';
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled or false;
            Idx = Idx;

            Elements = {};
            Addons = {};
            AnyEnabled = Info.AnyEnabled or false;
            Parent = Groupbox;
        };

        local Blank;
        local DepboxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 20);
            Visible = Depbox.Visible;
            ZIndex = 5;
            Parent = Container;
        });

        local DepboxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = DepboxOuter;
        });

        Library:AddToRegistry(DepboxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = DepboxInner;
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, -5, 1, 0);
            Position = UDim2.new(0, 5, 0, 0);
            TextSize = 14;
            Text = '';
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 7;
            Parent = DepboxInner;
            RichText = true;
        });

        local DropdownOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 60, 0, 18);
            Visible = false;
            ZIndex = 20;
            Parent = ScreenGui;
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownOuter;
        });

        Library:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor,
        });

        Library:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = Scrolling;
        });

        function Depbox:UpdateColors()
            DisplayLabel.TextColor3 = Depbox.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);

            Library.RegistryMap[DisplayLabel].Properties.TextColor3 = Depbox.Disabled and 'DisabledAccentColor' or nil;
        end;

        function Depbox:Display()
            DepboxOuter.Visible = Depbox.Visible;
            if Blank then Blank.Visible = Depbox.Visible end;

            Groupbox:Resize();
        end;

        function Depbox:SetValue(Value)
            if Depbox.Disabled then
                return;
            end;

            Depbox.Value = Value;
            DisplayLabel.Text = Value;

            if not Depbox.Disabled then
                Library:SafeCallback(Depbox.Callback, Depbox.Value);
                Library:SafeCallback(Depbox.Changed, Depbox.Value);
            end;
        end;

        function Depbox:OnChanged(Func)
            Depbox.Changed = Func;

            if Depbox.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Depbox.Value);
        end;

        function Depbox:SetVisible(Visibility)
            Depbox.Visible = Visibility;

            Depbox:Display();
        end;

        function Depbox:SetDisabled(Disabled)
            Depbox.Disabled = Disabled;

            Depbox:UpdateColors();
        end;

        function Depbox:SetText(Text)
            if typeof(Text) == "string" then
                Depbox.Text = Text;
                DisplayLabel.Text = Depbox.Text;
            end
        end;

        function Depbox:Update()
            local AnyEnabled = Depbox.AnyEnabled;
            local Enabled = AnyEnabled and false or true;

            for _, Element in next, Depbox.Elements do
                if AnyEnabled then
                    if Element.Value == true then
                        Enabled = true;
                        break;
                    end;
                else
                    if Element.Value ~= true then
                        Enabled = false;
                        break;
                    end;
                end;
            end;

            if Depbox.Visible == Enabled then
                return;
            end;

            Depbox:SetVisible(Enabled);
        end;

        function Depbox:AddElement(Element)
            if Element then
                table.insert(Depbox.Elements, Element);
            end;
        end;

        function Depbox:BuildDropdownList()
            local Values = Depbox.Values;
            local Buttons = {};

            for _, Element in next, Scrolling:GetChildren() do
                if not Element:IsA('UIListLayout') then
                    Element:Destroy();
                end;
            end;

            local Count = 0;

            for Idx, Value in next, Values do
                local Table = {};

                Count = Count + 1;

                local Button = Library:Create('TextButton', {
                    AutoButtonColor = false,
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Size = UDim2.new(1, -1, 0, 20);
                    Text = '';
                    ZIndex = 23;
                    Parent = Scrolling;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'OutlineColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Active = false;
                    Size = UDim2.new(1, -6, 1, 0);
                    Position = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Text = Value;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    ZIndex = 25;
                    Parent = Button;
                });

                Library:OnHighlight(Button, Button,
                    { BorderColor3 = 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                Button.MouseButton1Click:Connect(function(Input)
                    Depbox:SetValue(Value);
                    Depbox:CloseDropdown();
                    Library:AttemptSave();
                end);

                Buttons[Button] = Table;
            end;

            Scrolling.CanvasSize = UDim2.fromOffset(0, (Count * (20 * DPIScale)) + 1);
        end;

        function Depbox:SetValues(NewValues)
            if NewValues then
                Depbox.Values = NewValues;
            end;

            Depbox:BuildDropdownList();
        end;

        function Depbox:OpenDropdown()
            if Depbox.Disabled then
                return;
            end;

            if Library.IsMobile then
                Library.CanDrag = false;
            end;

            local X = DepboxOuter.AbsoluteSize.X + 0.5;
            DropdownOuter.Size = UDim2.new(0, X, 0, math.clamp(GetTableSize(Depbox.Values) * (20 * DPIScale), 0, 8 * (20 * DPIScale)) + 1);
            DropdownOuter.Position = UDim2.fromOffset(DepboxOuter.AbsolutePosition.X, DepboxOuter.AbsolutePosition.Y + DepboxOuter.Size.Y.Offset + 1);

            DropdownOuter.Visible = true;
            Library.OpenedFrames[DropdownOuter] = true;
        end;

        function Depbox:CloseDropdown()
            if Library.IsMobile then
                Library.CanDrag = true;
            end;

            DropdownOuter.Visible = false;
            Library.OpenedFrames[DropdownOuter] = nil;
        end;

        DepboxOuter.InputBegan:Connect(function(Input)
            if Depbox.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                if DropdownOuter.Visible then
                    Depbox:CloseDropdown();
                else
                    Depbox:OpenDropdown();
                end;
            end;
        end);

        InputService.InputBegan:Connect(function(Input)
            if Depbox.Disabled then
                return;
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = DropdownOuter.AbsolutePosition, DropdownOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - (20 * DPIScale) - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    Depbox:CloseDropdown();
                end;
            end;
        end);

        Depbox:SetValue(Depbox.Value);
        Depbox:BuildDropdownList();
        Blank = Groupbox:AddBlank(5, Depbox.Visible);
        task.delay(0.1, Depbox.UpdateColors, Depbox);
        Depbox:Display();
        Groupbox:Resize();

        table.insert(Library.DependencyBoxes, Depbox);
        Options[Idx] = Depbox;

        return Depbox;
    end;

    function BaseGroupboxFuncs:AddDependencyGroupbox(Idx, Info)
        local Groupbox = self;
        local Container = Groupbox.Container;

        local Depbox = {
            Type = 'DependencyGroupbox';
            Visible = if typeof(Info.Visible) == "boolean" then Info.Visible else true;
            Disabled = if typeof(Info.Disabled) == "boolean" then Info.Disabled or false;
            Idx = Idx;

            Elements = {};
            Addons = {};
            AnyEnabled = Info.AnyEnabled or false;
            Parent = Groupbox;
        };

        local Blank;
        local DepboxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, -4, 0, 20);
            Visible = Depbox.Visible;
            ZIndex = 5;
            Parent = Container;
        });

        local DepboxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = DepboxOuter;
        });

        Library:AddToRegistry(DepboxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = DepboxInner;
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, -5, 1, 0);
            Position = UDim2.new(0, 5, 0, 0);
            TextSize = 14;
            Text = '';
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 7;
            Parent = DepboxInner;
            RichText = true;
        });

        local DropdownOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(0, 60, 0, 18);
            Visible = false;
            ZIndex = 20;
            Parent = ScreenGui;
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownOuter;
        });

        Library:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = DropdownInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor,
        });

        Library:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = Scrolling;
        });

        function Depbox:UpdateColors()
            DisplayLabel.TextColor3 = Depbox.Disabled and Library.DisabledAccentColor or Color3.new(1, 1, 1);

            Library.RegistryMap[DisplayLabel].Properties.TextColor3 = Depbox.Disabled and 'DisabledAccentColor' or nil;
        end;

        function Depbox:Display()
            DepboxOuter.Visible = Depbox.Visible;
            if Blank then Blank.Visible = Depbox.Visible end;

            Groupbox:Resize();
        end;

        function Depbox:SetValue(Value)
            if Depbox.Disabled then
                return;
            end;

            Depbox.Value = Value;
            DisplayLabel.Text = Value;

            if not Depbox.Disabled then
                Library:SafeCallback(Depbox.Callback, Depbox.Value);
                Library:SafeCallback(Depbox.Changed, Depbox.Value);
            end;
        end;

        function Depbox:OnChanged(Func)
            Depbox.Changed = Func;

            if Depbox.Disabled then
                return;
            end;

            Library:SafeCallback(Func, Depbox.Value);
        end;

        function Depbox:SetVisible(Visibility)
            Depbox.Visible = Visibility;

            Depbox:Display();
        end;

        function Depbox:SetDisabled(Disabled)
            Depbox.Disabled = Disabled;

            Depbox:UpdateColors();
        end;

        function Depbox:SetText(Text)
            if typeof(Text) == "string" then
                Depbox.Text = Text;
                DisplayLabel.Text = Depbox.Text;
            end
        end;

        function Depbox:Update()
            local AnyEnabled = Depbox.AnyEnabled;
            local Enabled = AnyEnabled and false or true;

            for _, Element in next, Depbox.Elements do
                if AnyEnabled then
                    if Element.Value == true then
                        Enabled = true;
                        break;
                    end;
                else
                    if Element.Value ~= true then
                        Enabled = false;
                        break;
                    end;
                end;
            end;

            if Depbox.Visible == Enabled then
                return;
            end;

            Depbox:SetVisible(Enabled);
        end;

        function Depbox:AddElement(Element)
            if Element then
                table.insert(Depbox.Elements, Element);
            end;
        end;

        function Depbox:BuildDropdownList()
            local Values = Depbox.Values;
            local Buttons = {};

            for _, Element in next, Scrolling:GetChildren() do
                if not Element:IsA('UIListLayout') then
                    Element:Destroy();
                end;
            end;

            local Count = 0;

            for Idx, Value in next, Values do
                local Table = {};

                Count = Count + 1;

                local Button = Library:Create('TextButton', {
                    AutoButtonColor = false,
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Size = UDim2.new(1, -1, 0, 20);
                    Text = '';
                    ZIndex = 23;
                    Parent = Scrolling;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'OutlineColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Active = false;
                    Size = UDim2.new(1, -6, 1, 0);
                    Position = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Text = Value;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    ZIndex = 25;
                    Parent = Button;
                });

                Library:OnHighlight(Button, Button,
                    { BorderColor3 = 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                Button.MouseButton1Click:Connect(function(Input)
                    Depbox:SetValue(Value);
                    Depbox:CloseDropdown();
                    Library:AttemptSave();
                end);

                Buttons[Button] = Table;
            end;

            Scrolling.CanvasSize = UDim2.fromOffset(0, (Count * (20 * DPIScale)) + 1);
        end;

        function Depbox:SetValues(NewValues)
            if NewValues then
                Depbox.Values = NewValues;
            end;

            Depbox:BuildDropdownList();
        end;

        function Depbox:OpenDropdown()
            if Depbox.Disabled then
                return;
            end;

            if Library.IsMobile then
                Library.CanDrag = false;
            end;

            local X = DepboxOuter.AbsoluteSize.X + 0.5;
            DropdownOuter.Size = UDim2.new(0, X, 0, math.clamp(GetTableSize(Depbox.Values) * (20 * DPIScale), 0, 8 * (20 * DPIScale)) + 1);
            DropdownOuter.Position = UDim2.fromOffset(DepboxOuter.AbsolutePosition.X, DepboxOuter.AbsolutePosition.Y + DepboxOuter.Size.Y.Offset + 1);

            DropdownOuter.Visible = true;
            Library.OpenedFrames[DropdownOuter] = true;
        end;

        function Depbox:CloseDropdown()
            if Library.IsMobile then
                Library.CanDrag = true;
            end;

            DropdownOuter.Visible = false;
            Library.OpenedFrames[DropdownOuter] = nil;
        end;

        DepboxOuter.InputBegan:Connect(function(Input)
            if Depbox.Disabled then
                return;
            end;

            if (Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame()) or Input.UserInputType == Enum.UserInputType.Touch then
                if DropdownOuter.Visible then
                    Depbox:CloseDropdown();
                else
                    Depbox:OpenDropdown();
                end;
            end;
        end);

        InputService.InputBegan:Connect(function(Input)
            if Depbox.Disabled then
                return;
            end;

            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = DropdownOuter.AbsolutePosition, DropdownOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - (20 * DPIScale) - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    Depbox:CloseDropdown();
                end;
            end;
        end);

        Depbox:SetValue(Depbox.Value);
        Depbox:BuildDropdownList();
        Blank = Groupbox:AddBlank(5, Depbox.Visible);
        task.delay(0.1, Depbox.UpdateColors, Depbox);
        Depbox:Display();
        Groupbox:Resize();

        table.insert(Library.DependencyGroupboxes, Depbox);
        Options[Idx] = Depbox;

        return Depbox;
    end;

    function BaseGroupboxFuncs:Resize()
        local YSize = 0;

        for _, Element in next, self.Container:GetChildren() do
            if not Element:IsA('UIListLayout') and Element.Visible then
                YSize = YSize + Element.Size.Y.Offset + 2;
            end;
        end;

        self.Frame.Size = UDim2.new(1, -10, 0, YSize + 5);
    end;

    BaseGroupbox.__index = BaseGroupboxFuncs;
    BaseGroupbox.__namecall = function(Table, Key, ...)
        return BaseGroupboxFuncs[Key](...);
    end;
end;

local BaseTab = {};

do
    local BaseTabFuncs = {};

    function BaseTabFuncs:AddLeftGroupbox(Name)
        local Tab = self;
        local Column = Tab.ContainerLeft;

        local Groupbox = {
            Parent = Tab;
        };

        local GroupboxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, 0, 0, 0);
            ZIndex = 2;
            Parent = Column;
        });

        Library:AddToRegistry(GroupboxOuter, {
            BorderColor3 = 'Black';
        });

        local GroupboxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 2;
            Parent = GroupboxOuter;
        });

        Library:AddToRegistry(GroupboxInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local GroupboxLabel = Library:CreateLabel({
            Size = UDim2.new(1, -12, 0, 28);
            Position = UDim2.new(0, 12, 0, 0);
            TextSize = 18;
            Text = Name;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 2;
            Parent = GroupboxInner;
        });

        local GroupboxContent = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Position = UDim2.new(0, 5, 0, 33);
            Size = UDim2.new(1, -10, 1, -33);
            ZIndex = 1;
            Parent = GroupboxInner;
        });

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = GroupboxContent;
        });

        Groupbox.Frame = GroupboxInner;
        Groupbox.Container = GroupboxContent;

        setmetatable(Groupbox, BaseGroupbox);

        function Groupbox:SetVisible(Visibility)
            GroupboxOuter.Visible = Visibility;

            Tab:Resize();
        end;

        Tab:Resize();

        return Groupbox;
    end;

    function BaseTabFuncs:AddRightGroupbox(Name)
        local Tab = self;
        local Column = Tab.ContainerRight;

        local Groupbox = {
            Parent = Tab;
        };

        local GroupboxOuter = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(0, 0, 0);
            BorderColor3 = Color3.new(0, 0, 0);
            Size = UDim2.new(1, 0, 0, 0);
            ZIndex = 2;
            Parent = Column;
        });

        Library:AddToRegistry(GroupboxOuter, {
            BorderColor3 = 'Black';
        });

        local GroupboxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 2;
            Parent = GroupboxOuter;
        });

        Library:AddToRegistry(GroupboxInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local GroupboxLabel = Library:CreateLabel({
            Size = UDim2.new(1, -12, 0, 28);
            Position = UDim2.new(0, 12, 0, 0);
            TextSize = 18;
            Text = Name;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 2;
            Parent = GroupboxInner;
        });

        local GroupboxContent = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Position = UDim2.new(0, 5, 0, 33);
            Size = UDim2.new(1, -10, 1, -33);
            ZIndex = 1;
            Parent = GroupboxInner;
        });

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = GroupboxContent;
        });

        Groupbox.Frame = GroupboxInner;
        Groupbox.Container = GroupboxContent;

        setmetatable(Groupbox, BaseGroupbox);

        function Groupbox:SetVisible(Visibility)
            GroupboxOuter.Visible = Visibility;

            Tab:Resize();
        end;

        Tab:Resize();

        return Groupbox;
    end;

    function BaseTabFuncs:AddGroupbox(Name)
        return self:AddLeftGroupbox(Name);
    end;

    function BaseTabFuncs:Resize()
        local LeftSize = 0;
        local RightSize = 0;

        for _, Element in next, self.ContainerLeft:GetChildren() do
            if Element:IsA('Frame') and Element.Visible then
                LeftSize = LeftSize + Element.AbsoluteSize.Y + 8;
            end;
        end;

        for _, Element in next, self.ContainerRight:GetChildren() do
            if Element:IsA('Frame') and Element.Visible then
                RightSize = RightSize + Element.AbsoluteSize.Y + 8;
            end;
        end;

        self.ContainerLeft.CanvasSize = UDim2.new(0, 0, 0, LeftSize);
        self.ContainerRight.CanvasSize = UDim2.new(0, 0, 0, RightSize);

        self.ContainerLeft.Visible = LeftSize > 0;
        self.ContainerRight.Visible = RightSize > 0;
    end;

    BaseTab.__index = BaseTabFuncs;
    BaseTab.__namecall = function(Table, Key, ...)
        return BaseTabFuncs[Key](...);
    end;
end;

local function CreateKeybindFrame()
    local KeybindFrame = Library:Create('Frame', {
        BackgroundColor3 = Color3.new(0, 0, 0);
        BorderColor3 = Color3.new(0, 0, 0);
        Position = UDim2.new(0, 10, 0, 36);
        Size = UDim2.new(0, 220, 0, 28);
        Visible = false;
        ZIndex = 11;
        Parent = ScreenGui;
    });

    Library:AddToRegistry(KeybindFrame, {
        BorderColor3 = 'Black';
    });

    local KeybindInner = Library:Create('Frame', {
        BackgroundColor3 = Library.BackgroundColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 12;
        Parent = KeybindFrame;
    });

    Library:AddToRegistry(KeybindInner, {
        BackgroundColor3 = 'BackgroundColor';
        BorderColor3 = 'OutlineColor';
    });

    local KeybindLabel = Library:CreateLabel({
        Size = UDim2.new(0, 120, 0, 18);
        Position = UDim2.new(0, 8, 0, 5);
        TextSize = 18;
        Text = 'Keybinds';
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 12;
        Parent = KeybindInner;
    });

    local KeybindContainer = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Position = UDim2.new(0, 5, 0, 28);
        Size = UDim2.new(1, -10, 1, -33);
        ZIndex = 12;
        Parent = KeybindInner;
    });

    Library:Create('UIListLayout', {
        Padding = UDim.new(0, 5);
        FillDirection = Enum.FillDirection.Vertical;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Parent = KeybindContainer;
    });

    Library.KeybindFrame = KeybindFrame;
    Library.KeybindContainer = KeybindContainer;

    Library:MakeDraggable(KeybindFrame);
end;

local function CreateWatermark()
    local WatermarkOuter = Library:Create('Frame', {
        BackgroundColor3 = Color3.new(0, 0, 0);
        BorderColor3 = Color3.new(0, 0, 0);
        Position = UDim2.new(0, 10, 0, 10);
        Size = UDim2.new(0, 200, 0, 20);
        Visible = false;
        ZIndex = 11;
        Parent = ScreenGui;
    });

    Library:AddToRegistry(WatermarkOuter, {
        BorderColor3 = 'Black';
    });

    local WatermarkInner = Library:Create('Frame', {
        BackgroundColor3 = Library.BackgroundColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 12;
        Parent = WatermarkOuter;
    });

    Library:AddToRegistry(WatermarkInner, {
        BackgroundColor3 = 'BackgroundColor';
        BorderColor3 = 'OutlineColor';
    });

    local WatermarkLabel = Library:CreateLabel({
        Size = UDim2.new(1, 0, 1, 0);
        TextSize = 14;
        Text = 'Watermark';
        ZIndex = 13;
        Parent = WatermarkInner;
    });

    Library:MakeDraggable(WatermarkOuter);
    Library.Watermark = WatermarkLabel;
end;

function Library:CreateWindow(Info)
    Info = Info or {};

    assert(Info.Title, 'CreateWindow: Missing `Title` string.');

    Library.VideoLink = Info.VideoLink or '';
    Library.ShowCustomCursor = Info.ShowCustomCursor or true;
    Library.ShowToggleFrameInKeybinds = Info.ShowToggleFrameInKeybinds or true;
    Library.NotifyOnError = Info.NotifyOnError or false;

    Library:SetDPIScale(Info.DPIScale or 100);

    local Window = {
        Tabs = {};
    };

    local WindowOuter = Library:Create('Frame', {
        BackgroundColor3 = Color3.new(0, 0, 0);
        BorderColor3 = Color3.new(0, 0, 0);
        Position = UDim2.new(0.5, -330, 0.5, -225);
        Size = UDim2.new(0, 660, 0, 450);
        Visible = false;
        ZIndex = 2;
        Parent = ScreenGui;
    });

    Library:AddToRegistry(WindowOuter, {
        BorderColor3 = 'Black';
    });

    Library:MakeDraggable(WindowOuter, 40, true);
    Library:MakeResizable(WindowOuter);

    local WindowInner = Library:Create('Frame', {
        BackgroundColor3 = Library.BackgroundColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 2;
        Parent = WindowOuter;
    });

    Library:AddToRegistry(WindowInner, {
        BackgroundColor3 = 'BackgroundColor';
        BorderColor3 = 'OutlineColor';
    });

    local WindowHeader = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 0, 40);
        ZIndex = 3;
        Parent = WindowInner;
    });

    Library:AddToRegistry(WindowHeader, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'OutlineColor';
    });

    local WindowLabel = Library:CreateLabel({
        Size = UDim2.new(0, 350, 1, 0);
        TextSize = 18;
        Text = Info.Title;
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 3;
        Parent = WindowHeader;
    });

    local TabContainer = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Position = UDim2.new(0, 8, 0, 48);
        Size = UDim2.new(1, -16, 1, -56);
        ZIndex = 3;
        Parent = WindowInner;
    });

    local TabContainerLeft = Library:Create('ScrollingFrame', {
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        CanvasSize = UDim2.new(0, 0, 0, 0);
        Position = UDim2.new(0, 0, 0, 0);
        Size = UDim2.new(0.5, -4, 1, 0);
        ScrollBarImageColor3 = Color3.new(0, 0, 0);
        ScrollBarThickness = 0;
        Visible = false;
        ZIndex = 3;
        Parent = TabContainer;
    });

    local TabContainerRight = Library:Create('ScrollingFrame', {
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        CanvasSize = UDim2.new(0, 0, 0, 0);
        Position = UDim2.new(0.5, 4, 0, 0);
        Size = UDim2.new(0.5, -4, 1, 0);
        ScrollBarImageColor3 = Color3.new(0, 0, 0);
        ScrollBarThickness = 0;
        Visible = false;
        ZIndex = 3;
        Parent = TabContainer;
    });

    local TabButtonLayout = Library:Create('UIListLayout', {
        Padding = UDim.new(0, 0);
        FillDirection = Enum.FillDirection.Horizontal;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Parent = WindowHeader;
    });

    local function UpdateTabButtonPosition()
        local X = TabButtonLayout.AbsoluteContentSize.X + 30;

        if X > WindowHeader.AbsoluteSize.X then
            TabButtonLayout.Padding = UDim.new(0, 0);
            TabButtonLayout.FillDirection = Enum.FillDirection.Vertical;
            TabButtonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left;
        else
            TabButtonLayout.Padding = UDim.new(0, 8);
            TabButtonLayout.FillDirection = Enum.FillDirection.Horizontal;
            TabButtonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right;
        end;
    end;

    TabButtonLayout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(UpdateTabButtonPosition);
    UpdateTabButtonPosition();

    function Window:SetWindowTitle(Title)
        WindowLabel.Text = Title;
    end;

    function Window:AddTab(Name)
        local Tab = {
            Parent = Window;
        };

        local TabButton = Library:Create('TextButton', {
            AutoButtonColor = false;
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Position = UDim2.new(0, 30, 0, 8);
            Size = UDim2.new(0, 75, 0, 24);
            Text = '';
            ZIndex = 4;
            Parent = WindowHeader;
        });

        Library:AddToRegistry(TabButton, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local TabButtonLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 1, 0);
            TextSize = 16;
            Text = Name;
            ZIndex = 5;
            Parent = TabButton;
        });

        local TabFrame = Library:Create('Frame', {
            BackgroundTransparency = 1;
            Size = UDim2.new(1, 0, 1, 0);
            Visible = false;
            ZIndex = 3;
            Parent = TabContainer;
        });

        local TabContainerLeft = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Position = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(0.5, -4, 1, 0);
            ScrollBarImageColor3 = Color3.new(0, 0, 0);
            ScrollBarThickness = 0;
            Visible = false;
            ZIndex = 3;
            Parent = TabFrame;
        });

        local TabContainerRight = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            BorderSizePixel = 0;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Position = UDim2.new(0.5, 4, 0, 0);
            Size = UDim2.new(0.5, -4, 1, 0);
            ScrollBarImageColor3 = Color3.new(0, 0, 0);
            ScrollBarThickness = 0;
            Visible = false;
            ZIndex = 3;
            Parent = TabFrame;
        });

        Tab.Container = TabFrame;
        Tab.ContainerLeft = TabContainerLeft;
        Tab.ContainerRight = TabContainerRight;

        Tab.Button = TabButton;
        Tab.ButtonText = TabButtonLabel;

        setmetatable(Tab, BaseTab);

        function Tab:Show()
            for _, OtherTab in next, Window.Tabs do
                OtherTab.Button.BackgroundColor3 = Library.MainColor;
                OtherTab.Button.BorderColor3 = Library.OutlineColor;
                OtherTab.Container.Visible = false;

                Library.RegistryMap[OtherTab.Button].Properties.BackgroundColor3 = 'MainColor';
                Library.RegistryMap[OtherTab.Button].Properties.BorderColor3 = 'OutlineColor';
            end;

            TabButton.BackgroundColor3 = Library.AccentColor;
            TabButton.BorderColor3 = Library.AccentColorDark;
            TabFrame.Visible = true;

            Library.RegistryMap[TabButton].Properties.BackgroundColor3 = 'AccentColor';
            Library.RegistryMap[TabButton].Properties.BorderColor3 = 'AccentColorDark';

            Library.ActiveTab = Tab;
        end;

        TabButton.MouseButton1Down:Connect(function()
            Tab:Show();
        end);

        if #Window.Tabs == 0 then
            Tab:Show();
        end;

        table.insert(Window.Tabs, Tab);
        Window.Tabs[Name] = Tab;

        Library.TotalTabs = Library.TotalTabs + 1;

        return Tab;
    end;

    function Window:SelectTab(Idx)
        if type(Idx) == 'number' then
            if Window.Tabs[Idx] then
                Window.Tabs[Idx]:Show();
            end
        elseif type(Idx) == 'string' then
            if Window.Tabs[Idx] then
                Window.Tabs[Idx]:Show();
            end
        end
    end

    function Window:Show()
        WindowOuter.Visible = true;
    end;

    function Window:Hide()
        WindowOuter.Visible = false;
    end;

    function Window:IsVisible()
        return WindowOuter.Visible;
    end;

    function Window:Toggle()
        WindowOuter.Visible = not WindowOuter.Visible;
    end;

    function Window:Close()
        WindowOuter.Visible = false;
    end;

    function Window:SetKeybind(Keybind)
        if Keybind == 'None' then
            Library.ToggleKeybind = nil;
        else
            Library.ToggleKeybind = Keybind;
        end;
    end;

    function Window:Unload()
        Library:Unload();
    end;

    CreateKeybindFrame();
    CreateWatermark();

    Library.Window.Holder = WindowOuter;
    Library.Window.Tabs = Window.Tabs;

    local TweenService = game:GetService("TweenService")
    local CoreGuiService = game:GetService("CoreGui")
    local RunService = game:GetService("RunService")

    for _,v in next, CoreGuiService:GetChildren() do
        if v.Name == "starlight_intro" then v:Destroy() end
    end

    local function quickTween(t) return TweenInfo.new(t or 0.175, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) end

    local function ShowStarLightIntroduction()
        local sg = Instance.new("ScreenGui")
        sg.Name = "starlight_intro"
        sg.Parent = CoreGuiService
        sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

        local edge = Instance.new("Frame")
        edge.AnchorPoint = Vector2.new(0.5, 0.5)
        edge.Position = UDim2.new(0.5, 0, 0.4, 0)
        edge.Size = UDim2.new(0, 300, 0, 308)
        edge.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        edge.BackgroundTransparency = 1
        edge.Parent = sg
        Instance.new("UICorner", edge).CornerRadius = UDim.new(0, 2)

        local bg = Instance.new("Frame")
        bg.AnchorPoint = Vector2.new(0.5, 0.5)
        bg.Position = UDim2.new(0.5, 0, 0.5, 0)
        bg.Size = UDim2.new(0, 298, 0, 306)
        bg.BackgroundTransparency = 1
        bg.ClipsDescendants = true
        bg.Parent = edge
        Instance.new("UICorner", bg).CornerRadius = UDim.new(0, 2)
        local g = Instance.new("UIGradient", bg)
        g.Rotation = 90
        g.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(34, 34, 34)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(28, 28, 28))
        }

        local bar = Instance.new("Frame")
        bar.Size = UDim2.new(0, 0, 0, 1)
        bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255)
        bar.BackgroundTransparency = 0.2
        bar.Parent = bg
        Instance.new("UICorner", bar).CornerRadius = UDim.new(0, 2)

        local logo = Instance.new("ImageLabel")
        logo.AnchorPoint = Vector2.new(0.5, 0.5)
        logo.Position = UDim2.new(0.5, 0, 0.5, 0)
        logo.Size = UDim2.new(0, 448, 0, 150)
        logo.Image = "http://www.roblox.com/asset/?id=9365068051"
        logo.ImageColor3 = Color3.fromRGB(159, 115, 255)
        logo.ImageTransparency = 1
        logo.BackgroundTransparency = 1
        logo.Parent = bg

        local txt = Instance.new("TextLabel")
        txt.Size = UDim2.new(0, 120, 0, 21)
        txt.Font = Enum.Font.Code
        txt.Text = "powered by StarLight"
        txt.TextColor3 = Color3.fromRGB(124, 124, 124)
        txt.TextSize = 10
        txt.TextTransparency = 1
        txt.BackgroundTransparency = 1
        txt.Parent = bg

        local sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://4590657391"
        sound.Parent = game:GetService("SoundService")
        sound:Play()
        game:Debris:AddItem(sound, 5)

        local rot = -16
        local conn = RunService.RenderStepped:Connect(function()
            rot = rot + 0.4
            logo.Rotation = logo.Rotation - rot
        end)

        local function seq()
            TweenService:Create(edge, quickTween(), {BackgroundTransparency = 0}):Play()
            TweenService:Create(bg, quickTween(), {BackgroundTransparency = 0}):Play()
            wait(0.2)
            TweenService:Create(bar, quickTween(), {Size = UDim2.new(0, 298, 0, 1)}):Play()
            wait(0.2)
            TweenService:Create(txt, quickTween(), {TextTransparency = 0}):Play()
            wait(0.3)
            TweenService:Create(logo, quickTween(), {ImageTransparency = 0}):Play()
            wait(2)
            TweenService:Create(logo, quickTween(), {ImageTransparency = 1}):Play()
            wait(0.2)
            TweenService:Create(txt, quickTween(), {TextTransparency = 1}):Play()
            wait(0.1)
            TweenService:Create(bar, quickTween(), {Size = UDim2.new(0, 0, 0, 1)}):Play()
            wait(0.1)
            TweenService:Create(bg, quickTween(), {BackgroundTransparency = 1}):Play()
            TweenService:Create(edge, quickTween(), {BackgroundTransparency = 1}):Play()
            wait(0.2)
            conn:Disconnect()
            sg:Destroy()
            Window:Show()
        end
        coroutine.wrap(seq)()
    end

    ShowStarLightIntroduction()

    InputService.InputBegan:Connect(function(Input)
        if Library.ToggleKeybind and Input.KeyCode == Enum.KeyCode[Library.ToggleKeybind] then
            Window:Toggle();
        end;
    end);

    LibraryMainOuterFrame = WindowOuter;

    return Window;
end;

function Library:Notify(Message, Time)
    if Library.Notify then
        Library.Notify(Message, Time);
    end;
end;

function Library:SetWatermarkVisibility(Bool)
    Library.Watermark.Parent.Parent.Visible = Bool;
end;

function Library:SetWatermark(Text)
    if Library.Watermark then
        Library.Watermark.Text = Text;
    end;
end;

function Library:OnThemeChange(Func)
    table.insert(Library.Signals, Func);
end;

getgenv().Linoria = Library;
return Library;