local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Right"

local Window = Library:CreateWindow({
    Title = 'mspaint',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    NotifySide = "Right",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    ESP = Window:AddTab('ESP'),
    Cheats = Window:AddTab('Cheats'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Main Tab
local MainLeftGroup = Tabs.Main:AddLeftGroupbox('Auto Features')
local MainRightGroup = Tabs.Main:AddRightGroupbox('Player Features')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ProximityPromptService = game:GetService("ProximityPromptService")

local player = Players.LocalPlayer
local RANGE = 12.5
local INTERVAL = 0.1

local fireOk = pcall(function()
    fireproximityprompt(Instance.new("ProximityPrompt"))
end)

local autoInteractEnabled = false
local autoInteractConnection = nil

local function firePrompt(prompt)
    if not (prompt and prompt.Enabled) then return end
    if fireOk and fireproximityprompt then
        fireproximityprompt(prompt)
    else
        prompt:InputHoldBegin()
        task.wait(prompt.HoldDuration or 0)
        prompt:InputHoldEnd()
    end
end

local ignoredNames = {
    HidePrompt = true, ClimbPrompt = true, PushPrompt = true,
    InteractPrompt = true, PropPrompt = true,
    StarRiftPrompt = true, RiftPrompt = true
}
local ignoredParents = {
    Padlock = true, Seek_Arm = true, KeyObtainFake = true
}

local lastCheck = 0

local function onHeartbeat(dt)
    if not autoInteractEnabled then return end
    
    lastCheck = lastCheck + dt
    if lastCheck < INTERVAL then return end
    lastCheck = 0

    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local pos = hrp.Position

    for _, prompt in ipairs(Workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") and prompt.Enabled
           and not ignoredNames[prompt.Name]
           and not ignoredParents[prompt.Parent and prompt.Parent.Name or ""] then
            
            local part = prompt.Parent
            if part:IsA("Model") then 
                part = part:FindFirstChildWhichIsA("BasePart") 
                if not part then goto continue end
            end
            
            if part:IsA("BasePart") and (part.Position - pos).Magnitude <= RANGE then
                firePrompt(prompt)
            end
        end
        ::continue::
    end
end

local function toggleAutoInteract(state)
    autoInteractEnabled = state
    if state then
        if autoInteractConnection then
            autoInteractConnection:Disconnect()
        end
        autoInteractConnection = RunService.Heartbeat:Connect(onHeartbeat)
    elseif autoInteractConnection then
        autoInteractConnection:Disconnect()
        autoInteractConnection = nil
    end
end

local Lighting = game:GetService("Lighting")
local brightnessEnabled = false
local originalProperties = {}
local brightnessConnection = nil

local function saveOriginalProperties()
    originalProperties.GlobalShadows = Lighting.GlobalShadows
    originalProperties.Brightness = Lighting.Brightness
    originalProperties.ClockTime = Lighting.ClockTime
    originalProperties.FogEnd = Lighting.FogEnd
    originalProperties.OutdoorAmbient = Lighting.OutdoorAmbient
    originalProperties.ExposureCompensation = Lighting.ExposureCompensation
end

local function applyBrightnessImmediately()
    Lighting.GlobalShadows = false
    Lighting.Brightness = 6
    Lighting.ClockTime = 14
    Lighting.FogEnd = 1e6
    Lighting.OutdoorAmbient = Color3.fromRGB(192, 192, 192)
    Lighting.ExposureCompensation = 0.25
end

local function setBrightness(state)
    brightnessEnabled = state
    if state then
        saveOriginalProperties()
        applyBrightnessImmediately()
        
        if brightnessConnection then
            brightnessConnection:Disconnect()
        end
        brightnessConnection = RunService.RenderStepped:Connect(function()
            applyBrightnessImmediately()
        end)
    else
        if brightnessConnection then
            brightnessConnection:Disconnect()
            brightnessConnection = nil
        end
        
        if originalProperties.GlobalShadows ~= nil then
            Lighting.GlobalShadows = originalProperties.GlobalShadows
            Lighting.Brightness = originalProperties.Brightness
            Lighting.ClockTime = originalProperties.ClockTime
            Lighting.FogEnd = originalProperties.FogEnd
            Lighting.OutdoorAmbient = originalProperties.OutdoorAmbient
            Lighting.ExposureCompensation = originalProperties.ExposureCompensation
        end
    end
end

MainLeftGroup:AddToggle('AutoInteract', {
    Text = 'Auto Interact',
    Default = false,
    Tooltip = 'Automatically interact with nearby objects',
    Callback = toggleAutoInteract
}):AddKeyPicker('AutoInteractKey', {
    Default = 'R',
    Text = 'Auto Interact Keybind',
    Callback = function(key)
        if key == 'R' then
            Toggles.AutoInteract:SetValue(not Toggles.AutoInteract.Value)
        end
    end
})

local speedEnabled = false
local targetSpeed = 18
local speedConnection = nil
local characterAddedConnection = nil

local function applySpeed(character)
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = targetSpeed
    end
end

local function onCharacterAdded(character)
    if speedEnabled then
        applySpeed(character)
    end
end

local function toggleSpeed(state)
    speedEnabled = state
    if state then
        if speedConnection then
            speedConnection:Disconnect()
        end
        
        if characterAddedConnection then
            characterAddedConnection:Disconnect()
        end
        
        if player.Character then
            applySpeed(player.Character)
        end
        
        characterAddedConnection = player.CharacterAdded:Connect(onCharacterAdded)
        
        speedConnection = RunService.Heartbeat:Connect(function()
            if player.Character then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                    humanoid.WalkSpeed = targetSpeed
                end
            end
        end)
    else
        if speedConnection then
            speedConnection:Disconnect()
            speedConnection = nil
        end
        
        if characterAddedConnection then
            characterAddedConnection:Disconnect()
            characterAddedConnection = nil
        end
        
        if player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
            end
        end
    end
end

local speedSlider = MainLeftGroup:AddSlider('SpeedValue', {
    Text = 'Speed Value',
    Default = 18,
    Min = 16,
    Max = 22,
    Rounding = 0,
    Suffix = ' studs',
    Callback = function(value)
        targetSpeed = value
        if speedEnabled and player.Character then
            applySpeed(player.Character)
        end
    end
})

MainLeftGroup:AddToggle('SpeedBoost', {
    Text = 'Speed Boost',
    Default = false,
    Tooltip = 'Increase movement speed',
    Callback = toggleSpeed
})

local jumpConnections = {}

local function setupJump()
    for _, conn in ipairs(jumpConnections) do
        conn:Disconnect()
    end
    jumpConnections = {}
    
    local char = player.Character
    if not char then return end
    
    char:SetAttribute("CanJump", true)
    
    local function fix()
        char:SetAttribute("CanJump", true)
    end
    
    table.insert(jumpConnections, char:GetAttributeChangedSignal("CanJump"):Connect(fix))
    table.insert(jumpConnections, player.CharacterAdded:Connect(function(newChar)
        task.wait(0.5)
        if newChar then
            newChar:SetAttribute("CanJump", true)
            table.insert(jumpConnections, newChar:GetAttributeChangedSignal("CanJump"):Connect(function()
                newChar:SetAttribute("CanJump", true)
            end))
        end
    end))
end

MainRightGroup:AddToggle('JumpButton', {
    Text = 'Force Jump',
    Default = false,
    Tooltip = 'Force enable jump attribute',
    Callback = function(state)
        if state then
            setupJump()
        else
            for _, conn in ipairs(jumpConnections) do
                conn:Disconnect()
            end
            jumpConnections = {}
            if player.Character and player.Character:GetAttribute("CanJump") ~= nil then
                player.Character:SetAttribute("CanJump", false)
            end
        end
    end
})

MainRightGroup:AddToggle("Brightness", {
    Text = "Brightness",
    Default = false,
    Callback = setBrightness
})

-- ESP Tab
local ESPGroup = Tabs.ESP:AddLeftGroupbox("ESP Settings")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local GameData = ReplicatedStorage:WaitForChild("GameData")
local LatestRoomVal = GameData:WaitForChild("LatestRoom")
local CurrentRooms = Workspace:WaitForChild("CurrentRooms")

local COL = {
    Key = Color3.fromRGB(0, 255, 0),
    Hide = Color3.fromRGB(255, 255, 0),
    Book = Color3.fromRGB(255, 100, 255),
    Lever = Color3.fromRGB(255, 165, 0),
    Breaker = Color3.fromRGB(255, 0, 200),
    Timer = Color3.fromRGB(0, 255, 255),
    Gen = Color3.fromRGB(255, 200, 0),
    Fuse = Color3.fromRGB(255, 255, 0),
    Chest = Color3.fromRGB(255, 215, 0),
    Gold = Color3.fromRGB(255, 215, 0),
    Player = Color3.fromRGB(0, 255, 255),
    Item = Color3.fromRGB(200, 200, 200),
    Anchor = Color3.fromRGB(255, 215, 0),
    EKey = Color3.fromRGB(0, 255, 0),
    Pump = Color3.fromRGB(255, 200, 0),
    ElectricalKey = Color3.fromRGB(0, 200, 200)
}

local ITEM_SET = {
    "Flashlight","Lockpick","Vitamins","Bandage","StarVial","StarBottle","StarJug",
    "Shakelight","Straplight","Bulklight","Battery","Candle","Crucifix","CrucifixWall",
    "Glowsticks","SkeletonKey","Candy","ShieldMini","ShieldBig","BandagePack","BatteryPack",
    "RiftCandle","LaserPointer","HolyGrenade","Shears","Smoothie","Cheese","Bread",
    "AlarmClock","RiftSmoothie","GweenSoda","GlitchCub","ElectricalKeyObtain"
}
local ITEM_MAP = {}
for _,v in ipairs(ITEM_SET) do ITEM_MAP[v]=true end

local function currentRoom()
    return CurrentRooms:FindFirstChild(tostring(LatestRoomVal.Value))
end

local function createTracer()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = 2
    line.Transparency = 0.8
    return line
end

local function isInPlayerHand(obj)
    if not obj then return false end
    if obj:IsA("Tool") then
        local parent = obj.Parent
        if parent and (parent:IsA("Model") or parent:IsA("Backpack")) then
            if parent:IsA("Model") and Players:GetPlayerFromCharacter(parent) then
                return true
            elseif parent:IsA("Backpack") then
                return true
            end
        end
    end
    local current = obj
    while current and current ~= workspace do
        if current:IsA("Model") and Players:GetPlayerFromCharacter(current) then
            return true
        end
        current = current.Parent
    end
    return false
end

local tracerESPs = {}
local tracerEnabled = false

local function addESP(obj, text, color, tracerColor)
    if not obj or not obj.Parent then return end
    if isInPlayerHand(obj) then return end
    if obj:FindFirstChild("PureESP") then obj.PureESP:Destroy() end
    local tracer = createTracer()
    tracer.Color = tracerColor or color
    tracerESPs[obj] = {
        object = obj,
        tracer = tracer,
        text = text,
        color = color
    }
    local hl = Instance.new("Highlight")
    hl.Name = "PureESP"
    hl.Adornee = obj
    hl.FillColor = color
    hl.OutlineColor = color
    hl.FillTransparency = 0.5
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Parent = obj
    local bg = Instance.new("BillboardGui")
    bg.Name = "PureESP"
    bg.Adornee = obj
    bg.Size = UDim2.new(0, 120, 0, 40)
    bg.AlwaysOnTop = true
    bg.LightInfluence = 0
    if obj.Name == "Bed" or obj.Name == "Double_Bed" then
        bg.StudsOffset = Vector3.new(0, 2, 0)
    end
    bg.Parent = obj
    local txt = Instance.new("TextLabel")
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency = 1
    txt.Font = Enum.Font.GothamBold
    txt.TextSize = 18
    txt.TextColor3 = color
    txt.TextStrokeTransparency = 0.5
    txt.TextStrokeColor3 = Color3.new(0,0,0)
    txt.Text = text
    txt.Parent = bg
    return hl, bg, tracer
end

local function clearRoomESP(room)
    if not room then return end
    for _,v in ipairs(room:GetDescendants()) do
        if v:FindFirstChild("PureESP") then v.PureESP:Destroy() end
        if tracerESPs[v] and tracerESPs[v].tracer then
            tracerESPs[v].tracer:Remove()
            tracerESPs[v] = nil
        end
    end
end

local HIDE_SPOTS = {
    "Wardrobe","Rooms_Locker","Backdoor_Wardrobe","Toolshed","Locker_Large",
    "Bed","CircularVent","Rooms_Locker_Fridge","RetroWardrobe","Dumpster","Double_Bed"
}

local EXTRA_ITEMS = {
    {"锚","MinesAnchor",COL.Anchor},
    {"电钥匙","ElectricalKeyObtain",COL.EKey},
    {"水泵","WaterPump",COL.Pump}
}

local function checkAndAddESP(obj)
    if isInPlayerHand(obj) then return end
    if obj.Name == "KeyObtain" and Toggles.KeyESP.Value then
        addESP(obj, "Key", COL.Key)
        return
    end
    if obj.Name == "ElectricalKeyObtain" and Toggles.ElectricalKeyESP.Value then
        addESP(obj, "Electrical Key", COL.ElectricalKey)
        return
    end
    for _,spot in ipairs(HIDE_SPOTS) do
        if obj.Name == spot and Toggles.ContainerESP.Value then
            if obj.Name == "Bed" or obj.Name == "Double_Bed" then
                addESP(obj, "Bed", COL.Hide)
            else
                addESP(obj, "Container", COL.Hide)
            end
            return
        end
    end
    if obj:IsA("Model") and obj.Name == "LiveHintBook" and Toggles.BookESP.Value then
        addESP(obj, "Book", COL.Book)
        return
    end
    if obj:IsA("Model") and obj.Name == "LeverForGate" and Toggles.LeverESP.Value then
        addESP(obj, "Lever", COL.Lever)
        return
    end
    if obj.Name == "LiveBreakerPolePickup" and Toggles.BreakerESP.Value then
        addESP(obj, "Breaker", COL.Breaker)
        return
    end
    if obj.Name == "TimerLever" and Toggles.TimerESP.Value then
        addESP(obj, "Timer", COL.Timer)
        return
    end
    if obj.Name == "MinesGenerator" and Toggles.GeneratorESP.Value then
        addESP(obj, "Generator", COL.Gen)
        return
    end
    if obj.Name == "FuseObtain" and Toggles.FuseESP.Value then
        addESP(obj, "Fuse", COL.Fuse)
        return
    end
    if obj.Name == "ChestBox" and Toggles.ChestESP.Value then
        addESP(obj, "Chest", COL.Chest)
        return
    end
    if obj.Name == "GoldPile" and Toggles.GoldESP.Value then
        addESP(obj, "Gold "..tostring(obj:GetAttribute("GoldValue") or "?"), COL.Gold)
        return
    end
    for _,row in ipairs(EXTRA_ITEMS) do
        if obj.Name == row[2] and Toggles.ExtraItemsESP.Value then
            addESP(obj, row[1], row[3])
            return
        end
    end
    if ITEM_MAP[obj.Name] and Toggles.ItemESP.Value then
        addESP(obj, obj.Name, COL.Item)
        return
    end
end

local currentRoomListener = nil

local function setupRoomListener(room)
    if currentRoomListener then
        currentRoomListener:Disconnect()
        currentRoomListener = nil
    end
    if not room then return end
    for _, obj in ipairs(room:GetDescendants()) do
        checkAndAddESP(obj)
    end
    currentRoomListener = room.DescendantAdded:Connect(checkAndAddESP)
end

local function updateTracers()
    if not Workspace.CurrentCamera then return end
    
    for obj, data in pairs(tracerESPs) do
        if obj and obj.Parent and data.tracer then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                local pos = part.Position
                local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(pos)
                
                if onScreen and tracerEnabled then
                    data.tracer.From = Vector2.new(Workspace.CurrentCamera.ViewportSize.X / 2, Workspace.CurrentCamera.ViewportSize.Y)
                    data.tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                    data.tracer.Visible = true
                else
                    data.tracer.Visible = false
                end
            else
                data.tracer.Visible = false
            end
        else
            if data and data.tracer then
                data.tracer:Remove()
            end
            tracerESPs[obj] = nil
        end
    end
end

local tracerConnection = nil
local function toggleTracer(state)
    tracerEnabled = state
    if state then
        if tracerConnection then
            tracerConnection:Disconnect()
        end
        tracerConnection = RunService.RenderStepped:Connect(updateTracers)
    elseif tracerConnection then
        tracerConnection:Disconnect()
        tracerConnection = nil
        
        for _, data in pairs(tracerESPs) do
            if data.tracer then
                data.tracer.Visible = false
            end
        end
    end
end

ESPGroup:AddToggle("TracerESP", {
    Text = "Tracer ESP",
    Default = false,
    Callback = toggleTracer
})

ESPGroup:AddToggle("KeyESP", {
    Text = "Key ESP",
    Default = false
})

ESPGroup:AddToggle("ElectricalKeyESP", {
    Text = "Electrical Key ESP",
    Default = false
})

ESPGroup:AddToggle("ContainerESP", {
    Text = "Container ESP",
    Default = false
})

ESPGroup:AddToggle("BookESP", {
    Text = "Book ESP",
    Default = false
})

ESPGroup:AddToggle("LeverESP", {
    Text = "Lever ESP",
    Default = false
})

ESPGroup:AddToggle("BreakerESP", {
    Text = "Breaker ESP",
    Default = false
})

ESPGroup:AddToggle("TimerESP", {
    Text = "Timer ESP",
    Default = false
})

ESPGroup:AddToggle("GeneratorESP", {
    Text = "Generator ESP",
    Default = false
})

ESPGroup:AddToggle("FuseESP", {
    Text = "Fuse ESP",
    Default = false
})

ESPGroup:AddToggle("ChestESP", {
    Text = "Chest ESP",
    Default = false
})

ESPGroup:AddToggle("GoldESP", {
    Text = "Gold ESP",
    Default = false
})

ESPGroup:AddToggle("ExtraItemsESP", {
    Text = "Extra Items ESP",
    Default = false
})

ESPGroup:AddToggle("ItemESP", {
    Text = "Item ESP",
    Default = false
})

local function initESP()
    local room = currentRoom()
    if room then
        setupRoomListener(room)
    end
    
    LatestRoomVal:GetPropertyChangedSignal("Value"):Connect(function()
        local oldRoom = room
        local newRoom = currentRoom()
        if newRoom then
            clearRoomESP(oldRoom)
            setupRoomListener(newRoom)
        end
    end)
end

initESP()

local EntityESPGroup = Tabs.ESP:AddRightGroupbox("Entity ESP")

local EspEntityNameDis = {
    ["FigureRig"] = "Figure",
    ["SallyMoving"] = "Window",
    ["RushMoving"] = "Rush",
    ["Eyes"] = "Eyes",
    ["Groundskeeper"] = "Skeeper",
    ["BackdoorLookman"] = "Lookman",
    ["BackdoorRush"] = "Blitz",
    ["MandrakeLive"] = "Mandrake",
    ["GloomPile"] = "Egg",
    ["Snare"] = "Snare",
    ["GrumbleRig"] = "Grumble",
    ["GiggleCeiling"] = "Giggle",
    ["AmbushMoving"] = "Ambush"
}

local EntityAdd = {}
local EntitySpawn, EntityRemove

local function CreateESP(v)
    local highlight = Instance.new("Highlight")
    highlight.Name = "EntityESP"
    highlight.Adornee = v
    highlight.FillColor = Color3.fromRGB(255, 50, 50)
    highlight.OutlineColor = Color3.fromRGB(255, 50, 50)
    highlight.FillTransparency = 0.5
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = v

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "EntityESP"
    billboard.Adornee = v
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.Parent = v

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 18
    textLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.Text = EspEntityNameDis[v.Name] or v.Name
    textLabel.Parent = billboard

    EntityAdd[v] = {highlight, billboard}
    
    local tracer = createTracer()
    tracer.Color = Color3.fromRGB(255, 50, 50)
    tracerESPs[v] = {
        object = v,
        tracer = tracer,
        text = EspEntityNameDis[v.Name] or v.Name,
        color = Color3.fromRGB(255, 50, 50)
    }
end

local function RemoveESP(v)
    if EntityAdd[v] then
        for _, obj in ipairs(EntityAdd[v]) do
            obj:Destroy()
        end
        EntityAdd[v] = nil
    end
    
    if tracerESPs[v] then
        if tracerESPs[v].tracer then
            tracerESPs[v].tracer:Remove()
        end
        tracerESPs[v] = nil
    end
end

local function EnableEntityESP(Value)
    if Value then
        for _, v in pairs(workspace:GetDescendants()) do
            if EspEntityNameDis[v.Name] and v:IsA("Model") then
                CreateESP(v)
            end
        end

        EntitySpawn = workspace.DescendantAdded:Connect(function(v)
            if EspEntityNameDis[v.Name] and v:IsA("Model") then
                CreateESP(v)
            end
        end)

        EntityRemove = workspace.DescendantRemoving:Connect(function(v)
            if EntityAdd[v] then
                RemoveESP(v)
            end
        end)
    else
        for v, _ in pairs(EntityAdd) do
            RemoveESP(v)
        end
        EntityAdd = {}

        if EntitySpawn then
            EntitySpawn:Disconnect()
            EntitySpawn = nil
        end
        if EntityRemove then
            EntityRemove:Disconnect()
            EntityRemove = nil
        end
    end
end

EntityESPGroup:AddToggle("EntityESP", {
    Text = "Entity ESP",
    Default = false,
    Callback = EnableEntityESP
})

-- Cheats Tab
local AntiBox = Tabs.Cheats:AddLeftGroupbox("Anti-Cheat")
local VisualBox = Tabs.Cheats:AddRightGroupbox("Visual Settings")
local FOVBox = Tabs.Cheats:AddLeftGroupbox("FOV Settings")

local LocalPlayer = Players.LocalPlayer
local WorkspaceCamera = Workspace.CurrentCamera
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService")

local screechCon = nil
AntiBox:AddToggle("AntiScreech", {
    Text = "Remove Screech",
    Default = false,
    Callback = function(enabled)
        if screechCon then
            screechCon:Disconnect()
            screechCon = nil
        end
        if enabled then
            local camKids = WorkspaceCamera:GetChildren()
            for i = 1, #camKids do
                if camKids[i].Name == "GlitchedScreech" then
                    camKids[i]:Destroy()
                end
            end
            screechCon = WorkspaceCamera.ChildAdded:Connect(function(child)
                if child.Name == "GlitchedScreech" then
                    child:Destroy()
                end
            end)
            local mods = LocalPlayer.PlayerGui
                :WaitForChild("MainUI")
                :WaitForChild("Initiator")
                :WaitForChild("Main_Game")
                :WaitForChild("RemoteListener")
                :WaitForChild("Modules")
            local mod = mods:FindFirstChild("Screech") or mods:FindFirstChild("_Screech")
            if mod then
                mod.Name = "_Screech"
            end
        else
            local mods = LocalPlayer.PlayerGui
                :WaitForChild("MainUI")
                :WaitForChild("Initiator")
                :WaitForChild("Main_Game")
                :WaitForChild("RemoteListener")
                :WaitForChild("Modules")
            local mod = mods:FindFirstChild("_Screech") or mods:FindFirstChild("Screech")
            if mod then
                mod.Name = "Screech"
            end
        end
    end
})

AntiBox:AddToggle("AntiDread", {
    Text = "Remove Dread",
    Default = false,
    Callback = function(enabled)
        local mods = LocalPlayer.PlayerGui
            :WaitForChild("MainUI")
            :WaitForChild("Initiator")
            :WaitForChild("Main_Game")
            :WaitForChild("RemoteListener")
            :WaitForChild("Modules")
        local mod = mods:FindFirstChild("Dread") or mods:FindFirstChild("_Dread")
        if mod then
            mod.Name = enabled and "_Dread" or "Dread"
        end
    end
})

local THROTTLE = 0.02
local hearingCon = nil
AntiBox:AddToggle("AntiFigureHearing", {
    Text = "Anti-Figure Hearing",
    Default = false,
    Callback = function(enabled)
        if hearingCon then
            hearingCon:Disconnect()
            hearingCon = nil
        end
        if enabled then
            local acc = 0
            hearingCon = RunService.Heartbeat:Connect(function(dt)
                acc = acc + dt
                if acc < THROTTLE then
                    return
                end
                acc = 0
                local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder")
                remotes = remotes and remotes:FindFirstChild("Crouch")
                if remotes then
                    remotes:FireServer(true)
                end
            end)
        else
            local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder")
            remotes = remotes and remotes:FindFirstChild("Crouch")
            if remotes then
                remotes:FireServer(false)
            end
        end
    end
})

AntiBox:AddToggle("AntiA90", {
    Text = "Remove A90",
    Default = false,
    Callback = function(enabled)
        local mods = LocalPlayer.PlayerGui
            :WaitForChild("MainUI")
            :WaitForChild("Initiator")
            :WaitForChild("Main_Game")
            :WaitForChild("RemoteListener")
            :WaitForChild("Modules")
        local mod = mods:FindFirstChild("A90") or mods:FindFirstChild("_A90")
        if mod then
            mod.Name = enabled and "_A90" or "A90"
        end
    end
})

local eyesCon = nil
local Remotes = nil
local motor = nil

if ReplicatedStorage:FindFirstChild("EntityInfo") then
    Remotes = ReplicatedStorage.EntityInfo
else
    Remotes = ReplicatedStorage:FindFirstChild("RemotesFolder") or ReplicatedStorage
end

motor = Remotes:FindFirstChild("MotorReplication")

if motor then
    AntiBox:AddToggle("AntiEyes", {
        Text = "Anti-Eyes",
        Default = false,
        Callback = function(enabled)
            if eyesCon then
                eyesCon:Disconnect()
                eyesCon = nil
            end
            if enabled then
                eyesCon = RunService.Heartbeat:Connect(function()
                    if Workspace:FindFirstChild("Eyes") then
                        motor:FireServer(-760)
                    end
                end)
            end
        end
    })
end

local lookmanCon = nil
AntiBox:AddToggle("AntiLookman", {
    Text = "Anti-Lookman",
    Default = false,
    Callback = function(enabled)
        if lookmanCon then
            lookmanCon:Disconnect()
            lookmanCon = nil
        end
        if enabled then
            lookmanCon = RunService.Heartbeat:Connect(function()
                if Workspace:FindFirstChild("BackdoorLookman") then
                    motor:FireServer(-760)
                end
            end)
        end
    end
})

local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
local cachedDensity = nil
local antiFogActive = false

if atmosphere then
    VisualBox:AddToggle("AntiFog", {
    Text = "Anti-Fog",
    Default = false,
    Callback = function(enabled)
        antiFogActive = enabled

        if enabled then
            if cachedDensity == nil then
                cachedDensity = atmosphere.Density
            end

            task.spawn(function()
                while antiFogActive do
                    TweenService:Create(
                        atmosphere,
                        TweenInfo.new(0.5),
                        { Density = 0 }
                    ):Play()
                    task.wait(0.8)
                end
            end)
        else
            if cachedDensity then
                TweenService:Create(
                    atmosphere,
                    TweenInfo.new(0.5),
                    { Density = cachedDensity }
                ):Play()
            end
        end
    end
})
end

local shade = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Shade")
    or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Shade")

if shade then
    VisualBox:AddToggle('AntiShutdown', {
        Text = "Anti-Shutdown",
        Default = false,
        Callback = function(on)
            shade.Name = on and "_Shade" or "Shade"
        end
    })
end

local Void = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Void")
    or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Void")

if Void then
    VisualBox:AddToggle('AntiVoidJump', {
        Text = "Anti-Void Jump",
        Default = false,
        Callback = function(on)
            Void.Name = on and "_Void" or "Void"
        end
    })
end

local Glitch = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Glitch")
    or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Glitch")

if Glitch then
    VisualBox:AddToggle('AntiGlitchJump', {
        Text = "Anti-Glitch Jump",
        Default = false,
        Callback = function(on)
            Glitch.Name = on and "_Glitch" or "Glitch"
        end
    })
end

VisualBox:AddToggle('AntiJamming', {
    Text = "Anti-Jamming",
    Default = false,
    Callback = function(state)
        if not game:GetService("ReplicatedStorage").LiveModifiers.Jammin then return end
        local mainTrack = SoundService:FindFirstChild("Main")
        if mainTrack then
            local jamming = mainTrack:FindFirstChild("Jamming")
            if jamming then
                jamming.Enabled = not state
            end
        end

        local mainUI = LocalPlayer:FindFirstChild("PlayerGui")
            and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
        if mainUI then
            local healthGui = mainUI:FindFirstChild("Initiator")
                and mainUI.Initiator:FindFirstChild("Main_Game")
                and mainUI.Initiator.Main_Game:FindFirstChild("Health")
            if healthGui then
                local jamSound = healthGui:FindFirstChild("Jam")
                if jamSound then
                    jamSound.Playing = not state
                end
            end
        end
    end
})

VisualBox:AddToggle("NoCutScenes", {
    Text = "No CutScenes",
    Default = false,
    Callback = function(enabled)
        if enabled then
            local CutScenes = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("Cutscenes") 
                or game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("_Cutscenes")
            if CutScenes then
                CutScenes.Name = enabled and "_Cutscenes" or "Cutscenes"
            end
        end
    end
})

local currentFOV = 70
local targetFOV = 70
local fovEnabled = false
local stepping = false
local fovConn = nil
local playingThinkAnimation = false
local camera = Workspace.CurrentCamera

local function monitorAnimations(char)
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator", 3)
    if not animator then return end

    local animFolder = char:FindFirstChild("Animations")
    if not animFolder then return end

    local think1 = animFolder:FindFirstChild("Think1")
    local think2 = animFolder:FindFirstChild("Think2")
    if not (think1 or think2) then return end

    local thinkIds = {}
    if think1 and think1:IsA("Animation") then
        table.insert(thinkIds, think1.AnimationId)
    end
    if think2 and think2:IsA("Animation") then
        table.insert(thinkIds, think2.AnimationId)
    end

    local function updateFOVBasedOnPlayingTracks()
        local tracks = animator:GetPlayingAnimationTracks()
        local thinking = false
        for _, track in pairs(tracks) do
            for _, id in pairs(thinkIds) do
                if track.Animation.AnimationId == id then
                    thinking = true
                    break
                end
            end
            if thinking then break end
        end

        if thinking and not playingThinkAnimation then
            playingThinkAnimation = true
            currentFOV = 70
            camera.FieldOfView = currentFOV
        elseif not thinking and playingThinkAnimation then
            playingThinkAnimation = false
            if fovEnabled then
                currentFOV = targetFOV
                stepFOV()
            end
        end
    end

    animator.AnimationPlayed:Connect(updateFOVBasedOnPlayingTracks)
    updateFOVBasedOnPlayingTracks()
end

local function stepFOV()
    if stepping then return end
    stepping = true
    task.spawn(function()
        while stepping and currentFOV ~= targetFOV do
            local delta = targetFOV - currentFOV
            local step = (delta > 0 and 2) or -2
            if math.abs(delta) < 2 then
                step = delta
            end
            currentFOV = currentFOV + step
            camera.FieldOfView = currentFOV
            task.wait(0.009)
        end
        stepping = false
    end)
end

local function startEnforcing()
    if fovConn then fovConn:Disconnect() end
    fovConn = camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if math.abs(camera.FieldOfView - currentFOV) > 0.1 then
            camera.FieldOfView = currentFOV
        end
    end)
    camera.FieldOfView = currentFOV
end

local function stopEnforcing()
    if fovConn then
        fovConn:Disconnect()
        fovConn = nil
    end
end

local function waitForCamera()
    repeat
        camera = Workspace.CurrentCamera
        task.wait(0.2)
    until camera
end

waitForCamera()

LocalPlayer.CharacterAdded:Connect(function(char)
    waitForCamera()
    if fovEnabled then
        currentFOV = camera.FieldOfView
        startEnforcing()
        stepFOV()
    end
    monitorAnimations(char)
end)

Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    waitForCamera()
    if fovEnabled then
        currentFOV = camera.FieldOfView
        startEnforcing()
        stepFOV()
    end
end)

if LocalPlayer.Character then
    monitorAnimations(LocalPlayer.Character)
end

FOVBox:AddSlider("FOV", {
    Text = "FOV",
    Min = 70,
    Max = 120,
    Default = 70,
    Rounding = 0,
    Callback = function(value)
        targetFOV = value
        if fovEnabled and not playingThinkAnimation then
            stepFOV()
        end
    end,
})

FOVBox:AddToggle("EnableFOV", {
    Text = "Enable FOV",
    Default = false,
    Callback = function(on)
        fovEnabled = on
        waitForCamera()

        if on then
            currentFOV = camera.FieldOfView
            startEnforcing()
            if not playingThinkAnimation then
                stepFOV()
            end
        else
            stopEnforcing()
            targetFOV = 70
            stepFOV()
        end
    end,
})

local SpeedBypassGroup = Tabs.Cheats:AddRightGroupbox("Speed Bypass")

local DEFAULT_WALK_SPEED_MAX = 22
local speedBypassDelay = 0.23
local OldAccel = nil
local ClonedCollision = nil
local speedBypassConnection = nil

local function InitSpeedBypass()
    if not LocalPlayer.Character then return false end
    if not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return false end
    if not LocalPlayer.Character:FindFirstChild("Collision") then return false end

    OldAccel = LocalPlayer.Character.HumanoidRootPart.CustomPhysicalProperties
    ClonedCollision = LocalPlayer.Character.Collision:Clone()
    ClonedCollision.Name = "_CollisionClone"
    ClonedCollision.Massless = true
    ClonedCollision.Parent = LocalPlayer.Character
    ClonedCollision.CanCollide = false
    ClonedCollision.CanQuery = false
    ClonedCollision.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0.7, 0, 1, 1)
    return true
end

local function ToggleSpeedBypass(value)
    if value then
        if not InitSpeedBypass() then
            Toggles.SpeedBypass:SetValue(false)
            return
        end
        
        local accumulator = 0
        speedBypassConnection = RunService.Heartbeat:Connect(function(dt)
            if Toggles.SpeedBypass.Value and ClonedCollision then
                Options.SpeedValue:SetMax(35)
                
                accumulator = accumulator + dt
                if accumulator >= speedBypassDelay then
                    accumulator = 0
                    ClonedCollision.Massless = not ClonedCollision.Massless
                end
            end
        end)
    else
        if speedBypassConnection then
            speedBypassConnection:Disconnect()
            speedBypassConnection = nil
        end
        
        Options.SpeedValue:SetMax(DEFAULT_WALK_SPEED_MAX)
        
        if ClonedCollision then
            ClonedCollision:Destroy()
            ClonedCollision = nil
        end
        
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CustomPhysicalProperties = OldAccel
        end
    end
end

SpeedBypassGroup:AddToggle("SpeedBypass", {
    Text = "Speed Bypass",
    Default = false,
    Tooltip = "Bypass speed limitations",
    Callback = ToggleSpeedBypass
})

SpeedBypassGroup:AddSlider("SpeedBypassDelay", {
    Text = "Speed Bypass Delay",
    Default = 0.23,
    Min = 0.21,
    Max = 0.25,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        speedBypassDelay = value
    end
})

player.CharacterAdded:Connect(function(character)
    character:WaitForChild("HumanoidRootPart")
    character:WaitForChild("Collision")
    
    if Toggles.SpeedBypass.Value then
        ToggleSpeedBypass(false)
        task.wait(0.1)
        ToggleSpeedBypass(true)
    end
end)

player.CharacterRemoving:Connect(function()
    if Toggles.SpeedBypass.Value then
        ToggleSpeedBypass(false)
    end
end)

local CYAN_COLOR = Color3.new(0, 1, 1)
local CHEST_COLOR = Color3.new(1, 0.5, 0)

local HIGHLIGHT_SETTINGS = {
    FillColor = CYAN_COLOR,
    OutlineColor = CYAN_COLOR,
    FillTransparency = 0.5,
    DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
}

local CHEST_HIGHLIGHT_SETTINGS = {
    FillColor = CHEST_COLOR,
    OutlineColor = CHEST_COLOR,
    FillTransparency = 0.5,
    DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
}

local LABEL_SETTINGS = {
    Size = UDim2.new(0, 120, 0, 50),
    Font = Enum.Font.GothamBold,
    TextSize = 20,
    TextColor = CYAN_COLOR,
    TextStrokeTransparency = 0.7,
    TextStrokeColor3 = Color3.new(0, 0.5, 0.5),
    AnchorPoint = Vector2.new(0.5, 0.5),
    AlwaysOnTop = true,
    LightInfluence = 0
}

local CHEST_LABEL_SETTINGS = {
    Size = UDim2.new(0, 120, 0, 50),
    Font = Enum.Font.GothamBold,
    TextSize = 20,
    TextColor = CHEST_COLOR,
    TextStrokeTransparency = 0.7,
    TextStrokeColor3 = Color3.new(0.5, 0.25, 0),
    AnchorPoint = Vector2.new(0.5, 0.5),
    AlwaysOnTop = true,
    LightInfluence = 0
}

local doorESPs = {}
local chestESPs = {}

local function pickOffset(roomId)
    local seed = roomId % 8
    local offsets = {
        Vector3.new(0, 0, 0),
        Vector3.new(0, 2, 0),
        Vector3.new(0, -2, 0),
        Vector3.new(2, 0, 0),
        Vector3.new(-2, 0, 0),
        Vector3.new(0, 0, 2),
        Vector3.new(0, 0, -2),
        Vector3.new(0, 1, 1)
    }
    return offsets[seed + 1]
end

local function createDoorESP(door, roomId)
    if door:FindFirstChild("DoorESP") then return end
    
    local anchor = Instance.new("Part")
    anchor.Anchored = true
    anchor.CanCollide = false
    anchor.Transparency = 1
    anchor.Size = Vector3.new()
    anchor.CFrame = door.CFrame + pickOffset(roomId)
    anchor.Parent = workspace
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "DoorHighlight"
    highlight.Adornee = door
    for k, v in pairs(HIGHLIGHT_SETTINGS) do
        highlight[k] = v
    end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "DoorLabel"
    billboard.Adornee = anchor
    billboard.Size = LABEL_SETTINGS.Size
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    
    local label = Instance.new("TextLabel")
    label.Name = "DoorText"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = LABEL_SETTINGS.Font
    label.TextSize = LABEL_SETTINGS.TextSize
    label.TextColor3 = LABEL_SETTINGS.TextColor
    label.TextStrokeTransparency = LABEL_SETTINGS.TextStrokeTransparency
    label.TextStrokeColor3 = LABEL_SETTINGS.TextStrokeColor3
    label.AnchorPoint = LABEL_SETTINGS.AnchorPoint
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    
    local espFolder = Instance.new("Folder")
    espFolder.Name = "DoorESP"
    espFolder.Parent = door
    
    highlight.Parent = espFolder
    billboard.Parent = espFolder
    label.Parent = billboard
    
    local line = createTracer()
    line.Color = CYAN_COLOR
    
    doorESPs[door] = {
        door = door,
        label = label,
        anchor = anchor,
        highlight = highlight,
        line = line
    }
end

local function createChestESP(chest, roomId)
    if chest:FindFirstChild("ChestESP") then return end
    
    local anchor = Instance.new("Part")
    anchor.Anchored = true
    anchor.CanCollide = false
    anchor.Transparency = 1
    anchor.Size = Vector3.new()
    anchor.CFrame = chest.CFrame + pickOffset(roomId)
    anchor.Parent = workspace
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ChestHighlight"
    highlight.Adornee = chest
    for k, v in pairs(CHEST_HIGHLIGHT_SETTINGS) do
        highlight[k] = v
    end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ChestLabel"
    billboard.Adornee = anchor
    billboard.Size = CHEST_LABEL_SETTINGS.Size
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    
    local label = Instance.new("TextLabel")
    label.Name = "ChestText"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = CHEST_LABEL_SETTINGS.Font
    label.TextSize = CHEST_LABEL_SETTINGS.TextSize
    label.TextColor3 = CHEST_LABEL_SETTINGS.TextColor
    label.TextStrokeTransparency = CHEST_LABEL_SETTINGS.TextStrokeTransparency
    label.TextStrokeColor3 = CHEST_LABEL_SETTINGS.TextStrokeColor3
    label.AnchorPoint = CHEST_LABEL_SETTINGS.AnchorPoint
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    
    local espFolder = Instance.new("Folder")
    espFolder.Name = "ChestESP"
    espFolder.Parent = chest
    
    highlight.Parent = espFolder
    billboard.Parent = espFolder
    label.Parent = billboard
    
    local line = createTracer()
    line.Color = CHEST_COLOR
    
    chestESPs[chest] = {
        chest = chest,
        label = label,
        anchor = anchor,
        highlight = highlight,
        line = line
    }
end

local function updateDoorAndChestESP()
    local tracerEnabled = Toggles.TracerESP.Value
    
    for door, data in pairs(doorESPs) do
        if door and door.Parent then
            local doorFolder = door.Parent
            local lock = doorFolder and doorFolder:FindFirstChild("Lock")
            local lockText = lock and " 锁定" or ""
            data.label.Text = string.format("门 %d%s", tonumber(door.Parent.Parent.Name or "0") + 1, lockText)
            
            local doorPos = data.anchor.Position
            local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(doorPos)
            
            if onScreen and tracerEnabled then
                data.line.Visible = true
                data.line.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                data.line.To = Vector2.new(screenPos.X, screenPos.Y)
            else
                data.line.Visible = false
            end
        else
            if data.line then
                data.line:Remove()
            end
            if data.anchor then
                data.anchor:Destroy()
            end
            doorESPs[door] = nil
        end
    end
    
    for chest, data in pairs(chestESPs) do
        if chest and chest.Parent then
            local locked = chest.Name == "ChestBoxLocked"
            local lockText = locked and " 锁定" or " 未锁定"
            data.label.Text = string.format("宝箱%s", lockText)
            
            local chestPos = data.anchor.Position
            local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(chestPos)
            
            if onScreen and tracerEnabled then
                data.line.Visible = true
                data.line.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                data.line.To = Vector2.new(screenPos.X, screenPos.Y)
            else
                data.line.Visible = false
            end
        else
            if data.line then
                data.line:Remove()
            end
            if data.anchor then
                data.anchor:Destroy()
            end
            chestESPs[chest] = nil
        end
    end
end

local function scanForDoorsAndChests()
    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
        local roomId = tonumber(room.Name)
        if roomId then
            local doorFolder = room:FindFirstChild("Door")
            if doorFolder then
                local door = doorFolder:FindFirstChild("Door")
                if door and not doorESPs[door] then
                    createDoorESP(door, roomId)
                end
            end
            
            local sideroom = room:FindFirstChild("Sideroom")
            if sideroom then
                local assets = sideroom:FindFirstChild("Assets")
                if assets then
                    local chest = assets:FindFirstChild("ChestBoxLocked")
                    if chest and not chestESPs[chest] then
                        createChestESP(chest, roomId)
                    end
                end
            end
        end
    end
end

scanForDoorsAndChests()

RunService.Heartbeat:Connect(function()
    updateDoorAndChestESP()
end)

workspace.CurrentRooms.ChildAdded:Connect(function(child)
    if tonumber(child.Name) then
        task.wait(0.05)
        scanForDoorsAndChests()
    end
end)

-- UI Settings Tab
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")
local ThemeGroup = Tabs["UI Settings"]:AddRightGroupbox("Themes")

MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Left", "Right" },
    Default = "Right",
    Text = "Notification Side",
    Callback = function(Value)
        Library:SetNotifySide(Value)
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "DPI Scale",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value) / 100
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()

MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { 
    Default = "RightShift", 
    NoUI = true, 
    Text = "Menu keybind" 
})

MenuGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
ThemeManager:SetFolder("mspaint")
SaveManager:SetFolder("mspaint")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60
local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    Library:SetWatermark(('FPS: %s | Ping: %s ms | mspaint'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    Library.Unloaded = true
end)

SaveManager:LoadAutoloadConfig()
Library:Notify("UI loaded successfully! Notifications should appear on the right.", 5)