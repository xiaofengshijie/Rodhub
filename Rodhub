local RodhubSystem = (function()
    local _state = {
        combat = {enabled=false, radius=100, frequency=0, lastTime=0},
        scrap = {enabled=false, cache={}, task=nil},
        log = {enabled=false, cache={}, task=nil}
    }

    local _services = {
        players = game:GetService("Players"),
        replicatedStorage = game:GetService("ReplicatedStorage"),
        runService = game:GetService("RunService"),
        workspace = game:GetService("Workspace")
    }

    local _player = _services.players.LocalPlayer
    local _character = _player.Character or _player.CharacterAdded:Wait()
    local _rootPart = _character:WaitForChild("HumanoidRootPart")
    local _shootRemote = _services.replicatedStorage:WaitForChild("remotes"):WaitForChild("shoot")

    local function _initCombat()
        _services.runService.Heartbeat:Connect(function()
            if not _state.combat.enabled or _state.combat.frequency <= 0 then return end
            
            local currentTime = tick()
            if currentTime - _state.combat.lastTime < (1/_state.combat.frequency) then return end
            _state.combat.lastTime = currentTime
            
            for _, target in ipairs(_services.workspace.animals:GetChildren()) do
                if target.Name == "deer" and target:FindFirstChild("HumanoidRootPart") then
                    local distance = (target.HumanoidRootPart.Position - _rootPart.Position).Magnitude
                    if distance <= _state.combat.radius then
                        local args = {
                            CFrame.new(_rootPart.Position, target.HumanoidRootPart.Position),
                            CFrame.new(_rootPart.Position + Vector3.new(0,1,0), target.HumanoidRootPart.Position)
                        }
                        _shootRemote:FireServer(unpack(args))
                        if _state.combat.frequency < 10 then break end
                    end
                end
            end
        end)
    end

    local function _initScrap()
        local function _updateCache()
            table.clear(_state.scrap.cache)
            local scraps = _services.workspace:FindFirstChild("scraps")
            if scraps then
                for _, scrap in ipairs(scraps:GetChildren()) do
                    local material = scrap:FindFirstChild("defaultMaterial10")
                    local prompt = material and material:FindFirstChild("ProximityPrompt")
                    if prompt then
                        table.insert(_state.scrap.cache, {
                            pos = scrap:GetPivot().Position,
                            prompt = prompt,
                            scrap = scrap
                        })
                    end
                end
            end
        end

        local function _collectProcess()
            while _state.scrap.enabled and #_state.scrap.cache > 0 do
                local nearest = nil
                local minDist = math.huge
                
                for _, data in ipairs(_state.scrap.cache) do
                    if data.scrap.Parent then
                        local dist = (data.pos - _rootPart.Position).Magnitude
                        if dist < minDist then
                            minDist = dist
                            nearest = data
                        end
                    end
                end
                
                if nearest then
                    _rootPart.CFrame = CFrame.new(nearest.pos + Vector3.new(0,1.5,0))
                    
                    for _ = 1, 3 do
                        if nearest.prompt and nearest.prompt.Parent then
                            fireproximityprompt(nearest.prompt)
                        end
                        task.wait(0.05)
                    end
                    
                    for i, v in ipairs(_state.scrap.cache) do
                        if v == nearest then
                            table.remove(_state.scrap.cache, i)
                            break
                        end
                    end
                else
                    _updateCache()
                end
            end
            
            if _state.scrap.enabled then
                task.wait(1)
                _updateCache()
                _state.scrap.task = task.spawn(_collectProcess)
            end
        end

        return {
            updateCache = _updateCache,
            collectProcess = _collectProcess
        }
    end

    local function _initLog()
        local function _findPrompt(obj)
            if obj:IsA("ProximityPrompt") then return obj end
            for _, child in ipairs(obj:GetChildren()) do
                local found = _findPrompt(child)
                if found then return found end
            end
        end

        local function _updateCache()
            table.clear(_state.log.cache)
            local logs = _services.workspace:FindFirstChild("logs")
            if logs then
                for _, log in ipairs(logs:GetChildren()) do
                    local prompt = _findPrompt(log)
                    if prompt then
                        table.insert(_state.log.cache, {
                            model = log,
                            prompt = prompt
                        })
                    end
                end
            end
        end

        local function _collectProcess()
            while _state.log.enabled do
                for i = #_state.log.cache, 1, -1 do
                    if not _state.log.enabled then break end
                    
                    local data = _state.log.cache[i]
                    if data.model.Parent then
                        for _ = 1, 5 do
                            if data.prompt and data.prompt.Parent then
                                fireproximityprompt(data.prompt)
                            end
                            task.wait(0.03)
                        end
                        table.remove(_state.log.cache, i)
                    else
                        table.remove(_state.log.cache, i)
                    end
                end
                
                _updateCache()
                task.wait(0.5)
            end
        end

        return {
            updateCache = _updateCache,
            collectProcess = _collectProcess
        }
    end

    local function _createUI()
        local Rodhub = loadstring(game:HttpGet("https://raw.githubusercontent.com/iopjklbnmsss/SansHublib/refs/heads/main/lib1"))()
        local window = Rodhub:CreateWindow("Rodhub开源项目", "blue")

        local combatTab = window:CreateTab("RodHub杀戮光环")
        combatTab:CreateToggle("启用自动射击", false, function(state)
            _state.combat.enabled = state
        end)
        combatTab:CreateSlider("射击半径", 10, 500, 100, function(value)
            _state.combat.radius = value
        end)
        combatTab:CreateSlider("射击频率(次/秒)", 0, 20, 0, function(value)
            _state.combat.frequency = value
        end)

        local farmTab = window:CreateTab("RodHub自动收集废料")
        farmTab:CreateToggle("废料收集", false, function(state)
            _state.scrap.enabled = state
            if state then
                local scrap = _initScrap()
                scrap.updateCache()
                _state.scrap.task = task.spawn(scrap.collectProcess)
            elseif _state.scrap.task then
                task.cancel(_state.scrap.task)
            end
        end)

        local logTab = window:CreateTab("RodHub木头自动收集")
        logTab:CreateToggle("木头收集", false, function(state)
            _state.log.enabled = state
            if state then
                local log = _initLog()
                log.updateCache()
                _state.log.task = task.spawn(log.collectProcess)
            elseif _state.log.task then
                task.cancel(_state.log.task)
            end
        end)
    end

    _initCombat()
    _createUI()

    return {
        scrap = _initScrap(),
        log = _initLog()
    }
end)()
