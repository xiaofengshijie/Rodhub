"本地 cloneref = (cloneref 或 clonereference 或函数 (实例：任何)
    返回实例
结尾）
本地 CoreGui：CoreGui = cloneref（游戏：GetService（“CoreGui”））
本地玩家：Players = cloneref（game：GetService（“Players”））
本地 RunService: RunService = cloneref(game:GetService("RunService"))
本地 SoundService：SoundService = cloneref（游戏：GetService（“SoundService”））
本地 UserInputService：UserInputService = cloneref（游戏：GetService（“UserInputService”））
本地文本服务：TextService = cloneref（游戏：GetService（“TextService”））
本地团队：Teams = cloneref(game:GetService("Teams"))
本地 TweenService：TweenService = cloneref（game：GetService（“TweenService”））

本地 getgenv = getgenv 或函数（）
    返回共享
结尾
本地 setclipboard = setclipboard 或 nil
本地 protectgui = protectgui 或 (syn 和 syn.protect_gui) 或函数 () 结束
本地 gethui = gethui 或函数（）
    返回 CoreGui
结尾

本地 LocalPlayer = Players.LocalPlayer 或 Players.PlayerAdded:Wait()
本地鼠标 = cloneref（LocalPlayer：GetMouse（））

本地标签 = {}
本地按钮 = {}
本地切换 = {}
本地选项 = {}

本地图书馆 = {
    本地播放器 = 本地播放器，
    设备平台 = 零，
    IsMobile = false，
    IsRobloxFocused = true，

    ScreenGui = 零，

    搜索文本 = "",
    搜索 = 错误，
    LastSearchTab = nil，

    ActiveTab = 零，
    制表符 = {}，
    依赖框 = {},

    键绑定框架 = 零，
    键绑定容器 = 零，
    键绑定切换 = {},

    通知 = {}，

    ToggleKeybind = Enum.KeyCode.RightControl，
    TweenInfo = TweenInfo.new(0.1，Enum.EasingStyle.Quad，Enum.EasingDirection.Out)，
    NotifyTweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),

    切换 = false，
    卸载 = false，

    标签 = 标签，
    按钮 = 按钮，
    切换 = 切换，
    选项 = 选项，

    NotifySide = "右",
    显示自定义光标 = true，
    ForceCheckbox = false，
    显示切换帧在键绑定中 = true，
    错误时通知 = false，

    CantDragForced = false，

    信号 = {},
    卸载信号 = {},

    最小尺寸 = Vector2.new(480, 360),
    DPIScale = 1，
    圆角半径 = 4，

    IsLightTheme = false，
    方案 = {
        背景颜色 = Color3.fromRGB(15, 15, 15),
        主色 = Color3.fromRGB(25, 25, 25),
        AccentColor = Color3.fromRGB(125, 85, 255),
        轮廓颜色 = Color3.fromRGB(40, 40, 40),
        字体颜色 = Color3.new(1, 1, 1),
        字体 = Font.fromEnum(Enum.Font.Code),

        红色 = Color3.fromRGB(255, 50, 50),
        深色 = Color3.new(0, 0, 0),
        白色 = Color3.new(1, 1, 1),
    }，

    注册表 = {}，
    DPI注册表 = {}，
}

本地 ObsidianImageManager = {
    资产 = {
        透明纹理 = {
            RobloxId = 139785960036434，
            路径 = “Obsidian/assets/TransparencyTexture.png”，

            id = 零
        }，
        
        饱和度图 = {
            RobloxId = 4155801252，
            路径 = “Obsidian/assets/SaturationMap.png”，

            id = 零
        }
    }
}
做
    本地 BaseURL =“https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/”

    本地函数 RecursiveCreatePath（Path：string，IsFile：boolean？）
        如果不是 isfolder 或不是 makefolder 则返回结束

        本地段 = 路径：拆分（“/”）
        本地遍历路径 =“”

        如果是IsFile那么
            表.删除（段，#段）
        结尾

        对于 _，ipairs 中的 Segment（Segments）执行
            如果不是 isfolder(TraversedPath .. Segment)，那么
                makefolder（遍历路径..段）
            结尾

            遍历路径 = 遍历路径.. 段..“/”
        结尾

        返回 TraversedPath
    结尾

    函数 ObsidianImageManager.GetAsset（AssetName：字符串）
        如果不是 ObsidianImageManager.Assets[AssetName] 那么
            返回 nil
        结尾

        本地 AssetData = ObsidianImageManager.Assets[AssetName]
        如果 AssetData.Id 那么
            返回 AssetData.Id
        结尾

        本地 AssetID = string.format("rbxassetid://%s", AssetData.RobloxId)

        如果获取自定义资产则
            本地成功，NewID = pcall（getcustomasset，AssetData.Path）

            如果成功并且有 NewID，那么
                AssetID = NewID
            结尾
        结尾

        AssetData.Id = 资产ID
        返回 AssetID
    结尾

    函数 ObsidianImageManager.DownloadAsset（AssetPath：字符串）
        如果没有 getcustomasset 或没有 writefile 或没有 isfile 那么
            返回
        结尾

        RecursiveCreatePath（AssetPath，true）

        如果是文件（AssetPath）那么
            返回
        结尾

        本地 URLPath = AssetPath:gsub("Obsidian/", "")
        写入文件（AssetPath，游戏：HttpGet（BaseURL .. URLPath））
    结尾

    对于 _，ObsidianImageManager.Assets 中的数据
        ObsidianImageManager.下载资源（数据路径）
    结尾
结尾

如果 RunService:IsStudio() 那么
    如果是 UserInputService.TouchEnabled 而不是 UserInputService.MouseEnabled，则
        图书馆.IsMobile = true
        Library.MinSize = Vector2.new(480, 240)
    别的
        图书馆.IsMobile = false
        Library.MinSize = Vector2.new(480, 360)
    结尾
别的
    pcall（函数（）
        Library.DevicePlatform = UserInputService:GetPlatform()
    结尾）
    Library.IsMobile = (Library.DevicePlatform == Enum.Platform.Android 或 Library.DevicePlatform == Enum.Platform.IOS)
    Library.MinSize = Library.IsMobile 和 Vector2.new(480, 240) 或 Vector2.new(480, 360)
结尾

本地模板 = {
    --// 用户界面 \\-
    框架 = {
        边框尺寸像素 = 0，
    }，
    图像标签 = {
        背景透明度 = 1，
        边框尺寸像素 = 0，
    }，
    图像按钮 = {
        自动按钮颜色 = false，
        边框尺寸像素 = 0，
    }，
    滚动框架 = {
        边框尺寸像素 = 0，
    }，
    文本标签 = {
        边框尺寸像素 = 0，
        FontFace = "字体",
        RichText = true，
        TextColor3 = "字体颜色",
    }，
    文本按钮 = {
        自动按钮颜色 = false，
        边框尺寸像素 = 0，
        FontFace = "字体",
        RichText = true，
        TextColor3 = "字体颜色",
    }，
    文本框 = {
        边框尺寸像素 = 0，
        FontFace = "字体",
        PlaceholderColor3 = 函数（）
            本地 H、S、V = Library.Scheme.FontColor:ToHSV()
            返回 Color3.fromHSV(H, S, V / 2)
        结尾，
        文本 = "",
        TextColor3 = "字体颜色",
    }，
    UIListLayout = {
        排序顺序 = 枚举.排序顺序.布局顺序，
    }，
    UIStroke = {
        ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
    }，

    - // 图书馆 \\ - 
    窗口 = {
        Title = “无标题”，
        页脚 = “无页脚”，
        位置 = UDim2.fromOffset(6, 6),
        尺寸 = UDim2.fromOffset(720, 600),
        图标大小 = UDim2.fromOffset(30, 30),
        自动显示 = true，
        中心 = 真，
        可调整大小 = true，
        SearchbarSize = UDim2.fromScale(1, 1),
        圆角半径 = 4，
        NotifySide = "右",
        显示自定义光标 = true，
        字体 = Enum.Font.Code,
        ToggleKeybind = Enum.KeyCode.RightControl，
        MobileButtonsSide = "左",
        UnlockMouseWhileOpen = true
    }，
    切换 = {
        文本 = “切换”，
        默认值 = false，

        回调 = 函数（）结束，
        改变 = 函数（）结束，

        有风险 = 错误，
        已禁用 = 假，
        可见 = 真，
    }，
    输入 = {
        文本 = “输入”，
        默认值 = "",
        完成 = 错误，
        数字 = 假，
        ClearTextOnFocus = true，
        占位符 = "",
        允许空 = true，
        EmptyReset = "---",

        回调 = 函数（）结束，
        改变 = 函数（）结束，

        已禁用 = 假，
        可见 = 真，
    }，
    滑块 = {
        文本 = “滑块”，
        默认值 = 0，
        最小值 = 0，
        最大值 = 100，
        舍入 = 0，

        前缀 = "",
        后缀 =“”，

        回调 = 函数（）结束，
        改变 = 函数（）结束，

        已禁用 = 假，
        可见 = 真，
    }，
    下拉菜单 = {
        值 = {},
        禁用值 = {}，
        多=假，
        MaxVisibleDropdownItems = 8，

        回调 = 函数（）结束，
        改变 = 函数（）结束，

        已禁用 = 假，
        可见 = 真，
    }，
    视口 = {
        对象 = 零，
        相机 = 无，
        克隆 = true，
        自动对焦 = true，
        交互 = false，
        高度 = 200，
        可见 = 真，
    }，
    图像 = {
        图像 = "",
        透明度 = 0，
        颜色 = Color3.new(1, 1, 1),
        RectOffset = Vector2.zero，
        RectSize = Vector2.zero，
        比例类型 = Enum.比例类型.Fit,
        高度 = 200，
        可见 = 真，
    }，

    --// 插件 \\-
    按键选择器 = {
        文本 = “KeyPicker”，
        默认值 = “无”，
        默认修饰符 = {},
        模式 = “切换”，
        模式 = {“始终”、“切换”、“保持”}，
        SyncToggleState = false，

        回调 = 函数（）结束，
        ChangedCallback = 函数（）结束，
        改变 = 函数（）结束，
        点击=函数（）结束，
    }，
    颜色选择器 = {
        默认值 = Color3.new(1, 1, 1),

        回调 = 函数（）结束，
        改变 = 函数（）结束，
    }，
}

当地地点 = {
    底部 = { 0, 1 },
    右 = { 1, 0 },
}
本地尺寸 = {
    左 = { 0.5, 1 },
    右 = { 0.5, 1 },
}

--// 基本功能 \\--
本地函数ApplyDPIScale（Dimension，ExtraOffset）
    如果 typeof(Dimension) == "UDim" 那么
        返回 UDim.new(Dimension.Scale, Dimension.Offset * Library.DPIScale)
    结尾

    如果 ExtraOffset 那么
        返回 UDim2.new(
            尺寸.X.比例，
            （Dimension.X.Offset * Library.DPIScale）+（ExtraOffset[1] * Library.DPIScale），
            尺寸.Y.比例，
            （Dimension.Y.Offset * Library.DPIScale）+（ExtraOffset[2] * Library.DPIScale）
        ）
    结尾

    返回 UDim2.new(
        尺寸.X.比例，
        尺寸.X.偏移量 * 库.DPIScale，
        尺寸.Y.比例，
        尺寸.Y.偏移 * 库.DPI比例
    ）
结尾
局部函数ApplyTextScale(TextSize)
    返回 TextSize * Library.DPIScale
结尾

本地函数 WaitForEvent(Event, Timeout, Condition)
    本地可绑定 = 实例.new(“可绑定事件”)
    本地连接 = 事件：一次（函数（...）
        如果不是 Condition 或 typeof(Condition) == "function" 并且 Condition(...) 那么
            可绑定：Fire（真）
        别的
            可绑定：Fire（false）
        结尾
    结尾）
    任务.延迟（超时，函数（）
        连接：断开（）
        可绑定：Fire（false）
    结尾）

    本地结果 = Bindable.Event:Wait()
    可绑定：销毁（）

    返回结果
结尾

本地函数 IsMouseInput(Input: InputObject, IncludeM2: boolean?)
    返回Input.UserInputType == Enum.UserInputType.MouseButton1
        或（IncludeM2 == true 且 Input.UserInputType == Enum.UserInputType.MouseButton2）
        或 Input.UserInputType == Enum.UserInputType.Touch
结尾
本地函数 IsClickInput(Input: InputObject, IncludeM2: boolean?)
    返回 IsMouseInput(Input, IncludeM2)
        并且 Input.UserInputState == Enum.UserInputState.Begin
        和 Library.IsRobloxFocused
结尾
本地函数 IsHoverInput(Input: InputObject)
    返回（Input.UserInputType == Enum.UserInputType.MouseMovement 或 Input.UserInputType == Enum.UserInputType.Touch）
        并且 Input.UserInputState == Enum.UserInputState.Change
结尾
本地函数 IsDragInput(Input: InputObject, IncludeM2: boolean?)
    返回 IsMouseInput(Input, IncludeM2)
        和（Input.UserInputState == Enum.UserInputState.Begin 或 Input.UserInputState == Enum.UserInputState.Change）
        和 Library.IsRobloxFocused
结尾

本地函数 GetTableSize(Table: { [any]: any })
    本地大小 = 0

    对于 _，_ 成对（表）执行
        大小 += 1
    结尾

    返回大小
结尾
本地函数 StopTween(Tween: TweenBase)
    如果不是（Tween 和 Tween.PlaybackState == Enum.PlaybackState.Playing）那么
        返回
    结尾

    补间：取消()
结尾
本地函数 Trim(Text: string)
    返回文本：匹配（“^％s *（.-）％s * $”）
结尾
局部函数 Round(Value, Rounding)
    断言（Rounding >= 0，“无效的舍入数字。”）

    如果 Rounding == 0，则
        返回数学.floor（值）
    结尾

    返回数字（string.format（“％.”..四舍五入..“f”，值））
结尾

本地函数 GetPlayers(ExcludeLocalPlayer: boolean?)
    本地玩家列表 = 玩家：获取玩家（）

    如果排除本地玩家则
        本地 Idx = 表.find(PlayerList，LocalPlayer)
        如果 Idx 那么
            表.删除（PlayerList，Idx）
        结尾
    结尾

    表.sort（PlayerList，函数（Player1，Player2）
        返回 Player1.Name:lower() < Player2.Name:lower()
    结尾）

    返回 PlayerList
结尾
本地函数 GetTeams()
    本地 TeamList = Teams:GetTeams()

    表.sort（TeamList，函数（Team1，Team2）
        返回 Team1.Name:lower() < Team2.Name:lower()
    结尾）

    返回 TeamList
结尾

函数库：UpdateKeybindFrame()
    如果不是 Library.KeybindFrame 则
        返回
    结尾

    本地 XSize = 0
    对于 _，KeybindToggle 成对（Library.KeybindToggles）执行
        如果不是 KeybindToggle.Holder.Visible，那么
            继续
        结尾

        本地全尺寸 = KeybindToggle.Label.Size.X.Offset + KeybindToggle.Label.Position.X.Offset
        如果 FullSize > XSize 那么
            XSize = 全尺寸
        结尾
    结尾

    Library.KeybindFrame.Size = UDim2.fromOffset(XSize + 18 * Library.DPIScale, 0)
结尾
函数库：UpdateDependencyBoxes()
    对于 _，Depbox 成对（Library.DependencyBoxes）执行
        Depbox：更新（真）
    结尾

    如果 Library.Searching 那么
        图书馆：更新搜索（图书馆.搜索文本）
    结尾
结尾

本地函数 CheckDepbox(Box, Search)
    本地可见元素 = 0

    对于 _，ElementInfo 成对（Box.Elements）执行
        如果 ElementInfo.Type ==“Divider”那么
            ElementInfo.Holder.Visible = false
            继续
        elseif ElementInfo.SubButton then
            --// 检查是否有任何按钮名称与搜索匹配
            本地可见 = false

            --// 检查搜索是否与元素的名称匹配以及元素是否可见
            如果 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                可见 = 真
            别的
                ElementInfo.Base.Visible = false
            结尾
            如果 ElementInfo.SubButton.Text:lower():match(Search) 并且 ElementInfo.SubButton.Visible 那么
                可见 = 真
            别的
                ElementInfo.SubButton.Base.Visible = false
            结尾
            ElementInfo.Holder.Visible = 可见
            如果可见则
                可见元素 += 1
            结尾

            继续
        结尾

        --// 检查搜索是否与元素的名称匹配以及元素是否可见
        如果 ElementInfo.Text 和 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
            ElementInfo.Holder.Visible = true
            可见元素 += 1
        别的
            ElementInfo.Holder.Visible = false
        结尾
    结尾

    对于 _，Depbox 成对（Box.DependencyBoxes）执行
        如果不是 Depbox.Visible，那么
            继续
        结尾

        VisibleElements += CheckDepbox(Depbox，搜索)
    结尾

    返回可见元素
结尾
本地函数 RestoreDepbox(Box)
    对于 _，ElementInfo 成对（Box.Elements）执行
        ElementInfo.Holder.Visible = typeof(ElementInfo.Visible) == "boolean" 且 ElementInfo.Visible 或 true

        如果 ElementInfo.SubButton 那么
            ElementInfo.Base.Visible = ElementInfo.Visible
            ElementInfo.SubButton.Base.Visible = ElementInfo.SubButton.Visible
        结尾
    结尾

    框：调整大小（）
    Box.Holder.Visible = true

    对于 _，Depbox 成对（Box.DependencyBoxes）执行
        如果不是 Depbox.Visible，那么
            继续
        结尾

        恢复 Depbox（Depbox）
    结尾
结尾

函数库：UpdateSearch（SearchText）
    图书馆.搜索文本 = 搜索文本

    --// 重置上次搜索的选项卡中的元素可见性
    如果 Library.LastSearchTab 那么
        对于 _，成对的 Groupbox(Library.LastSearchTab.Groupboxes) 执行
            对于 _，ElementInfo 成对（Groupbox.Elements）执行
                ElementInfo.Holder.Visible = typeof(ElementInfo.Visible) == "boolean" 且 ElementInfo.Visible 或 true

                如果 ElementInfo.SubButton 那么
                    ElementInfo.Base.Visible = ElementInfo.Visible
                    ElementInfo.SubButton.Base.Visible = ElementInfo.SubButton.Visible
                结尾
            结尾

            对于 _，Depbox 成对（Groupbox.DependencyBoxes）执行
                如果不是 Depbox.Visible，那么
                    继续
                结尾

                恢复 Depbox（Depbox）
            结尾

            组框：调整大小（）
            Groupbox.Holder.Visible = true
        结尾

        对于 _，Tabbox 成对（Library.LastSearchTab.Tabboxes）执行
            对于 _，Tab 成对（Tabbox.Tabs）执行
                对于 _，ElementInfo 成对（Tab.Elements）执行
                    ElementInfo.Holder.Visible = typeof(ElementInfo.Visible) == "boolean" 和 ElementInfo.Visible
                        或 true

                    如果 ElementInfo.SubButton 那么
                        ElementInfo.Base.Visible = ElementInfo.Visible
                        ElementInfo.SubButton.Base.Visible = ElementInfo.SubButton.Visible
                    结尾
                结尾

                对于 _，Depbox 成对（Tab.DependencyBoxes）执行
                    如果不是 Depbox.Visible，那么
                        继续
                    结尾

                    恢复 Depbox（Depbox）
                结尾

                Tab.ButtonHolder.Visible = true
            结尾

            Tabbox.ActiveTab:调整大小()
            Tabbox.Holder.Visible = true
        结尾

        对于 _，DepGroupbox 成对（Library.LastSearchTab.DependencyGroupboxes）执行
            如果不是 DepGroupbox.Visible，那么
                继续
            结尾

            对于 _，ElementInfo 成对（DepGroupbox.Elements）执行
                ElementInfo.Holder.Visible = typeof(ElementInfo.Visible) == "boolean" 且 ElementInfo.Visible 或 true

                如果 ElementInfo.SubButton 那么
                    ElementInfo.Base.Visible = ElementInfo.Visible
                    ElementInfo.SubButton.Base.Visible = ElementInfo.SubButton.Visible
                结尾
            结尾

            对于 _，Depbox 成对（DepGroupbox.DependencyBoxes）执行
                如果不是 Depbox.Visible，那么
                    继续
                结尾

                恢复 Depbox（Depbox）
            结尾

            DepGroupbox:调整大小()
            DepGroupbox.Holder.Visible = true
        结尾
    结尾

    --// 如果搜索文本为空则取消搜索
    本地搜索 = SearchText:lower()
    如果 Trim(Search) == "" 或 Library.ActiveTab.IsKeyTab 那么
        图书馆.搜索=false
        图书馆.LastSearchTab = nil
        返回
    结尾

    图书馆.搜索 = true

    --// 循环遍历 Groupboxes 来获取元素信息
    对于 _，成对的 Groupbox(Library.ActiveTab.Groupboxes) 执行
        本地可见元素 = 0

        对于 _，ElementInfo 成对（Groupbox.Elements）执行
            如果 ElementInfo.Type ==“Divider”那么
                ElementInfo.Holder.Visible = false
                继续
            elseif ElementInfo.SubButton then
                --// 检查是否有任何按钮名称与搜索匹配
                本地可见 = false

                --// 检查搜索是否与元素的名称匹配以及元素是否可见
                如果 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                    可见 = 真
                别的
                    ElementInfo.Base.Visible = false
                结尾
                如果 ElementInfo.SubButton.Text:lower():match(Search) 并且 ElementInfo.SubButton.Visible 那么
                    可见 = 真
                别的
                    ElementInfo.SubButton.Base.Visible = false
                结尾
                ElementInfo.Holder.Visible = 可见
                如果可见则
                    可见元素 += 1
                结尾

                继续
            结尾

            --// 检查搜索是否与元素的名称匹配以及元素是否可见
            如果 ElementInfo.Text 和 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                ElementInfo.Holder.Visible = true
                可见元素 += 1
            别的
                ElementInfo.Holder.Visible = false
            结尾
        结尾

        对于 _，Depbox 成对（Groupbox.DependencyBoxes）执行
            如果不是 Depbox.Visible，那么
                继续
            结尾

            VisibleElements += CheckDepbox(Depbox，搜索)
        结尾

        --// 如果发现任何元素，则更新 Groupbox 大小和可见性
        如果 VisibleElements > 0，则
            组框：调整大小（）
        结尾
        Groupbox.Holder.Visible = VisibleElements > 0
    结尾

    对于_，成对的Tabbox（Library.ActiveTab.Tabboxes）执行
        本地 VisibleTabs = 0
        本地可见元素 = {}

        对于 _，Tab 成对（Tabbox.Tabs）执行
            可见元素[标签] = 0

            对于 _，ElementInfo 成对（Tab.Elements）执行
                如果 ElementInfo.Type ==“Divider”那么
                    ElementInfo.Holder.Visible = false
                    继续
                elseif ElementInfo.SubButton then
                    --// 检查是否有任何按钮名称与搜索匹配
                    本地可见 = false

                    --// 检查搜索是否与元素的名称匹配以及元素是否可见
                    如果 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                        可见 = 真
                    别的
                        ElementInfo.Base.Visible = false
                    结尾
                    如果 ElementInfo.SubButton.Text:lower():match(Search) 并且 ElementInfo.SubButton.Visible 那么
                        可见 = 真
                    别的
                        ElementInfo.SubButton.Base.Visible = false
                    结尾
                    ElementInfo.Holder.Visible = 可见
                    如果可见则
                        可见元素[Tab] += 1
                    结尾

                    继续
                结尾

                --// 检查搜索是否与元素的名称匹配以及元素是否可见
                如果 ElementInfo.Text 和 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                    ElementInfo.Holder.Visible = true
                    可见元素[Tab] += 1
                别的
                    ElementInfo.Holder.Visible = false
                结尾
            结尾

            对于 _，Depbox 成对（Tab.DependencyBoxes）执行
                如果不是 Depbox.Visible，那么
                    继续
                结尾

                VisibleElements[Tab] += CheckDepbox(Depbox，搜索)
            结尾
        结尾

        对于 Tab，Visible 成对（VisibleElements）执行
            Tab.ButtonHolder.Visible = 可见 > 0
            如果 Visible > 0，则
                可见标签 += 1

                如果 Tabbox.ActiveTab == Tab 那么
                    标签：调整大小()
                elseif VisibleElements[Tabbox.ActiveTab] == 0 然后
                    Tab:显示()
                结尾
            结尾
        结尾

        --// 更新 Tabbox 可见性（如果有）
        Tabbox.Holder.Visible = VisibleTabs > 0
    结尾

    对于 _，DepGroupbox 成对（Library.ActiveTab.DependencyGroupboxes）执行
        如果不是 DepGroupbox.Visible，那么
            继续
        结尾

        本地可见元素 = 0

        对于 _，ElementInfo 成对（DepGroupbox.Elements）执行
            如果 ElementInfo.Type ==“Divider”那么
                ElementInfo.Holder.Visible = false
                继续
            elseif ElementInfo.SubButton then
                --// 检查是否有任何按钮名称与搜索匹配
                本地可见 = false

                --// 检查搜索是否与元素的名称匹配以及元素是否可见
                如果 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                    可见 = 真
                别的
                    ElementInfo.Base.Visible = false
                结尾
                如果 ElementInfo.SubButton.Text:lower():match(Search) 并且 ElementInfo.SubButton.Visible 那么
                    可见 = 真
                别的
                    ElementInfo.SubButton.Base.Visible = false
                结尾
                ElementInfo.Holder.Visible = 可见
                如果可见则
                    可见元素 += 1
                结尾

                继续
            结尾

            --// 检查搜索是否与元素的名称匹配以及元素是否可见
            如果 ElementInfo.Text 和 ElementInfo.Text:lower():match(Search) 和 ElementInfo.Visible 那么
                ElementInfo.Holder.Visible = true
                可见元素 += 1
            别的
                ElementInfo.Holder.Visible = false
            结尾
        结尾

        对于 _，Depbox 成对（DepGroupbox.DependencyBoxes）执行
            如果不是 Depbox.Visible，那么
                继续
            结尾

            VisibleElements += CheckDepbox(Depbox，搜索)
        结尾

        --// 如果发现任何元素，则更新 Groupbox 大小和可见性
        如果 VisibleElements > 0，则
            DepGroupbox:调整大小()
        结尾
        DepGroupbox.Holder.Visible = VisibleElements > 0
    结尾

    --// 将最后一个标签页设置为当前标签页
    图书馆.LastSearchTab = 图书馆.ActiveTab
结尾

函数库：AddToRegistry（实例，属性）
    库.注册表[实例] = 属性
结尾

函数库：RemoveFromRegistry（实例）
    库.注册表[实例] = nil
结尾

函数库：UpdateColorsUsingRegistry()
    例如，成对的属性（Library.Registry）
        对于 Property，ColorIdx 成对（属性）执行
            如果 typeof(ColorIdx) == "string" 那么
                实例[属性] = 库.方案[ColorIdx]
            elseif typeof(ColorIdx) == "函数" then
                实例[属性] = ColorIdx()
            结尾
        结尾
    结尾
结尾

函数库：UpdateDPI（实例，属性）
    如果不是 Library.DPIRegistry[Instance] 那么
        返回
    结尾

    对于属性，值成对（属性）执行
        Library.DPIRegistry[Instance][Property] = Value 和 Value 或 nil
    结尾
结尾

函数库：SetDPIScale（DPIScale：数字）
    库.DPIScale = DPIScale / 100
    库.MinSize *= 库.DPIScale

    例如，成对的属性（Library.DPIRegistry）
        对于属性，值成对（属性）执行
            如果 Property == “DPIExclude” 或 Property == “DPIOffset” 则
                继续
            elseif 属性 == "TextSize" then
                实例[属性] = ApplyTextScale(值)
            别的
                实例[属性] = ApplyDPIScale(值，属性["DPIOffset"][属性])
            结尾
        结尾
    结尾

    对于 _，Tab 成对（Library.Tabs）执行
        如果 Tab.IsKeyTab 那么
            继续
        结尾

        标签：调整大小（真）
        对于_，成对的Groupbox（Tab.Groupboxes）做
            组框：调整大小（）
        结尾
        对于 _，Tabbox 成对（Tab.Tabboxes）执行
            对于 _，SubTab 成对（Tabbox.Tabs）执行
                子标签：调整大小()
            结尾
        结尾
    结尾

    对于 _，选项成对（选项）执行
        如果 Option.Type ==“下拉列表”则
            选项：RecalculateListSize()
        elseif Option.Type == "KeyPicker" then
            选项：更新（）
        结尾
    结尾

    库：UpdateKeybindFrame()
    对于 _，成对的通知（Library.Notifications）执行
        通知：调整大小（）
    结尾
结尾

函数库：GiveSignal（连接：RBXScriptConnection）
    表.插入（库.信号，连接）
    返回连接
结尾

函数 IsValidCustomIcon（图标：字符串）
    返回 typeof(Icon) == “string” 和 (Icon:match(“rbxasset”) 或 Icon:match(“roblox%.com/asset/%?id=") 或 Icon:match(“rbxthumb://type="))
结尾

本地 FetchIcons，图标 = pcall（函数（）
    返回加载字符串（
        游戏：HttpGet（“https://raw.githubusercontent.com/deividcomsono/lucide-roblox-direct/refs/heads/main/source.lua”）
    )()
结尾）
函数库：GetIcon（IconName：字符串）
    如果没有 FetchIcons，那么
        返回
    结尾
    本地成功，Icon = pcall（Icons.GetAsset，IconName）
    如果没有成功那么
        返回
    结尾
    返回图标
结尾

函数库：GetCustomIcon（IconName：字符串）
    如果不是 IsValidCustomIcon(IconName)，那么
        返回库：GetIcon（IconName）
    别的
        返回 {
            Url = 图标名称，
            图像矩形偏移 = Vector2.zero，
            图像矩形大小 = Vector2.zero，
            自定义 = true
        }
    结尾
结尾

函数库：Validate（表：{[string]：任意}，模板：{[string]：任意}）：{[string]：任意}
    如果 typeof(Table) ~= "table" 那么
        返回模板
    结尾

    对于成对的 k、v（模板）执行
        如果 typeof(k) == "number" 那么
            继续
        结尾

        如果 typeof(v) == "table" 那么
            表[k] = 库:验证(表[k]，v)
        elseif Table[k] == nil 则
            表[k] = v
        结尾
    结尾

    返回表
结尾

--// 创建者函数 \\--
本地函数 FillInstance（表：{[string]：任何}，实例：GuiObject）
    本地 ThemeProperties = Library.Registry[Instance] 或 {}
    本地 DPIProperties = Library.DPIRegistry[Instance] 或 {}

    本地 DPIExclude = DPIProperties["DPIExclude"] 或 Table["DPIExclude"] 或 {}
    本地 DPIOffset = DPIProperties["DPIOffset"] 或 Table["DPIOffset"] 或 {}

    对于成对的 k, v（表格）
        如果 k == “DPIExclude” 或 k == “DPIOffset” 那么
            继续
        elseif ThemeProperties[k] 然后
            主题属性[k] = nil
        elseif k ~= "Text" and (Library.Scheme[v] 或 typeof(v) == "function") then
            -- 当下拉菜单中的红色破坏东西时（临时修复 - 或者永久修复，我不知道 deivid 是否会对此采取措施）
            ThemeProperties[k] = v
            实例[k] = 库.方案[v] 或 v()
            继续
        结尾

        如果不是 DPIExclude[k] 那么
            如果 k == "Position" 或 k == "Size" 或 k:match("Padding") 那么
                DPI属性[k] = v
                v = ApplyDPIScale(v, DPIOffset[k])
            elseif k == "TextSize" 然后
                DPI属性[k] = v
                v = 应用文本比例（v）
            结尾
        结尾

        实例[k] = v
    结尾

    如果 GetTableSize(ThemeProperties) > 0，则
        库.注册表[实例] = ThemeProperties
    结尾
    如果 GetTableSize(DPIProperties) > 0，则
        DPIProperties["DPIExclude"] = DPIExclude
        DPIProperties["DPIOffset"] = DPIOffset
        Library.DPIRegistry[实例] = DPIProperties
    结尾
结尾

本地函数 New(ClassName: string, Properties: { [string]: any }): any
    本地实例 = 实例.new(类名)

    如果模板[类名]那么
        FillInstance(模板[类名]，实例)
    结尾
    FillInstance（属性，实例）

    如果 Properties["Parent"] 且不为 Properties["ZIndex"]，则
        pcall（函数（）
            实例.ZIndex = 属性.父级.ZIndex
        结尾）
    结尾

    返回实例
结尾

--// 主要实例 \\-
本地函数 SafeParentUI(实例：实例，父级：实例 | () -> 实例)
    本地成功，_error = pcall（function（）
        如果不是父母，那么
            父级 = CoreGui
        结尾

        本地目标父级
        如果 typeof(Parent) == "function" 那么
            目标父级 = 父级()
        别的
            DestinationParent = Parent
        结尾

        实例.父级 = 目标父级
    结尾）

    如果不是（成功并且 Instance.Parent）那么
        Instance.Parent = Library.LocalPlayer:WaitForChild("PlayerGui", math.huge)
    结尾
结尾

本地函数 ParentUI（UI：实例，SkipHiddenUI：布尔值？）
    如果 SkipHiddenUI 那么
        SafeParentUI（UI，CoreGui）
        返回
    结尾

    pcall（protectgui，UI）
    SafeParentUI（UI，gethui）
结尾

本地 ScreenGui = New("ScreenGui", {
    名称 = “黑曜石”，
    显示顺序 = 999，
    ResetOnSpawn = false，
})
父级UI（ScreenGui）
库.ScreenGui = ScreenGui
ScreenGui.DescendantRemoving:Connect(函数(实例)
    库：从注册表中删除（实例）
    库.DPIRegistry[实例] = nil
结尾）

本地 ModalElement = New("文本按钮", {
    背景透明度 = 1，
    模态=假，
    尺寸 = UDim2.fromScale(0, 0),
    锚点 = Vector2.zero，
    文本 = "",
    ZIndex = -999，
    父级 = ScreenGui
})

- // 光标
本地游标
做
    光标 = 新建（“框架”，{
        锚点 = Vector2.new(0.5, 0.5),
        背景颜色3 = "白色",
        大小 = UDim2.fromOffset(9, 1),
        可见=假，
        ZIndex = 999，
        父级 = ScreenGui，
    })
    新的（“框架”，{
        锚点 = Vector2.new(0.5, 0.5),
        背景颜色3 = "深色",
        位置 = UDim2.fromScale(0.5, 0.5),
        尺寸 = UDim2.new(1, 2, 1, 2),
        ZIndex = 998，
        父级 = 光标，
    })

    本地 CursorV = New("框架", {
        锚点 = Vector2.new(0.5, 0.5),
        背景颜色3 = "白色",
        位置 = UDim2.fromScale(0.5, 0.5),
        大小 = UDim2.fromOffset(1, 9),
        父级 = 光标，
    })
    新的（“框架”，{
        锚点 = Vector2.new(0.5, 0.5),
        背景颜色3 = "深色",
        位置 = UDim2.fromScale(0.5, 0.5),
        尺寸 = UDim2.new(1, 2, 1, 2),
        ZIndex = 998，
        父级 = CursorV，
    })
结尾

- // 通知
本地通知区域
本地通知列表
做
    NotificationArea = New("框架", {
        锚点 = Vector2.new(1, 0),
        背景透明度 = 1，
        位置 = UDim2.new(1, -6, 0, 6),
        尺寸 = UDim2.new(0, 300, 1, -6),
        父级 = ScreenGui，
    })
    通知列表 = 新建（“UIListLayout”，{
        水平对齐 = 枚举.水平对齐.右，
        填充 = UDim.new(0, 6),
        父级 = 通知区域，
    })
结尾

--// 库函数 \\--
函数库：GetBetterColor（颜色：Color3，添加：数字）：Color3
    添加 = 添加 * (Library.IsLightTheme 和 -4 或 2)
    返回 Color3.fromRGB(
        数学.clamp(Color.R * 255 + Add, 0, 255),
        数学.clamp(Color.G * 255 + Add, 0, 255),
        math.clamp（颜色.B * 255 + 添加，0，255）
    ）
结尾

函数库：GetDarkerColor（颜色：Color3）：Color3
    局部 H、S、V = 颜色：ToHSV()
    返回 Color3.fromHSV(H, S, V / 2)
结尾

函数库：GetKeyString（KeyCode：Enum.KeyCode）
    如果 KeyCode.EnumType == Enum.KeyCode 且 KeyCode.Value > 33 且 KeyCode.Value < 127 则
        返回字符串.char(KeyCode.Value)
    结尾

    返回 KeyCode.Name
结尾

函数库：GetTextBounds（文本：字符串，字体：字体，大小：数字，宽度：数字？）：（数字，数字）
    本地 Params = Instance.new("GetTextBoundsParams")
    参数.文本 = 文本
    Params.RichText = true
    Params.Font = 字体
    Params.Size = 尺寸
    Params.Width = 宽度或工作区.CurrentCamera.ViewportSize.X - 32

    本地边界 = TextService:GetTextBoundsAsync(Params)
    返回 Bounds.X、Bounds.Y
结尾

函数库：MouseIsOverFrame（Frame：GuiObject，Mouse：Vector2）：布尔值
    本地 AbsPos，AbsSize = Frame.AbsolutePosition，Frame.AbsoluteSize
    返回 Mouse.X >= AbsPos.X
        并且 Mouse.X <= AbsPos.X + AbsSize.X
        并且 Mouse.Y >= AbsPos.Y
        并且鼠标.Y <= AbsPos.Y + AbsSize.Y
结尾

函数库：SafeCallback（Func：（...any）-> ...any，...：any）
    如果不是（Func 和 typeof(Func) == "function"）那么
        返回
    结尾

    本地结果 = 表.pack(xpcall(Func，函数(错误)
        任务.defer（错误，调试.traceback（错误，2））
        如果 Library.NotifyOnError 那么
            库：通知（错误）
        结尾

        返回错误
    结尾， ...））

    如果不是 Result[1] 那么
        返回 nil
    结尾

    返回表.unpack（结果，2，结果.n）
结尾

函数库：MakeDraggable（UI：GuiObject，DragFrame：GuiObject，IgnoreToggled：boolean？，IsMainWindow：boolean？）
    本地起始位置
    本地帧位置
    本地拖动 = false
    本地已更改
    DragFrame.InputBegan:Connect(函数(输入：InputObject)
        如果不是 IsClickInput(Input) 或 IsMainWindow 且 Library.CantDragForced 则
            返回
        结尾

        StartPos = 输入.位置
        FramePos = UI.位置
        拖动 = true

        已更改 = 输入.更改：连接（函数（）
            如果 Input.UserInputState ~= Enum.UserInputState.End 那么
                返回
            结尾

            拖动 = false
            如果 Changed 并且 Changed.Connected 则
                改变：断开连接（）
                已更改 = 零
            结尾
        结尾）
    结尾）
    库：GiveSignal（UserInputService.InputChanged：Connect（函数（输入：InputObject）
        如果
            （不是 IgnoreToggled 也不是 Library.Toggled）
            或（IsMainWindow 和 Library.CantDragForced）
            或不 (ScreenGui 和 ScreenGui.Parent)
        然后
            拖动 = false
            如果 Changed 并且 Changed.Connected 则
                改变：断开连接（）
                已更改 = 零
            结尾

            返回
        结尾

        如果拖动并且 IsHoverInput(Input) 那么
            本地 Delta = 输入位置 - 起始位置
            UI.位置 =
                UDim2.new(FramePos.X.Scale，FramePos.X.Offset + Delta.X，FramePos.Y.Scale，FramePos.Y.Offset + Delta.Y)
        结尾
    结尾））
结尾

函数库：MakeResizable（UI：GuiObject，DragFrame：GuiObject，回调：（）->（）？）
    本地起始位置
    本地帧大小
    本地拖动 = false
    本地已更改
    DragFrame.InputBegan:Connect(函数(输入：InputObject)
        如果不是 IsClickInput(Input)，那么
            返回
        结尾

        StartPos = 输入.位置
        框架尺寸 = UI.尺寸
        拖动 = true

        已更改 = 输入.更改：连接（函数（）
            如果 Input.UserInputState ~= Enum.UserInputState.End 那么
                返回
            结尾

            拖动 = false
            如果 Changed 并且 Changed.Connected 则
                改变：断开连接（）
                已更改 = 零
            结尾
        结尾）
    结尾）
    库：GiveSignal（UserInputService.InputChanged：Connect（函数（输入：InputObject）
        如果不是 UI.Visible 或不是（ScreenGui 和 ScreenGui.Parent）那么
            拖动 = false
            如果 Changed 并且 Changed.Connected 则
                改变：断开连接（）
                已更改 = 零
            结尾

            返回
        结尾

        如果拖动并且 IsHoverInput(Input) 那么
            本地 Delta = 输入位置 - 起始位置
            UI.尺寸 = UDim2.新（
                帧大小.X.比例，
                math.clamp(FrameSize.X.Offset + Delta.X, Library.MinSize.X, math.huge),
                帧大小.Y.比例，
                math.clamp（FrameSize.Y.Offset + Delta.Y，Library.MinSize.Y，math.huge）
            ）
            如果回调则
                库：SafeCallback（回调）
            结尾
        结尾
    结尾））
结尾

函数库：MakeCover（持有者：GuiObject，位置：字符串）
    本地 Pos = Places[Place] 或 { 0, 0 }
    本地尺寸 = 尺寸[地点] 或 { 1, 0.5 }

    本地封面 = 新的（“框架”，{
        锚点 = Vector2.new(Pos[1], Pos[2]),
        背景颜色3 = Holder.背景颜色3，
        位置 = UDim2.fromScale(Pos[1], Pos[2]),
        尺寸 = UDim2.fromScale(尺寸[1], 尺寸[2]),
        父母=持有人，
    })

    返回封面
结尾

函数库：MakeLine（框架：GuiObject，信息）
    本地线 = 新建（“框架”，{
        AnchorPoint = Info.AnchorPoint 或 Vector2.zero，
        BackgroundColor3 = "轮廓颜色",
        位置 = 信息位置，
        大小 = 信息大小，
        父级 = 框架，
    })

    返回线路
结尾

函数库：MakeOutline（框架：GuiObject，角：数字？，ZIndex：数字？）
    本地 Holder = New("Frame", {
        背景颜色3 = "深色",
        位置 = UDim2.fromOffset(-2, -2),
        尺寸 = UDim2.new(1, 4, 1, 4),
        ZIndex = ZIndex，
        父级 = 框架，
    })

    本地大纲 = 新建（“框架”，{
        BackgroundColor3 = "轮廓颜色",
        位置 = UDim2.fromOffset(1, 1),
        尺寸 = UDim2.new(1, -2, 1, -2),
        ZIndex = ZIndex，
        父母=持有人，
    })

    如果 Corner 和 Corner > 0，则
        新的（“UICorner”，{
            角半径 = UDim.new(0, 角 + 1),
            父母=持有人，
        })
        新的（“UICorner”，{
            角半径 = UDim.new(0, 角),
            父级 = 大纲，
        })
    结尾

    返回持有人
结尾

函数库：AddDraggableButton（文本：字符串，Func）
    本地表 = {}

    本地按钮 = 新建（“文本按钮”，{
        BackgroundColor3 = "背景颜色",
        位置 = UDim2.fromOffset(6, 6),
        文本大小 = 16，
        ZIndex = 10，
        父级 = ScreenGui，

        DPIExclude = {
            位置 = 真，
        }，
    })
    新的（“UICorner”，{
        角半径 = UDim.new(0, 库.角半径 - 1),
        父级 = 按钮，
    })
    库：MakeOutline（按钮，库.CornerRadius，9）

    表格.按钮 = 按钮
    Button.MouseButton1Click:连接（函数（）
        库：SafeCallback（Func，Table）
    结尾）
    库：MakeDraggable（按钮，按钮，true）

    函数表：SetText（NewText：字符串）
        本地 X，Y = 库：GetTextBounds（NewText，Library.Scheme.Font，16）

        按钮.文本 = 新文本
        按钮.大小 = UDim2.fromOffset(X * 库.DPIScale * 2，Y * 库.DPIScale * 2)
        库：UpdateDPI（按钮，{
            尺寸 = UDim2.fromOffset(X * 2, Y * 2),
        })
    结尾
    表：设置文本（文本）

    返回表
结尾

函数库：AddDraggableMenu（名称：字符串）
    本地背景 = 库：MakeOutline（ScreenGui，Library.CornerRadius，10）
    Background.AutomaticSize = Enum.AutomaticSize.Y
    背景.位置 = UDim2.fromOffset(6, 6)
    背景.大小 = UDim2.fromOffset(0, 0)
    库：UpdateDPI（背景，{
        位置 = 假，
        尺寸=假，
    })

    本地 Holder = New("Frame", {
        BackgroundColor3 = "背景颜色",
        位置 = UDim2.fromOffset(2, 2),
        尺寸 = UDim2.new(1, -4, 1, -4),
        父级 = 背景，
    })
    新的（“UICorner”，{
        角半径 = UDim.new(0, 库.角半径 - 1),
        父母=持有人，
    })
    库：MakeLine（持有人，{
        位置 = UDim2.fromOffset(0, 34),
        尺寸 = UDim2.new(1, 0, 0, 1),
    })

    本地标签 = 新建（“文本标签”，{
        背景透明度 = 1，
        尺寸 = UDim2.new(1, 0, 0, 34),
        文本 = 姓名，
        文本大小 = 15，
        文本X对齐 = 枚举.文本X对齐.左，
        父母=持有人，
    })
    新的（“UIPadding”，{
        PaddingLeft = UDim.new(0, 12),
        PaddingRight = UDim.new(0, 12),
        父级 = 标签，
    })

    本地容器 = 新建（“框架”，{
        背景透明度 = 1，
        位置 = UDim2.fromOffset(0, 35),
        尺寸 = UDim2.new(1, 0, 1, -35),
        父母=持有人，
    })
    新的（“UIListLayout”，{
        填充 = UDim.new(0, 7),
        父级 = 容器，
    })
    新的（“UIPadding”，{
        PaddingBottom = UDim.new(0, 7),
        PaddingLeft = UDim.new(0, 7),
        PaddingRight = UDim.new(0, 7),
        PaddingTop = UDim.new(0, 7),
        父级 = 容器，
    })

    库：MakeDraggable（背景，标签，true）
    返回背景，容器
结尾

--// 水印 \\--
做
    本地 WatermarkBackground = Library:MakeOutline(ScreenGui, Library.CornerRadius, 10)
    WatermarkBackground.AutomaticSize = Enum.AutomaticSize.Y
    WatermarkBackground.Position = UDim2.fromOffset(6, 6)
    WatermarkBackground.Size = UDim2.fromOffset(0, 0)
    WatermarkBackground.Visible = false

    库：UpdateDPI（WatermarkBackground，{
        位置 = 假，
        尺寸=假，
    })

    本地 Holder = New("Frame", {
        BackgroundColor3 = "背景颜色",
        位置 = UDim2.fromOffset(2, 2),
        尺寸 = UDim2.new(1, -4, 1, -4),
        父级 = WatermarkBackground，
    })
    新的（“UICorner”，{
        角半径 = UDim.new(0, 库.角半径 - 1),
        父母=持有人，
    })

    本地 WatermarkLabel = New("TextLabel", {
        背景透明度 = 1，
        尺寸 = UDim2.new(1, 0, 0, 32),
        位置 = UDim2.fromOffset(0，-8 * Library.DPIScale + 7)，
        文本 = "",
        文本大小 = 15，
        文本X对齐 = 枚举.文本X对齐.左，
        父母=持有人，
    })
    新的（“UIPadding”，{
        PaddingLeft = UDim.new(0, 12),
        PaddingRight = UDim.new(0, 12),
        父级 = WatermarkLabel，
    })

    库：MakeDraggable（WatermarkBackground，WatermarkLabel，true）

    本地函数 ResizeWatermark()
        本地 X，Y = 库：GetTextBounds（WatermarkLabel.Text，Library.Scheme.Font，15）
        WatermarkBackground.Size = UDim2.fromOffset((12 + X + 12 + 4) * Library.DPIScale，Y * Library.DPIScale * 2 + 4)
        库：UpdateDPI（WatermarkBackground，{
            尺寸 = UDim2.fromOffset(12 + X + 12 + 4, Y * 2 + 4),
        })
    结尾

    函数库：SetWatermarkVisibility（Visible：boolean）
        WatermarkBackground.Visible = 可见
        如果可见则
            调整水印大小()
        结尾
    结尾

    函数库：SetWatermark（文本：字符串）
        WatermarkLabel.Text = Text
        调整水印大小()
    结尾
结尾

--// 上下文菜单 \\--
本地当前菜单
函数库：AddContextMenu(
    持有者：GuiObject，
    尺寸：UDim2 | () -> (),
    偏移量：{[数字]：数字} | () -> {}，
    列表：数字？，
    ActiveCallback：（Active：布尔值）->（）？
）
    本地菜单
    如果列表则
        菜单 = 新建（“滚动框架”，{
            AutomaticCanvasSize = List == 2 和 Enum.AutomaticSize.Y 或 Enum.AutomaticSize.None，
            AutomaticSize = List == 1 且 Enum.AutomaticSize.Y 或 Enum.AutomaticSize.None，
            BackgroundColor3 = "背景颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png",
            画布大小 = UDim2.fromOffset(0, 0),
            ScrollBarImageColor3 = "轮廓颜色",
            ScrollBarThickness = List == 2 且 2 或 0，
            Size = typeof(Size) == "function" 和 Size() 或 Size，
            TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png",
            可见=假，
            ZIndex = 10，
            父级 = ScreenGui，

            DPIExclude = {
                位置 = 真，
            }，
        })
    别的
        菜单 = 新建（“框架”，{
            BackgroundColor3 = "背景颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            Size = typeof(Size) == "function" 和 Size() 或 Size，
            可见=假，
            ZIndex = 10，
            父级 = ScreenGui，

            DPIExclude = {
                位置 = 真，
            }，
        })
    结尾

    本地表 = {
        活动 = 假，
        持有人=持有人，
        菜单 = 菜单，
        列表 = 零，
        信号=零，

        尺寸 = 尺寸，
    }

    如果列表则
        表.列表 = 新建（“UIListLayout”，{
            父级 = 菜单，
        })
    结尾

    函数表：Open()
        如果 CurrentMenu == Table 那么
            返回
        elseif 当前菜单
            当前菜单:关闭()
        结尾

        当前菜单 = 表格
        表.活动 = true

        如果 typeof(Offset) == "函数" 那么
            菜单.位置 = UDim2.fromOffset(
                数学.floor（Holder.AbsolutePosition.X + Offset（）[1]），
                math.floor（Holder.AbsolutePosition.Y + Offset（）[2]）
            ）
        别的
            菜单.位置 = UDim2.fromOffset(
                数学.floor（Holder.AbsolutePosition.X + Offset[1]），
                math.floor（Holder.AbsolutePosition.Y + Offset[2]）
            ）
        结尾
        如果 typeof(Table.Size) == "函数" 那么
            菜单.大小 = 表格.大小()
        别的
            菜单.大小 = 应用DPIScale(表格.大小)
        结尾
        如果 typeof(ActiveCallback) == "function" 那么
            库：SafeCallback（ActiveCallback，true）
        结尾

        菜单.可见 = true

        Table.Signal = Holder:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
            如果 typeof(Offset) == "函数" 那么
                菜单.位置 = UDim2.fromOffset(
                    数学.floor（Holder.AbsolutePosition.X + Offset（）[1]），
                    math.floor（Holder.AbsolutePosition.Y + Offset（）[2]）
                ）
            别的
                菜单.位置 = UDim2.fromOffset(
                    数学.floor（Holder.AbsolutePosition.X + Offset[1]），
                    math.floor（Holder.AbsolutePosition.Y + Offset[2]）
                ）
            结尾
        结尾）
    结尾

    函数表：Close()
        如果 CurrentMenu ~= Table 那么
            返回
        结尾
        菜单.可见 = false

        如果表.信号则
            表.信号：断开连接()
            表.信号 = 零
        结尾
        表.Active = false
        当前菜单 = 零
        如果 typeof(ActiveCallback) == "function" 那么
            库：SafeCallback（ActiveCallback，false）
        结尾
    结尾

    函数表：Toggle()
        如果 Table.Active 那么
            表:关闭()
        别的
            表:打开()
        结尾
    结尾

    函数表：SetSize(Size)
        表.大小 = 大小
        Menu.Size = typeof(Size) == "function" 和 Size() 或 Size
    结尾

    返回表
结尾

库：GiveSignal（UserInputService.InputBegan：Connect（函数（输入：InputObject）
    如果 IsClickInput(Input, true) 那么
        本地位置 = 输入.位置

        如果
            当前菜单
            而不是（
                库：MouseIsOverFrame（CurrentMenu.Menu，位置）
                或 Library:MouseIsOverFrame(CurrentMenu.Holder, Location)
            ）
        然后
            当前菜单:关闭()
        结尾
    结尾
结尾））

--// 工具提示 \\--
本地 TooltipLabel = New("TextLabel", {
    BackgroundColor3 = "背景颜色",
    BorderColor3 = "轮廓颜色",
    边框尺寸像素 = 1，
    文本大小 = 14，
    TextWrapped = true，
    可见=假，
    ZIndex = 20，
    父级 = ScreenGui，
})
TooltipLabel:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
    本地 X，Y = 库：GetTextBounds（
        工具提示标签.文本，
        工具提示标签.字体，
        工具提示标签.文本大小，
        工作区.CurrentCamera.ViewportSize.X - TooltipLabel.AbsolutePosition.X - 4
    ）

    TooltipLabel.Size = UDim2.fromOffset(X + 8 * Library.DPIScale，Y + 4 * Library.DPIScale)
    库：UpdateDPI（TooltipLabel，{
        尺寸 = UDim2.fromOffset(X, Y),
        DPI偏移 = {
            尺寸 = { 8, 4 },
        }，
    })
结尾）

本地 CurrentHoverInstance
函数库：AddTooltip（InfoStr：字符串，DisabledInfoStr：字符串，HoverInstance：GuiObject）
    本地工具提示表 = {
        已禁用 = 假，
        悬停 = false，
        信号 = {},
    }

    局部函数 DoHover()
        如果
            CurrentHoverInstance == HoverInstance
            或（CurrentMenu 和 Library:MouseIsOverFrame(CurrentMenu.Menu, Mouse)）
            或 (TooltipTable.Disabled 和 typeof(DisabledInfoStr) ~= "string")
            或（不是 TooltipTable.Disabled 和 typeof(InfoStr) ~= "string"）
        然后
            返回
        结尾
        CurrentHoverInstance = HoverInstance

        TooltipLabel.Text = TooltipTable.Disabled 和 DisabledInfoStr 或 InfoStr
        工具提示标签.可见 = true

        尽管
            图书馆.切换
            和库：MouseIsOverFrame（HoverInstance，Mouse）
            而不是（CurrentMenu 和 Library:MouseIsOverFrame(CurrentMenu.Menu, Mouse)）
        做
            TooltipLabel.Position = UDim2.fromOffset(
                Mouse.X + (Library.ShowCustomCursor 和 8 或 14)，
                Mouse.Y +（Library.ShowCustomCursor 和 8 或 12）
            ）

            RunService.RenderStepped:等待()
        结尾

        TooltipLabel.Visible = false
        CurrentHoverInstance = nil
    结尾

    表.插入（TooltipTable.信号，HoverInstance.MouseEnter：Connect（DoHover））
    表.插入（TooltipTable.信号，HoverInstance.MouseMoved：连接（DoHover））
    表.插入（
        工具提示表.信号，
        HoverInstance.MouseLeave:Connect(函数()
            如果 CurrentHoverInstance ~= HoverInstance 那么
                返回
            结尾

            TooltipLabel.Visible = false
            CurrentHoverInstance = nil
        结尾）
    ）

    函数 TooltipTable:Destroy()
        对于 Index = #TooltipTable.Signals, 1, -1 执行
            本地连接 = 表.删除（TooltipTable.信号，索引）
            连接：断开（）
        结尾

        如果 CurrentHoverInstance == HoverInstance 那么
            TooltipLabel.Visible = false
            CurrentHoverInstance = nil
        结尾
    结尾

    返回 TooltipTable
结尾

函数库：OnUnload（回调）
    表.插入（Library.UnloadSignals，回调）
结尾

函数库：卸载（）
    对于 Index = #Library.Signals, 1, -1 执行
        本地连接 = 表.删除（库.信号，索引）
        连接：断开（）
    结尾

    对于_，回调成对（Library.UnloadSignals）执行
        库：SafeCallback（回调）
    结尾

    库.卸载=真
    ScreenGui:销毁()
    getgenv().Library = nil
结尾

本地 CheckIcon = Library:GetIcon("检查")
本地 ArrowIcon = Library:GetIcon("chevron-up")
本地 ResizeIcon = Library:GetIcon("move-diagonal-2")
本地 KeyIcon = Library:GetIcon("key")

本地 BaseAddons = {}
做
    本地函数 = {}

    函数 Funcs:AddKeyPicker(Idx，Info)
        信息 = 库：验证（信息，模板.KeyPicker）

        本地 ParentObj = 自身
        本地 ToggleLabel = ParentObj.TextLabel

        本地 KeyPicker = {
            文本 = 信息文本，

            值 = Info.Default, -- 键
            修饰符 = Info.DefaultModifiers, -- 修饰符
            DisplayValue = Info.Default, -- 选择器文本

            切换 = false，
            模式 = 信息模式，
            同步切换状态 = 信息.同步切换状态，

            回调 = 信息回调，
            更改回调 = 信息.更改回调，
            已更改 = 信息已更改，
            点击次数 = 信息点击次数，

            类型 = “KeyPicker”，
        }

        如果 KeyPicker.Mode == "按下" 那么
            assert(ParentObj.Type == "Label", "模式为‘Press’的KeyPicker只能应用于标签。")
            
            KeyPicker.SyncToggleState = false
            Info.Modes = {“按下”}
            信息模式 = “按下”
        结尾

        如果 KeyPicker.SyncToggleState 那么
            信息模式 = {“切换”}
            Info.Mode =“切换”
        结尾

        本地采摘 = false

        -- 特殊键
        本地特殊键 = {
            [“MB1”] = Enum.UserInputType.MouseButton1,
            ["MB2"] = Enum.UserInputType.MouseButton2,
            [“MB3”] = Enum.UserInputType.MouseButton3
        }

        本地特殊键输入 = {
            [Enum.UserInputType.MouseButton1] = "MB1",
            [Enum.UserInputType.MouseButton2] = "MB2",
            [Enum.UserInputType.MouseButton3] = "MB3"
        }

        -- 修饰符
        本地修饰符 = {
            ["LAlt"] = Enum.KeyCode.LeftAlt,
            ["RAlt"] = Enum.KeyCode.RightAlt,

            ["LCtrl"] = Enum.KeyCode.LeftControl,
            ["RCtrl"] = Enum.KeyCode.RightControl,

            ["LShift"] = Enum.KeyCode.LeftShift,
            ["RShift"] = Enum.KeyCode.RightShift,

            ["Tab"] = Enum.KeyCode.Tab,
            ["CapsLock"] = Enum.KeyCode.CapsLock
        }

        本地修改器输入 = {
            [Enum.KeyCode.LeftAlt] = "LAlt",
            [Enum.KeyCode.RightAlt] = "RAlt",

            [Enum.KeyCode.LeftControl] = "左Ctrl",
            [Enum.KeyCode.RightControl] = "右控制键",

            [Enum.KeyCode.LeftShift] = "左移",
            [Enum.KeyCode.RightShift] = "右移",

            [Enum.KeyCode.Tab] = "Tab",
            [Enum.KeyCode.CapsLock] = "大写锁定"
        }

        本地 IsModifierInput = 函数（输入）
            返回 Input.UserInputType == Enum.UserInputType.Keyboard 和 ModifiersInput[Input.KeyCode] ~= nil;
        结尾;

        本地 GetActiveModifiers = 函数（）
            本地 ActiveModifiers = {};

            对于名称，在修饰符中输入
                如果 table.find(ActiveModifiers, Name) 则继续结束
                如果不是 UserInputService:IsKeyDown(Input) 则继续结束

                表.插入（ActiveModifiers，名称）；
            结尾;

            返回 ActiveModifiers；
        结尾

        本地 AreModifiersHeld = 函数（必需）
            如果不是 (typeof(Required) == "table" 并且 GetTableSize(Required) > 0) 那么
                返回 true；
            结尾;

            本地 ActiveModifiers = GetActiveModifiers();
            本地控股=真；

            对于 _，名称在必填项中
                如果 table.find(ActiveModifiers, Name) 则继续结束

                持有=假；
                休息;
            结尾

            退货持有；
        结尾

        本地 IsInputDown = 函数（输入）
            如果没有输入则
                返回 false；
            结尾;

            如果 SpecialKeysInput[Input.UserInputType] ~= nil 那么
                返回 UserInputService:IsMouseButtonPressed(Input.UserInputType) 而不是 UserInputService:GetFocusedTextBox();
            elseif Input.UserInputType == Enum.UserInputType.Keyboard 然后
                返回 UserInputService:IsKeyDown(Input.KeyCode) 而不是 UserInputService:GetFocusedTextBox();
            别的
                返回 false；
            结尾
        结尾

        本地 ConvertToInputModifiers = 函数（CurrentModifiers）
            本地输入修饰符 = {};

            对于 _，CurrentModifiers 中的名称
                表.插入（InputModifiers，Modifiers [name]）；
            结尾

            返回输入修饰符；
        结尾

        本地 VerifyModifiers = 函数（CurrentModifiers）
            如果 typeof(CurrentModifiers) ~= "table" 那么
                返回 {};
            结尾;

            本地ValidModifiers = {};

            对于 _，CurrentModifiers 中的名称
                如果不是 Modifiers[name] 则继续结束

                表.插入（ValidModifiers，名称）；
            结尾

            返回ValidModifiers；
        结尾

        KeyPicker.Modifiers = VerifyModifiers(KeyPicker.Modifiers); -- 验证默认修饰符

        本地 Picker = New(“TextButton”，{
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            尺寸 = UDim2.fromOffset(18, 18),
            文本 = KeyPicker.值，
            文本大小 = 14，
            父级 = ToggleLabel，
        })

        本地 KeybindsToggle = { Normal = KeyPicker.Mode ~= "Toggle" }; 执行
            本地 Holder = New("TextButton", {
                背景透明度 = 1，
                尺寸 = UDim2.new(1, 0, 0, 16),
                文本 = "",
                可见 = 不 Info.NoUI，
                父级 = Library.KeybindContainer，
            })

            本地标签 = 新建（“文本标签”，{
                背景透明度 = 1，
                尺寸 = UDim2.fromScale(1, 1),
                文本 = "",
                文本大小 = 14，
                文本透明度 = 0.5，
                父母=持有人，

                DPIExclude = {
                    尺寸 = 真实，
                }，
            })

            本地复选框 = 新建（“框架”，{
                背景颜色3 = "主颜色",
                尺寸 = UDim2.fromOffset(14, 14),
                SizeConstraint = Enum.SizeConstraint.RelativeYY，
                父母=持有人，
            })
            新的（“UICorner”，{
                角半径 = UDim.new(0, 库.角半径 / 2),
                父级 = 复选框，
            })
            新的（“UIStroke”，{
                颜色 = “轮廓颜色”，
                父级 = 复选框，
            })

            本地 CheckImage = New("ImageLabel", {
                Image = CheckIcon 和 CheckIcon.Url 或“”
                ImageColor3 = "字体颜色",
                ImageRectOffset = CheckIcon 和 CheckIcon.ImageRectOffset 或 Vector2.zero，
                ImageRectSize = CheckIcon 和 CheckIcon.ImageRectSize 或 Vector2.zero，
                图像透明度 = 1，
                位置 = UDim2.fromOffset(2, 2),
                尺寸 = UDim2.new(1, -4, 1, -4),
                父级 = 复选框，
            })

            函数 KeybindsToggle:Display(State)
                Label.TextTransparency = 状态和 0 或 0.5
                CheckImage.ImageTransparency = 状态和 0 或 1
            结尾

            函数 KeybindsToggle:SetText(Text)
                本地 X = 库：GetTextBounds（文本，标签.FontFace，标签.TextSize）
                标签.文本 = 文本
                标签.大小 = UDim2.new(0, X, 1, 0)
            结尾

            函数 KeybindsToggle:SetVisibility(Visibility)
                Holder.Visible = 可见性
            结尾

            函数 KeybindsToggle:SetNormal(Normal)
                KeybindsToggle.Normal = 正常

                Holder.Active = 不正常
                Label.Position = Normal 和 UDim2.fromOffset(0, 0) 或 UDim2.fromOffset(22 * Library.DPIScale, 0)
                Checkbox.Visible = 不正常
            结尾

            Holder.MouseButton1Click:连接（函数（）
                如果 KeybindsToggle.Normal 那么
                    返回
                结尾

                KeyPicker.Toggled = 不是 KeyPicker.Toggled
                按键选择器：单击（）
            结尾）

            KeybindsToggle.Holder = 持有者
            KeybindsToggle.Label = 标签
            KeybindsToggle.Checkbox = 复选框
            KeybindsToggle.Loaded = true
            表.插入（库.KeybindToggles，KeybindsToggle）
        结尾

        本地菜单表 = 库：AddContextMenu（Picker，UDim2.fromOffset（62，0），函数（）
            返回 { Picker.AbsoluteSize.X + 1.5, 0.5 }
        结束，1）
        KeyPicker.Menu = MenuTable

        本地模式按钮 = {}
        对于 _，模式成对（Info.Modes）执行
            本地模式按钮 = {}

            本地按钮 = 新建（“文本按钮”，{
                背景颜色3 = "主颜色",
                背景透明度 = 1，
                尺寸 = UDim2.new(1, 0, 0, 21),
                文本 = 模式，
                文本大小 = 14，
                文本透明度 = 0.5，
                父级 = 菜单表.菜单，
            })

            函数模式按钮：选择（）
                对于 _，按钮成对（ModeButtons）执行
                    按钮：取消选择（）
                结尾

                KeyPicker.Mode = 模式

                按钮.背景透明度 = 0
                按钮.文本透明度 = 0

                菜单表：关闭（）
            结尾

            函数 ModeButton:取消选择()
                KeyPicker.模式 = 零

                按钮.背景透明度 = 1
                按钮.文本透明度 = 0.5
            结尾

            Button.MouseButton1Click:连接（函数（）
                模式按钮：选择（）
            结尾）

            如果 KeyPicker.Mode == Mode 那么
                模式按钮：选择（）
            结尾

            模式按钮[模式] = 模式按钮
        结尾

        函数 KeyPicker:Display()
            如果 Library.Unloaded 则
                返回
            结尾

            局部 X, Y =
                库：GetTextBounds（KeyPicker.DisplayValue，Picker.FontFace，Picker.TextSize，ToggleLabel.AbsoluteSize.X）
            Picker.Text = KeyPicker.DisplayValue
            Picker.Size = UDim2.fromOffset(X + 9 * Library.DPIScale，Y + 4 * Library.DPIScale)
        结尾

        函数 KeyPicker:Update()
            键选择器：显示（）

            如果 Info.NoUI 那么
                返回
            结尾

            如果 KeyPicker.Mode == "Toggle" 且 ParentObj.Type == "Toggle" 且 ParentObj.Disabled 则
                KeybindsToggle：设置可见性（false）
                返回
            结尾

            本地状态 = KeyPicker:GetState()
            本地 ShowToggle = Library.ShowToggleFrameInKeybinds 和 KeyPicker.Mode ==“Toggle”

            如果 KeybindsToggle.Loaded 则
                如果显示切换则
                    键绑定切换：设置正常（false）
                别的
                    KeybindsToggle：设置正常（true）
                结尾

                KeybindsToggle:SetText((“[%s] %s (%s)”):format(KeyPicker.DisplayValue, KeyPicker.Text, KeyPicker.Mode))
                KeybindsToggle：设置可见性（true）
                键绑定切换：显示（状态）
            结尾

            库：UpdateKeybindFrame()
        结尾

        函数 KeyPicker:GetState()
            如果 KeyPicker.Mode ==“Always”那么
                返回 true；

            elseif KeyPicker.Mode == "Hold" then
                本地密钥 = KeyPicker.Value
                如果 Key == "None" 那么
                    返回 false；
                结尾

                如果不是 AreModifiersHeld(Ke yPicker.Modifiers) 那么
                    返回 false；
                结尾;

                如果 SpecialKeys[Key] ~= nil 那么
                    返回 UserInputService:IsMouseButtonPressed(SpecialKeys[Key]) 而不是 UserInputService:GetFocusedTextBox();
                别的
                    返回 UserInputService:IsKeyDown(Enum.KeyCode[Key]) 而不是 UserInputService:GetFocusedTextBox();
                结尾;

            别的
                返回 KeyPicker.Toggled；
            结尾
        结尾

        函数 KeyPicker:OnChanged(Func)
            KeyPicker.Changed = Func
        结尾

        函数 KeyPicker:OnClick(Func)
            KeyPicker.Clicked = Func
        结尾

        函数 KeyPicker:DoClick()
            如果 KeyPicker.Mode == "按下" 那么
                如果 KeyPicker.Toggled 和 Info.WaitForCallback == true，则
                    返回
                结尾

                KeyPicker.Toggled = true
            结尾

            如果 ParentObj.Type == "Toggle" 并且 KeyPicker.SyncToggleState 那么
                ParentObj：设置值（KeyPicker.Toggled）
            结尾

            库：SafeCallback（KeyPicker.Callback，KeyPicker.Toggled）
            库：SafeCallback（KeyPicker.Clicked，KeyPicker.Toggled）

            如果 KeyPicker.Mode == "按下" 那么
                KeyPicker.Toggled = false
            结尾
        结尾

        函数 KeyPicker:SetValue(数据)
            本地密钥、模式、修饰符 = 数据[1]、数据[2]、数据[3]

            KeyPicker.值 = 键；
            KeyPicker.Modifiers = VerifyModifiers(如果 typeof(Modifiers) == "table" 则 Modifiers 否则 KeyPicker.Modifiers);
            KeyPicker.DisplayValue = 如果 GetTableSize(KeyPicker.Modifiers) > 0 则 (table.concat(KeyPicker.Modifiers, " + ") .. " + " .. KeyPicker.Value) 否则 KeyPicker.Value;

            如果 ModeButtons[Mode] 那么
                模式按钮[模式]:选择()
            结尾

            本地 NewKey，NewModifiers = 如果 SpecialKeys[Key] == nil 则 Enum.KeyCode[Key] 否则 SpecialKeys[Key]，ConvertToInputModifiers(KeyPicker.Modifiers);
            库：SafeCallback(
                KeyPicker.ChangedCallback，
                新键、新修饰符
            ）
            库：SafeCallback(
                KeyPicker.已更改，
                新键、新修饰符
            ）

            键选择器：更新（）
        结尾

        函数 KeyPicker:SetText(文本)
            KeybindsToggle：设置文本（文本）
            键选择器：更新（）
        结尾

        Picker.MouseButton1Click:Connect(函数()
            如果选择则
                返回
            结尾

            采摘 = 真

            Picker.Text =“...”
            Picker.Size = UDim2.fromOffset(29 * Library.DPIScale, 18 * Library.DPIScale)

            -- 等待非修饰键 --
            本地输入
            重复
                输入 = UserInputService.InputBegan:Wait()
                如果 UserInputService:GetFocusedTextBox() 那么
                    采摘 = 错误
                    键选择器：更新（）
                    返回
                结尾
            直到不是 IsModifierInput(Input)

            本地密钥 =“未知”
            本地 ActiveModifiers =
                如果 Input.KeyCode == Enum.KeyCode.Escape 则 {} 否则 GetActiveModifiers();

            如果 SpecialKeysInput[Input.UserInputType] ~= nil 那么
                键 = 特殊键输入[输入.用户输入类型];
            elseif Input.UserInputType == Enum.UserInputType.Keyboard 然后
                Key = Input.KeyCode == Enum.KeyCode.Escape 和“None”或Input.KeyCode.Name；
            结尾

            KeyPicker.Toggled = false;
            KeyPicker:SetValue({ Key, KeyPicker.Mode, ActiveModifiers })

            -- RunService.RenderStepped:Wait()
            重复 task.wait() 直到 IsInputDown(Input) 或 UserInputService:GetFocusedTextBox() 不生效
            采摘 = 错误
        结尾）
        Picker.MouseButton2Click:连接（MenuTable.Toggle）

        库：GiveSignal（UserInputService.InputBegan：Connect（函数（输入：InputObject）
            如果
                KeyPicker.Mode ==“始终”
                或 KeyPicker.Value ==“未知”
                或 KeyPicker.Value ==“None”
                或挑选
                或 UserInputService:GetFocusedTextBox()
            然后
                返回
            结尾

            本地密钥 = KeyPicker.值；
            本地 HoldingModifiers = AreModifiersHeld(KeyPicker.Modifiers);
            本地 HoldingKey = false;

            如果
                Key 和 HoldingModifiers == true 并且 (
                    SpecialKeysInput[Input.UserInputType] == Key 或
                    （Input.UserInputType == Enum.UserInputType.Keyboard 和 Input.KeyCode.Name == Key）
                ）
            然后
                HoldingKey = true
            结尾

            如果 KeyPicker.Mode == "Toggle" 那么
                如果 HoldingKey 那么
                    KeyPicker.Toggled = 不是 KeyPicker.Toggled
                    按键选择器：单击（）
                结尾

            elseif KeyPicker.Mode == "按下" 然后
                如果 HoldingKey 那么
                    按键选择器：单击（）
                结尾
            结尾

            键选择器：更新（）
        结尾））

        库：GiveSignal（UserInputService.InputEnded：Connect（函数（）
            如果
                KeyPicker.Value ==“未知”
                或 KeyPicker.Value ==“None”
                或挑选
                或 UserInputService:GetFocusedTextBox()
            然后
                返回
            结尾

            键选择器：更新（）
        结尾））

        键选择器：更新（）

        如果 ParentObj.Addons 那么
            表.插入（ParentObj.Addons，KeyPicker）
        结尾

        选项[Idx] = KeyPicker

        返回自我
    结尾

    本地 HueSequenceTable = {}
    对于 Hue = 0, 1, 0.1
        表.插入（HueSequenceTable，ColorSequenceKeypoint.new（Hue，Color3.fromHSV（Hue，1,1）））
    结尾
    函数 Funcs:AddColorPicker(Idx, Info)
        信息 = 库：验证（信息，模板.ColorPicker）

        本地 ParentObj = 自身
        本地 ToggleLabel = ParentObj.TextLabel

        本地颜色选择器 = {
            值 = Info.Default，
            透明度 = Info.Transparency 或 0，
            标题 = 信息标题，

            回调 = 信息回调，
            已更改 = 信息已更改，

            类型 = “颜色选择器”，
        }
        ColorPicker.Hue，ColorPicker.Sat，ColorPicker.Vib = ColorPicker.Value:ToHSV()

        本地 Holder = New("TextButton", {
            背景颜色3 = 颜色选择器.值，
            BorderColor3 = 库:GetDarkerColor(ColorPicker.Value),
            边框尺寸像素 = 1，
            尺寸 = UDim2.fromOffset(18, 18),
            文本 = "",
            父级 = ToggleLabel，
        })

        本地 HolderTransparency = New(“ImageLabel”，{
            图像 = ObsidianImageManager.GetAsset("TransparencyTexture"),
            图像透明度 = (1 - 颜色选择器透明度),
            ScaleType = Enum.ScaleType.Tile,
            尺寸 = UDim2.fromScale(1, 1),
            TileSize = UDim2.fromOffset(9, 9),
            父母=持有人，
        })

        --// 颜色菜单 \\--
        本地 ColorMenu = Library:AddContextMenu(
            持有者，
            UDim2.fromOffset(Info.Transparency 和 256 或 234, 0)，
            功能（）
                返回 { 0.5, Holder.AbsoluteSize.Y + 1.5 }
            结尾，
            1
        ）
        颜色菜单.列表.填充 = UDim.new(0, 8)
        ColorPicker.ColorMenu = ColorMenu

        新的（“UIPadding”，{
            PaddingBottom = UDim.new(0, 6),
            PaddingLeft = UDim.new(0, 6),
            PaddingRight = UDim.new(0, 6),
            PaddingTop = UDim.new(0, 6),
            父级 = ColorMenu.Menu，
        })

        如果 typeof(ColorPicker.Title) == "string" 那么
            新的（“文本标签”，{
                背景透明度 = 1，
                尺寸 = UDim2.new(1, 0, 0, 8),
                文本 = ColorPicker.标题，
                文本大小 = 14，
                文本X对齐 = 枚举.文本X对齐.左，
                父级 = ColorMenu.Menu，
            })
        结尾

        本地 ColorHolder = New("Frame", {
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 200),
            父级 = ColorMenu.Menu，
        })
        新的（“UIListLayout”，{
            FillDirection = Enum.FillDirection.Horizo​​ntal,
            填充 = UDim.new(0, 6),
            父级 = ColorHolder，
        })

        --// 卫星地图
        本地 SatVipMap = New("ImageButton", {
            背景颜色3 = 颜色选择器.值，
            图像 = ObsidianImageManager.GetAsset("饱和度图"),
            尺寸 = UDim2.fromOffset(200, 200),
            父级 = ColorHolder，
        })

        本地 SatVibCursor = New("Frame", {
            锚点 = Vector2.new(0.5, 0.5),
            背景颜色3 = "白色",
            大小 = UDim2.fromOffset(6, 6),
            父级 = SatVipMap，
        })
        新的（“UICorner”，{
            角半径 = UDim.new(1, 0),
            父级 = SatVibCursor，
        })
        新的（“UIStroke”，{
            颜色 =“深色”，
            父级 = SatVibCursor，
        })

        --// 色调
        本地 HueSelector = New("TextButton", {
            大小 = UDim2.fromOffset(16, 200),
            文本 = "",
            父级 = ColorHolder，
        })
        新的（“UIGradient”，{
            颜色 = ColorSequence.new（HueSequenceTable），
            旋转 = 90，
            父级 = HueSelector，
        })

        本地 HueCursor = New("Frame", {
            锚点 = Vector2.new(0.5, 0.5),
            背景颜色3 = "白色",
            BorderColor3 = "深色",
            边框尺寸像素 = 1，
            位置 = UDim2.fromScale(0.5，ColorPicker.Hue)，
            尺寸 = UDim2.new(1, 2, 0, 1),
            父级 = HueSelector，
        })

        --// 阿尔法
        本地透明度选择器、透明度颜色、透明度光标
        如果信息透明度那么
            TransparencySelector = New("ImageButton", {
                图像 = ObsidianImageManager.GetAsset("TransparencyTexture"),
                ScaleType = Enum.ScaleType.Tile,
                大小 = UDim2.fromOffset(16, 200),
                TileSize = UDim2.fromOffset(8, 8),
                父级 = ColorHolder，
            })

            透明颜色 = 新的（“框架”，{
                背景颜色3 = 颜色选择器.值，
                尺寸 = UDim2.fromScale(1, 1),
                父级 = 透明选择器，
            })
            新的（“UIGradient”，{
                旋转 = 90，
                透明度 = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(1, 1),
                }),
                父级 = 透明颜色，
            })

            TransparencyCursor = New("框架", {
                锚点 = Vector2.new(0.5, 0.5),
                背景颜色3 = "白色",
                BorderColor3 = "深色",
                边框尺寸像素 = 1，
                位置 = UDim2.fromScale(0.5，ColorPicker.Transparency)，
                尺寸 = UDim2.new(1, 2, 0, 1),
                父级 = 透明选择器，
            })
        结尾

        本地 InfoHolder = New("Frame", {
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 20),
            父级 = ColorMenu.Menu，
        })
        新的（“UIListLayout”，{
            FillDirection = Enum.FillDirection.Horizo​​ntal,
            Horizo​​ntalFlex = Enum.UIFlexAlignment.Fill，
            填充 = UDim.new(0, 8),
            父母 = 信息持有者，
        })

        本地 HueBox = New("文本框", {
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            ClearTextOnFocus = false，
            尺寸 = UDim2.fromScale(1, 1),
            文本 = “#??????”,
            文本大小 = 14，
            父母 = 信息持有者，
        })

        本地 RgbBox = New("文本框", {
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            ClearTextOnFocus = false，
            尺寸 = UDim2.fromScale(1, 1),
            文本 =“？，？，？”，
            文本大小 = 14，
            父母 = 信息持有者，
        })

        --// 上下文菜单 \\--
        本地 ContextMenu = 库：AddContextMenu（Holder，UDim2.fromOffset（93，0），函数（）
            返回 { Holder.AbsoluteSize.X + 1.5, 0.5 }
        结束，1）
        ColorPicker.ContextMenu = ContextMenu
        做
            本地函数 CreateButton(Text, Func)
                本地按钮 = 新建（“文本按钮”，{
                    背景透明度 = 1，
                    尺寸 = UDim2.new(1, 0, 0, 21),
                    文本 = 文本，
                    文本大小 = 14，
                    父级 = ContextMenu.Menu，
                })

                Button.MouseButton1Click:连接（函数（）
                    库：SafeCallback（Func）
                    上下文菜单：关闭()
                结尾）
            结尾

            CreateButton("复制颜色", function()
                库.CopiedColor = { 颜色选择器.值，颜色选择器.透明度}
            结尾）

            CreateButton("粘贴颜色", function()
                颜色选择器：SetValueRGB（库.CopiedColor[1]，库.CopiedColor[2]）
            结尾）

            如果设置剪贴板则
                CreateButton("复制十六进制", function()
                    设置剪贴板（tostring（ColorPicker.Value：ToHex（）））
                结尾）
                CreateButton("复制 RGB", 函数()
                    设置剪贴板（table.concat（{
                        数学.floor（ColorPicker.Value.R * 255），
                        数学.floor（ColorPicker.Value.G * 255），
                        数学.floor（ColorPicker.Value.B * 255），
                    }, ", "))
                结尾）
            结尾
        结尾

        - // 结尾 \\ - 

        函数 ColorPicker:SetHSVFromRGB(Color)
            ColorPicker.Hue，ColorPicker.Sat，ColorPicker.Vib = Color：ToHSV（）
        结尾

        函数颜色选择器：显示（）
            如果 Library.Unloaded 则
                返回
            结尾

            ColorPicker.Value = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib)

            Holder.BackgroundColor3 = ColorPicker.Value
            Holder.BorderColor3 = 库：GetDarkerColor(ColorPicker.Value)
            HolderTransparency.ImageTransparency = (1 - ColorPicker.Transparency)

            SatVipMap.BackgroundColor3 = Color3.fromHSV(ColorPicker.Hue, 1, 1)
            如果 TransparencyColor 那么
                TransparencyColor.BackgroundColor3 = ColorPicker.Value
            结尾

            SatVibCursor.Position = UDim2.fromScale(ColorPicker.Sat，1-ColorPicker.Vib)
            HueCursor.Position = UDim2.fromScale(0.5，ColorPicker.Hue)
            如果 TransparencyCursor 那么
                TransparencyCursor.Position = UDim2.fromScale(0.5，ColorPicker.Transparency)
            结尾

            HueBox.Text =“#”..ColorPicker.Value:ToHex()
            RgbBox.Text = table.concat({
                数学.floor（ColorPicker.Value.R * 255），
                数学.floor（ColorPicker.Value.G * 255），
                数学.floor（ColorPicker.Value.B * 255），
            }, ", ")
        结尾

        函数颜色选择器：更新（）
            颜色选择器:显示()

            库：SafeCallback（ColorPicker.Callback，ColorPicker.Value）
            库：SafeCallback（ColorPicker.Changed，ColorPicker.Value）
        结尾

        函数 ColorPicker:OnChanged(Func)
            ColorPicker.Changed = Func
        结尾

        函数 ColorPicker:SetValue(HSV, 透明度)
            局部颜色 = Color3.fromHSV(HSV[1], HSV[2], HSV[3])

            ColorPicker.Transparency = Info.Transparency 和 Transparency 或 0
            颜色选择器：SetHSVFromRGB（颜色）
            颜色选择器：更新（）
        结尾

        函数 ColorPicker:SetValueRGB(颜色，透明度)
            ColorPicker.Transparency = Info.Transparency 和 Transparency 或 0
            颜色选择器：SetHSVFromRGB（颜色）
            颜色选择器：更新（）
        结尾

        Holder.MouseButton1Click:连接（ColorMenu.Toggle）
        Holder.MouseButton2Click:连接（ContextMenu.Toggle）

        SatVipMap.InputBegan:Connect(函数(输入：InputObject)
            当 IsDragInput(Input) 执行
                本地 MinX = SatVipMap.AbsolutePosition.X
                本地 MaxX = MinX + SatVipMap.AbsoluteSize.X
                本地 LocationX = math.clamp(Mouse.X, MinX, MaxX)

                本地 MinY = SatVipMap.AbsolutePosition.Y
                本地 MaxY = MinY + SatVipMap.AbsoluteSize.Y
                本地 LocationY = math.clamp(Mouse.Y, MinY, MaxY)

                本地 OldSat = ColorPicker.Sat
                本地 OldVib = ColorPicker.Vib
                ColorPicker.Sat = (LocationX - MinX) / (MaxX - MinX)
                ColorPicker.Vib = 1 - ((LocationY - MinY) / (MaxY - MinY))

                如果 ColorPicker.Sat ~= OldSat 或 ColorPicker.Vib ~= OldVib 那么
                    颜色选择器：更新（）
                结尾

                RunService.RenderStepped:等待()
            结尾
        结尾）
        HueSelector.InputBegan:Connect（函数（输入：InputObject）
            当 IsDragInput(Input) 执行
                本地最小值 = HueSelector.AbsolutePosition.Y
                局部最大值 = 最小值 + HueSelector.AbsoluteSize.Y
                本地位置 = math.clamp(Mouse.Y, Min, Max)

                本地 OldHue = ColorPicker.Hue
                ColorPicker.Hue = (位置 - 最小值) / (最大值 - 最小值)

                如果 ColorPicker.Hue ~= OldHue 那么
                    颜色选择器：更新（）
                结尾

                RunService.RenderStepped:等待()
            结尾
        结尾）
        如果 TransparencySelector 那么
            TransparencySelector.InputBegan:Connect(函数(输入：InputObject)
                当 IsDragInput(Input) 执行
                    本地最小值 = TransparencySelector.AbsolutePosition.Y
                    局部最大值 = TransparencySelector.AbsolutePosition.Y + TransparencySelector.AbsoluteSize.Y
                    本地位置 = math.clamp(Mouse.Y, Min, Max)

                    本地 OldTransparency = ColorPicker.Transparency
                    ColorPicker.Transparency = (位置 - 最小值) / (最大值 - 最小值)

                    如果 ColorPicker.Transparency ~= OldTransparency 那么
                        颜色选择器：更新（）
                    结尾

                    RunService.RenderStepped:等待()
                结尾
            结尾）
        结尾

        HueBox.FocusLost:连接（函数（输入）
            如果没有输入则
                返回
            结尾

            本地成功，Color = pcall（Color3.fromHex，HueBox.Text）
            如果成功并且 typeof(Color) == "Color3" 那么
                ColorPicker.Hue，ColorPicker.Sat，ColorPicker.Vib = Color：ToHSV（）
            结尾

            颜色选择器：更新（）
        结尾）
        RgbBox.FocusLost:连接（函数（输入）
            如果没有输入则
                返回
            结尾

            本地 R, G, B = RgbBox.Text:match("(%d+),%s*(%d+),%s*(%d+)")
            如果 R 和 G 和 B 那么
                颜色选择器：SetHSVFromRGB（Color3.fromRGB（R，G，B））
            结尾

            颜色选择器：更新（）
        结尾）

        颜色选择器:显示()

        如果 ParentObj.Addons 那么
            表.插入（ParentObj.Addons，ColorPicker）
        结尾

        选项[Idx] = 颜色选择器

        返回自我
    结尾

    BaseAddons.__index = Funcs
    BaseAddons.__namecall = 函数（_，键，...）
        返回 Funcs[Key](...)
    结尾
结尾

本地 BaseGroupbox = {}
做
    本地函数 = {}

    函数 Funcs:AddDivider()
        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地 Holder = New("Frame", {
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            尺寸 = UDim2.new(1, 0, 0, 2),
            父级 = 容器，
        })

        组框：调整大小（）

        表.插入（Groupbox.元素，{
            持有人=持有人，
            类型 = “分隔符”，
        })
    结尾

    函数 Funcs:AddLabel(...)
        本地数据 = {}
        本地插件 = {}

        本地 First = 选择（1，...）
        本地 Second = 选择（2，...）

        如果 typeof(First) == "table" 或 typeof(Second) == "table" 那么
            本地 Params = typeof(First) == "table" 和 First 或 Second

            数据.文本 = 参数.文本或“”
            Data.DoesWrap = Params.DoesWrap 或 false
            数据大小 = 参数大小或 14
            Data.Visible = Params.Visible 或 true
            Data.Idx = typeof(Second) == "table" 且 First 或 nil
        别的
            数据.文本 = 第一个或“”
            Data.DoesWrap = Second 或 false
            数据大小 = 14
            数据.可见 = true
            Data.Idx = select(3，...) 或 nil
        结尾

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地标签 = {
            文本 = 数据.文本，
            是否包装 = 数据.是否包装，

            插件 = 插件，

            可见 = 数据.可见，
            类型 = “标签”，
        }

        本地 TextLabel = New("TextLabel", {
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 18),
            文本 = 标签.文本，
            文本大小 = 数据大小，
            TextWrapped = Label.DoesWrap,
            TextXAlignment = Groupbox.IsKeyTab 和 Enum.TextXAlignment.Center 或 Enum.TextXAlignment.Left，
            父级 = 容器，
        })

        函数标签：SetVisible（Visible：boolean）
            标签.可见 = 可见

            文本标签.可见 = 标签.可见
            组框：调整大小（）
        结尾

        函数标签：SetText（文本：字符串）
            标签.文本 = 文本
            TextLabel.Text = Text

            如果 Label.DoesWrap 那么
                本地_，Y =
                    库：GetTextBounds（Label.Text、TextLabel.FontFace、TextLabel.TextSize、TextLabel.AbsoluteSize.X）
                TextLabel.Size = UDim2.new(1, 0, 0, Y + 4 * Library.DPIScale)
            结尾

            组框：调整大小（）
        结尾

        如果 Label.DoesWrap 那么
            本地_，Y =
                库：GetTextBounds（Label.Text、TextLabel.FontFace、TextLabel.TextSize、TextLabel.AbsoluteSize.X）
            TextLabel.Size = UDim2.new(1, 0, 0, Y + 4 * Library.DPIScale)
        别的
            新的（“UIListLayout”，{
                FillDirection = Enum.FillDirection.Horizo​​ntal,
                水平对齐 = 枚举.水平对齐.右，
                填充 = UDim.new(0, 6),
                父级 = TextLabel，
            })
        结尾

        如果 Data.DoesWrap 那么
            本地最后= TextLabel.AbsoluteSize

            TextLabel:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                如果 TextLabel.AbsoluteSize == Last 那么
                    返回
                结尾

                本地_，Y =
                    库：GetTextBounds（Label.Text、TextLabel.FontFace、TextLabel.TextSize、TextLabel.AbsoluteSize.X）
                TextLabel.Size = UDim2.new(1, 0, 0, Y + 4 * Library.DPIScale)

                最后 = TextLabel.AbsoluteSize
                组框：调整大小（）
            结尾）
        结尾

        组框：调整大小（）

        标签.文本标签 = 文本标签
        标签.容器 = 容器
        如果不是 Data.DoesWrap 那么
            设置元表（标签，BaseAddons）
        结尾

        标签.持有人=文本标签
        表格.插入（Groupbox.元素，标签）

        如果 Data.Idx 那么
            标签[Data.Idx] = 标签
        别的
            表.插入（标签，标签）
        结尾

        返回标签
    结尾

    函数 Funcs:AddButton(...)
        本地函数 GetInfo(...)
            本地信息 = {}

            本地 First = 选择（1，...）
            本地 Second = 选择（2，...）

            如果 typeof(First) == "table" 或 typeof(Second) == "table" 那么
                本地 Params = typeof(First) == "table" 和 First 或 Second

                Info.Text = Params.Text 或“”
                Info.Func = Params.Func 或 function() 结束
                信息.DoubleClick = 参数.DoubleClick

                信息.工具提示 = 参数.工具提示
                Info.DisabledTooltip = Params.DisabledTooltip

                Info.Risky = Params.Risky 或 false
                Info.Disabled = Params.Disabled 或 false
                Info.Visible = Params.Visible 或 true
                Info.Idx = typeof(Second) == "table" 且 First 或 nil
            别的
                Info.Text = First 或“”
                Info.Func = Second 或 function() end
                信息.DoubleClick = false

                信息.工具提示 = 零
                Info.DisabledTooltip = nil

                信息风险=假
                信息.Disabled = false
                信息.可见 = true
                Info.Idx = select(3，...) 或 nil
            结尾

            返回信息
        结尾
        本地信息 = GetInfo(...)

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地按钮 = {
            文本 = 信息文本，
            函数 = 信息.函数，
            双击 = 信息.双击，

            工具提示 = 信息.工具提示，
            DisabledTooltip = Info.DisabledTooltip，
            工具提示表 = 零，

            风险 = 信息风险，
            已禁用 = Info.Disabled，
            可见 = 信息可见，

            吐温 = 零，
            类型 = “按钮”，
        }

        本地 Holder = New("Frame", {
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 21),
            父级 = 容器，
        })

        新的（“UIListLayout”，{
            FillDirection = Enum.FillDirection.Horizo​​ntal,
            Horizo​​ntalFlex = Enum.UIFlexAlignment.Fill，
            填充 = UDim.new(0, 9),
            父母=持有人，
        })

        本地函数 CreateButton(Button)
            本地 Base = New("文本按钮", {
                Active = 未 Button.Disabled，
                BackgroundColor3 = Button.Disabled 和“BackgroundColor”或“MainColor”，
                尺寸 = UDim2.fromScale(1, 1),
                文本 = 按钮.文本，
                文本大小 = 14，
                文本透明度 = 0.4，
                可见 = 按钮.可见，
                父母=持有人，
            })

            本地 Stroke = New("UIStroke", {
                颜色 = “轮廓颜色”，
                透明度 = Button.Disabled 且 0.5 或 0，
                父级 = 基础，
            })

            返回 Base、Stroke
        结尾

        本地函数 InitEvents(Button)
            按钮.Base.MouseEnter:连接（函数（）
                如果 Button.Disabled，则
                    返回
                结尾

                Button.Tween = TweenService:创建（Button.Base，Library.TweenInfo，{
                    文本透明度 = 0，
                })
                按钮.Tween:播放()
            结尾）
            Button.Base.MouseLeave:连接（函数（）
                如果 Button.Disabled，则
                    返回
                结尾

                Button.Tween = TweenService:创建（Button.Base，Library.TweenInfo，{
                    文本透明度 = 0.4，
                })
                按钮.Tween:播放()
            结尾）

            Button.Base.MouseButton1Click:Connect(函数()
                如果 Button.Disabled 或 Button.Locked 则
                    返回
                结尾

                如果按钮双击则
                    按钮.锁定 = true

                    Button.Base.Text =“你确定吗？”
                    按钮.Base.TextColor3 = 库.Scheme.AccentColor
                    Library.Registry[Button.Base].TextColor3 = "AccentColor"

                    本地点击 = WaitForEvent(Button.Base.MouseButton1Click，0.5)

                    按钮.Base.Text = 按钮.Text
                    Button.Base.TextColor3 = Button.Risky 和 ​​Library.Scheme.Red 或 Library.Scheme.FontColor
                    Library.Registry[Button.Base].TextColor3 = Button.Risky 和“Red”或“FontColor”

                    如果点击则
                        库：SafeCallback（Button.Func）
                    结尾

                    RunService.RenderStepped:Wait() --// 鼠标按钮无需等待即可触发（我讨厌 roblox）
                    按钮.锁定=假
                    返回
                结尾

                库：SafeCallback（Button.Func）
            结尾）
        结尾

        按钮.Base，按钮.Stroke = 创建按钮（按钮）
        初始化事件（按钮）

        函数按钮：添加按钮（...）
            本地信息 = GetInfo(...)

            本地子按钮 = {
                文本 = 信息文本，
                函数 = 信息.函数，
                双击 = 信息.双击，

                工具提示 = 信息.工具提示，
                DisabledTooltip = Info.DisabledTooltip，
                工具提示表 = 零，

                风险 = 信息风险，
                已禁用 = Info.Disabled，
                可见 = 信息可见，

                吐温 = 零，
                类型 = “子按钮”，
            }

            按钮.子按钮 = 子按钮
            SubButton.Base，SubButton.Stroke = CreateButton（SubButton）
            初始化事件（子按钮）

            函数 SubButton:UpdateColors()
                如果 Library.Unloaded 则
                    返回
                结尾

                StopTween（SubButton.Tween）

                SubButton.Base.BackgroundColor3 = SubButton.Disabled 和 Library.Scheme.BackgroundColor
                    或 Library.Scheme.MainColor
                SubButton.Base.TextTransparency = SubButton.Disabled 和 0.8 或 0.4
                SubButton.Stroke.Transparency = SubButton.Disabled 和 0.5 或 0

                Library.Registry[SubButton.Base].BackgroundColor3 = SubButton.Disabled 和 "BackgroundColor"
                    或“主色”
            结尾

            函数 SubButton:SetDisabled(Disabled: boolean)
                SubButton.Disabled = 已禁用

                如果 SubButton.TooltipTable 那么
                    SubButton.TooltipTable.Disabled = SubButton.Disabled
                结尾

                SubButton.Base.Active = 不是 SubButton.Disabled
                子按钮：更新颜色（）
            结尾

            函数 SubButton:SetVisible(Visible: boolean)
                SubButton.Visible = 可见

                子按钮.Base.Visible = 子按钮.Visible
                组框：调整大小（）
            结尾

            函数 SubButton:SetText(Text: string)
                SubButton.Text = 文本
                SubButton.Base.Text = 文本
            结尾

            如果 typeof(SubButton.Tooltip) == "string" 或 typeof(SubButton.DisabledTooltip) == "string" 那么
                SubButton.TooltipTable =
                    库：AddTooltip（SubButton.Tooltip，SubButton.DisabledTooltip，SubButton.Base）
                SubButton.TooltipTable.Disabled = SubButton.Disabled
            结尾

            如果 SubButton.Risky 那么
                SubButton.Base.TextColor3 = Library.Scheme.Red
                Library.Registry[SubButton.Base].TextColor3 = "红色"
            结尾

            子按钮：更新颜色（）

            如果 Info.Idx 那么
                按钮[Info.Idx] = 子按钮
            别的
                表格.插入（按钮，子按钮）
            结尾

            返回子按钮
        结尾

        函数按钮：UpdateColors()
            如果 Library.Unloaded 则
                返回
            结尾

            StopTween（按钮.Tween）

            Button.Base.BackgroundColor3 = Button.Disabled 和 Library.Scheme.BackgroundColor
                或 Library.Scheme.MainColor
            Button.Base.TextTransparency = Button.Disabled 和 0.8 或 0.4
            Button.Stroke.Transparency = Button.Disabled 和 0.5 或 0

            Library.Registry[Button.Base].BackgroundColor3 = Button.Disabled 和“BackgroundColor”或“MainColor”
        结尾

        函数按钮：SetDisabled（Disabled：布尔值）
            Button.Disabled = 已禁用

            如果 Button.TooltipTable 那么
                按钮.TooltipTable.Disabled = 按钮.Disabled
            结尾

            Button.Base.Active = 不是 Button.Disabled
            按钮：更新颜色（）
        结尾

        函数按钮：SetVisible（Visible：布尔值）
            按钮.可见 = 可见

            Holder.Visible = Button.Visible
            组框：调整大小（）
        结尾

        函数按钮：SetText（文本：字符串）
            按钮.文本 = 文本
            按钮.Base.Text = 文本
        结尾

        如果 typeof(Button.Tooltip) == "string" 或 typeof(Button.DisabledTooltip) == "string" 那么
            Button.TooltipTable = 库：AddTooltip（Button.Tooltip，Button.DisabledTooltip，Button.Base）
            按钮.TooltipTable.Disabled = 按钮.Disabled
        结尾

        如果按钮.Risky那么
            按钮.Base.TextColor3 = Library.Scheme.Red
            Library.Registry[Button.Base].TextColor3 = "红色"
        结尾

        按钮：更新颜色（）
        组框：调整大小（）

        按钮.Holder = Holder
        表格.插入（Groupbox.元素，按钮）

        如果 Info.Idx 那么
            按钮[Info.Idx] = 按钮
        别的
            表格.插入（按钮，按钮）
        结尾

        返回按钮
    结尾

    函数 Funcs:AddCheckbox(Idx，Info)
        信息 = 库：验证（信息，模板.切换）

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地切换 = {
            文本 = 信息文本，
            值 = Info.Default，

            工具提示 = 信息.工具提示，
            DisabledTooltip = Info.DisabledTooltip，
            工具提示表 = 零，

            回调 = 信息回调，
            已更改 = 信息已更改，

            风险 = 信息风险，
            已禁用 = Info.Disabled，
            可见 = 信息可见，
            附加组件 = {},

            类型 = “切换”，
        }

        本地按钮 = 新建（“文本按钮”，{
            Active = 未 Toggle.Disabled，
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 18),
            文本 = "",
            可见 = 切换可见，
            父级 = 容器，
        })

        本地标签 = 新建（“文本标签”，{
            背景透明度 = 1，
            位置 = UDim2.fromOffset(26, 0),
            尺寸 = UDim2.new(1, -26, 1, 0),
            文本 = 切换文本，
            文本大小 = 14，
            文本透明度 = 0.4，
            文本X对齐 = 枚举.文本X对齐.左，
            父级 = 按钮，
        })

        新的（“UIListLayout”，{
            FillDirection = Enum.FillDirection.Horizo​​ntal,
            水平对齐 = 枚举.水平对齐.右，
            填充 = UDim.new(0, 6),
            父级 = 标签，
        })

        本地复选框 = 新建（“框架”，{
            背景颜色3 = "主颜色",
            尺寸 = UDim2.fromScale(1, 1),
            SizeConstraint = Enum.SizeConstraint.RelativeYY，
            父级 = 按钮，
        })
        新的（“UICorner”，{
            角半径 = UDim.new(0, 库.角半径 / 2),
            父级 = 复选框，
        })

        本地 CheckboxStroke = New("UIStroke", {
            颜色 = “轮廓颜色”，
            父级 = 复选框，
        })

        本地 CheckImage = New("ImageLabel", {
            Image = CheckIcon 和 CheckIcon.Url 或“”
            ImageColor3 = "字体颜色",
            ImageRectOffset = CheckIcon 和 CheckIcon.ImageRectOffset 或 Vector2.zero，
            ImageRectSize = CheckIcon 和 CheckIcon.ImageRectSize 或 Vector2.zero，
            图像透明度 = 1，
            位置 = UDim2.fromOffset(2, 2),
            尺寸 = UDim2.new(1, -4, 1, -4),
            父级 = 复选框，
        })

        函数切换：更新颜色（）
            切换：显示()
        结尾

        函数切换：显示（）
            如果 Library.Unloaded 则
                返回
            结尾

            CheckboxStroke.Transparency = Toggle.Disabled 和 0.5 或 0

            如果 Toggle.Disabled 那么
                标签.文本透明度 = 0.8
                CheckImage.ImageTransparency = Toggle.Value 和 0.8 或 1

                Checkbox.BackgroundColor3 = Library.Scheme.BackgroundColor
                Library.Registry[Checkbox].BackgroundColor3 = "背景颜色"

                返回
            结尾

            TweenService：创建（标签，Library.TweenInfo，{
                TextTransparency = Toggle.Value 和 0 或 0.4，
            }）：玩（）
            TweenService：创建（CheckImage，Library.TweenInfo，{
                ImageTransparency = Toggle.Value 和 0 或 1，
            }）：玩（）

            Checkbox.BackgroundColor3 = Library.Scheme.MainColor
            库.注册表[复选框].BackgroundColor3 = "主颜色"
        结尾

        函数切换：OnChanged（Func）
            Toggle.Changed = Func
        结尾

        函数切换：设置值（值）
            如果 Toggle.Disabled 那么
                返回
            结尾

            切换.值 = 值
            切换：显示()

            对于 _，Addon 成对（Toggle.Addons）执行
                如果 Addon.Type == "KeyPicker" 并且 Addon.SyncToggleState 那么
                    Addon.Toggled = Toggle.Value
                    插件：更新（）
                结尾
            结尾

            库：SafeCallback（Toggle.Callback，Toggle.Value）
            库：SafeCallback（Toggle.Changed，Toggle.Value）
            库：UpdateDependencyBoxes()
        结尾

        函数 Toggle:SetDisabled（Disabled：布尔值）
            Toggle.Disabled = 已禁用

            如果 Toggle.TooltipTable 那么
                Toggle.TooltipTable.Disabled = Toggle.Disabled
            结尾

            对于 _，Addon 成对（Toggle.Addons）执行
                如果 Addon.Type == "KeyPicker" 并且 Addon.SyncToggleState 那么
                    插件：更新（）
                结尾
            结尾

            Button.Active = 不 Toggle.Disabled
            切换：显示()
        结尾

        函数切换：SetVisible（Visible：布尔值）
            Toggle.Visible = 可见

            按钮.可见 = 切换.可见
            组框：调整大小（）
        结尾

        函数切换：SetText（文本：字符串）
            切换.文本 = 文本
            标签.文本 = 文本
        结尾

        Button.MouseButton1Click:连接（函数（）
            如果 Toggle.Disabled 那么
                返回
            结尾

            Toggle:SetValue（不是 Toggle.Value）
        结尾）

        如果 typeof(Toggle.Tooltip) == "string" 或 typeof(Toggle.DisabledTooltip) == "string" 那么
            Toggle.TooltipTable = Library:AddTooltip(Toggle.Tooltip, Toggle.DisabledTooltip, Button)
            Toggle.TooltipTable.Disabled = Toggle.Disabled
        结尾

        如果 Toggle.Risky 那么
            Label.TextColor3 = Library.Scheme.Red
            Library.Registry[Label].TextColor3 = "红色"
        结尾

        切换：显示()
        组框：调整大小（）

        Toggle.TextLabel = 标签
        Toggle.Container = 容器
        设置metatable（切换，BaseAddons）

        Toggle.Holder = 按钮
        表格.插入（Groupbox.Elements，切换）

        切换[Idx] = 切换

        返回切换
    结尾

    函数 Funcs:AddToggle(Idx，Info)
        如果 Library.ForceCheckbox 那么
            返回 Funcs.AddCheckbox（self，Idx，Info）
        结尾

        信息 = 库：验证（信息，模板.切换）

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地切换 = {
            文本 = 信息文本，
            值 = Info.Default，

            工具提示 = 信息.工具提示，
            DisabledTooltip = Info.DisabledTooltip，
            工具提示表 = 零，

            回调 = 信息回调，
            已更改 = 信息已更改，

            风险 = 信息风险，
            已禁用 = Info.Disabled，
            可见 = 信息可见，
            附加组件 = {},

            类型 = “切换”，
        }

        本地按钮 = 新建（“文本按钮”，{
            Active = 未 Toggle.Disabled，
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 18),
            文本 = "",
            可见 = 切换可见，
            父级 = 容器，
        })

        本地标签 = 新建（“文本标签”，{
            背景透明度 = 1，
            尺寸 = UDim2.new(1, -40, 1, 0),
            文本 = 切换文本，
            文本大小 = 14，
            文本透明度 = 0.4，
            文本X对齐 = 枚举.文本X对齐.左，
            父级 = 按钮，
        })

        新的（“UIListLayout”，{
            FillDirection = Enum.FillDirection.Horizo​​ntal,
            水平对齐 = 枚举.水平对齐.右，
            填充 = UDim.new(0, 6),
            父级 = 标签，
        })

        本地 Switch = New("Frame", {
            锚点 = Vector2.new(1, 0),
            背景颜色3 = "主颜色",
            位置 = UDim2.fromScale(1, 0),
            大小 = UDim2.fromOffset(32, 18),
            父级 = 按钮，
        })
        新的（“UICorner”，{
            角半径 = UDim.new(1, 0),
            父级 = 开关，
        })
        新的（“UIPadding”，{
            PaddingBottom = UDim.new(0, 2),
            PaddingLeft = UDim.new(0, 2),
            PaddingRight = UDim.new(0, 2),
            PaddingTop = UDim.new(0, 2),
            父级 = 开关，
        })
        本地 SwitchStroke = New("UIStroke", {
            颜色 = “轮廓颜色”，
            父级 = 开关，
        })

        本地球 = 新的（“框架”，{
            BackgroundColor3 = "字体颜色",
            尺寸 = UDim2.fromScale(1, 1),
            SizeConstraint = Enum.SizeConstraint.RelativeYY，
            父级 = 开关，
        })
        新的（“UICorner”，{
            角半径 = UDim.new(1, 0),
            父级 = 球，
        })

        函数切换：更新颜色（）
            切换：显示()
        结尾

        函数切换：显示（）
            如果 Library.Unloaded 则
                返回
            结尾

            本地偏移量 = Toggle.Value 和 1 或 0

            Switch.BackgroundTransparency = Toggle.Disabled 和 0.75 或 0
            SwitchStroke.Transparency = Toggle.Disabled 和 0.75 或 0

            Switch.BackgroundColor3 = Toggle.Value 和 Library.Scheme.AccentColor 或 Library.Scheme.MainColor
            SwitchStroke.Color = Toggle.Value 和 Library.Scheme.AccentColor 或 Library.Scheme.OutlineColor

            Library.Registry[Switch].BackgroundColor3 = Toggle.Value 和“AccentColor”或“MainColor”
            Library.Registry[SwitchStroke].Color = Toggle.Value 和“AccentColor”或“OutlineColor”

            如果 Toggle.Disabled 那么
                标签.文本透明度 = 0.8
                Ball.AnchorPoint = Vector2.new(偏移量，0)
                球.位置 = UDim2.fromScale(偏移量，0)

                Ball.BackgroundColor3 = 库：GetDarkerColor（Library.Scheme.FontColor）
                Library.Registry[Ball].BackgroundColor3 = function()
                    返回库：GetDarkerColor（Library.Scheme.FontColor）
                结尾

                返回
            结尾

            TweenService：创建（标签，Library.TweenInfo，{
                TextTransparency = Toggle.Value 和 0 或 0.4，
            }）：玩（）
            TweenService：创建（Ball，Library.TweenInfo，{
                锚点 = Vector2.new(偏移量，0)，
                位置 = UDim2.fromScale(偏移量，0)，
            }）：玩（）

            Ball.BackgroundColor3 = Library.Scheme.FontColor
            Library.Registry[Ball].BackgroundColor3 = "字体颜色"
        结尾

        函数切换：OnChanged（Func）
            Toggle.Changed = Func
        结尾

        函数切换：设置值（值）
            如果 Toggle.Disabled 那么
                返回
            结尾

            切换.值 = 值
            切换：显示()

            对于 _，Addon 成对（Toggle.Addons）执行
                如果 Addon.Type == "KeyPicker" 并且 Addon.SyncToggleState 那么
                    Addon.Toggled = Toggle.Value
                    插件：更新（）
                结尾
            结尾

            库：SafeCallback（Toggle.Callback，Toggle.Value）
            库：SafeCallback（Toggle.Changed，Toggle.Value）
            库：UpdateDependencyBoxes()
        结尾

        函数 Toggle:SetDisabled（Disabled：布尔值）
            Toggle.Disabled = 已禁用

            如果 Toggle.TooltipTable 那么
                Toggle.TooltipTable.Disabled = Toggle.Disabled
            结尾

            对于 _，Addon 成对（Toggle.Addons）执行
                如果 Addon.Type == "KeyPicker" 并且 Addon.SyncToggleState 那么
                    插件：更新（）
                结尾
            结尾

            Button.Active = 不 Toggle.Disabled
            切换：显示()
        结尾

        函数切换：SetVisible（Visible：布尔值）
            Toggle.Visible = 可见

            按钮.可见 = 切换.可见
            组框：调整大小（）
        结尾

        函数切换：SetText（文本：字符串）
            切换.文本 = 文本
            标签.文本 = 文本
        结尾

        Button.MouseButton1Click:连接（函数（）
            如果 Toggle.Disabled 那么
                返回
            结尾

            Toggle:SetValue（不是 Toggle.Value）
        结尾）

        如果 typeof(Toggle.Tooltip) == "string" 或 typeof(Toggle.DisabledTooltip) == "string" 那么
            Toggle.TooltipTable = Library:AddTooltip(Toggle.Tooltip, Toggle.DisabledTooltip, Button)
            Toggle.TooltipTable.Disabled = Toggle.Disabled
        结尾

        如果 Toggle.Risky 那么
            Label.TextColor3 = Library.Scheme.Red
            Library.Registry[Label].TextColor3 = "红色"
        结尾

        切换：显示()
        组框：调整大小（）

        Toggle.TextLabel = 标签
        Toggle.Container = 容器
        设置metatable（切换，BaseAddons）

        Toggle.Holder = 按钮
        表格.插入（Groupbox.Elements，切换）

        切换[Idx] = 切换

        返回切换
    结尾

    函数 Funcs:AddInput(Idx，Info)
        信息 = 库：验证（信息，模板.输入）

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地输入 = {
            文本 = 信息文本，
            值 = Info.Default，
            完成 = 信息完成，
            数字 = 信息数字，
            ClearTextOnFocus = Info.ClearTextOnFocus，
            占位符 = 信息占位符，
            允许空 = 信息.允许空，
            EmptyReset = Info.EmptyReset，

            工具提示 = 信息.工具提示，
            DisabledTooltip = Info.DisabledTooltip，
            工具提示表 = 零，

            回调 = 信息回调，
            已更改 = 信息已更改，

            已禁用 = Info.Disabled，
            可见 = 信息可见，

            类型 = “输入”，
        }

        本地 Holder = New("Frame", {
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 39),
            可见 = 输入.可见，
            父级 = 容器，
        })

        本地标签 = 新建（“文本标签”，{
            背景透明度 = 1，
            尺寸 = UDim2.new(1, 0, 0, 14),
            文本 = 输入.文本，
            文本大小 = 14，
            文本X对齐 = 枚举.文本X对齐.左，
            父母=持有人，
        })

        本地 Box = New("文本框", {
            锚点 = Vector2.new(0, 1),
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            ClearTextOnFocus = 不是 Input.Disabled 和 Input.ClearTextOnFocus，
            占位符文本 = 输入.占位符，
            位置 = UDim2.fromScale(0, 1),
            尺寸 = UDim2.new(1, 0, 0, 21),
            文本 = 输入.值，
            TextEditable = 未输入禁用，
            文本缩放 = 真，
            文本X对齐 = 枚举.文本X对齐.左，
            父母=持有人，
        })

        新的（“UIPadding”，{
            PaddingBottom = UDim.new(0, 3),
            PaddingLeft = UDim.new(0, 8),
            PaddingRight = UDim.new(0, 8),
            PaddingTop = UDim.new(0, 4),
            父级 = Box，
        })

        函数输入：UpdateColors()
            如果 Library.Unloaded 则
                返回
            结尾

            Label.TextTransparency = Input.Disabled 和 0.8 或 0
            Box.TextTransparency = Input.Disabled 和 0.8 或 0
        结尾

        函数输入：OnChanged（Func）
            输入.改变=函数
        结尾

        函数输入：SetValue（文本）
            如果不是 Input.AllowEmpty 且 Trim(Text) == "" 那么
                文本 = 输入.EmptyReset
            结尾

            如果 Info.MaxLength 和 #Text > Info.MaxLength 那么
                文本 = 文本：sub（1，Info.MaxLength）
            结尾

            如果输入数字则
                如果 #Text > 0 且不是 tonumber(Text) 则
                    文本 = 输入.值
                结尾
            结尾

            输入.值 = 文本
            框.文本 = 文本

            如果不是 Input.Disabled，那么
                库：SafeCallback（Input.Callback，Input.Value）
                库：SafeCallback（输入.更改，输入.值）
            结尾
        结尾

        函数输入：SetDisabled（Disabled：布尔值）
            输入.禁用 = 已禁用

            如果输入.TooltipTable那么
                Input.TooltipTable.Disabled = Input.Disabled
            结尾

            Box.ClearTextOnFocus = 非 Input.Disabled 和 Input.ClearTextOnFocus
            Box.TextEditable = 不是 Input.Disabled
            输入：UpdateColors()
        结尾

        函数输入：SetVisible（Visible：布尔值）
            输入.可见 = 可见

            Holder.Visible = Input.Visible
            组框：调整大小（）
        结尾

        函数输入：SetText（文本：字符串）
            输入.文本 = 文本
            标签.文本 = 文本
        结尾

        如果输入完成则
            Box.FocusLost:连接（函数（输入）
                如果没有输入则
                    返回
                结尾

                输入：SetValue（Box.Text）
            结尾）
        别的
            框：GetPropertyChangedSignal（“文本”）：连接（函数（）
                输入：SetValue（Box.Text）
            结尾）
        结尾

        如果 typeof(Input.Tooltip) == "string" 或 typeof(Input.DisabledTooltip) == "string" 那么
            Input.TooltipTable = Library:AddTooltip(Input.Tooltip, Input.DisabledTooltip, Box)
            Input.TooltipTable.Disabled = Input.Disabled
        结尾

        组框：调整大小（）

        输入.持有人=持有人
        表.插入（Groupbox.元素，输入）

        选项[Idx] = 输入

        返回输入
    结尾

    函数 Funcs:AddSlider(Idx，Info)
        信息 = 库：验证（信息，模板.滑块）

        本地 Groupbox = 自身
        本地容器 = Groupbox.Container

        本地滑块 = {
            文本 = 信息文本，
            值 = Info.Default，
            Min = Info.Min，
            最大值 = 信息最大值，

            前缀 = 信息前缀，
            后缀 = 信息后缀，
            紧凑 = 信息紧凑，
            舍入 = Info.Rounding，

            工具提示 = 信息.工具提示，
            DisabledTooltip = Info.DisabledTooltip，
            工具提示表 = 零，

            回调 = 信息回调，
            已更改 = 信息已更改，

            已禁用 = Info.Disabled，
            可见 = 信息可见，

            类型 = “滑块”，
        }

        本地 Holder = New("Frame", {
            背景透明度 = 1，
            Size = UDim2.new(1, 0, 0, Info.Compact 和 13 或 31)，
            可见 = 滑块.可见，
            父级 = 容器，
        })

        本地 SliderLabel
        如果不是 Info.Compact 那么
            SliderLabel = New("文本标签", {
                背景透明度 = 1，
                尺寸 = UDim2.new(1, 0, 0, 14),
                文本 = 滑块.文本，
                文本大小 = 14，
                文本X对齐 = 枚举.文本X对齐.左，
                父母=持有人，
            })
        结尾

        本地 Bar = New("TextButton", {
            Active = 未 Slider.Disabled，
            锚点 = Vector2.new(0, 1),
            背景颜色3 = "主颜色",
            BorderColor3 = "轮廓颜色",
            边框尺寸像素 = 1，
            位置 = UDim2.fromScale(0, 1),
            尺寸 = UDim2.new(1, 0, 0, 13),
            文本 = "",
            父母=持有人，
        })

        本地 DisplayLabel = New("TextLabel", {
            背景透明度 = 1，
            尺寸 = UDim2.fromScale(1, 1),
            文本 = "",
            文本大小 = 14，
            ZIndex = 2，
            父级 = Bar，
        })
        新的（“UIStroke”，{
            ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual，
            颜色 =“深色”，
            LineJoinMode = Enum.LineJoinMode.Miter，
            父级 = DisplayLabel，
        })
…"
 https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua#:~:text=%E6%9C%AC%E5%9C%B0%20cloneref%20%3D%20(cloneref,Library%0A%E8%BF%94%E5%9B%9E%E5%BA%93